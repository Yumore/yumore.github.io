<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>面试问题集锦 | Nathaniel</title>
  <meta name="keywords" content=" Android , 面试 ">
  <meta name="description" content="面试问题集锦 | Nathaniel">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="WeChat加我微信 QQ448216285  EmailContact me 开不开心 意不意外 惊不惊喜 啪叽没了">
<meta property="og:type" content="website">
<meta property="og:title" content="关于我">
<meta property="og:url" content="http://example.com/about/index.html">
<meta property="og:site_name" content="Nathaniel">
<meta property="og:description" content="WeChat加我微信 QQ448216285  EmailContact me 开不开心 意不意外 惊不惊喜 啪叽没了">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/about.png">
<meta property="article:published_time" content="2020-12-21T09:21:33.000Z">
<meta property="article:modified_time" content="2023-11-06T14:59:19.000Z">
<meta property="article:author" content="Nathaniel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/about.png">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>Nathaniel</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/Yumore"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="facebook"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-facebook"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
            <a title="instagram"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-instagram"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="reddit"
               href="https://www.reddit.com/user/yelog/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-reddit"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="weibo"
               href="http://weibo.com/u/2307534817"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-weibo"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="jianshu"
               href="https://www.jianshu.com/u/ff56736de7cf"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-jianshu"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/people/jaytp/activities"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="oschina"
               href="https://my.oschina.net/yelog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-oschina"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="email"
               href="mailto:nathanwriting@126.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=448216285&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="kugou"
               href="https://www.kugou.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-kugou"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="neteasemusic"
               href="https://music.163.com/#/user/home?id=88151013"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-neteasemusic"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(46)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="工具">
            
            工具
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="测试">
            
            测试
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="开发规范">
            
            开发规范
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="软技能">
            
            软技能
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Android">
            
            Android
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="blog">
            
            blog
            <small>(33)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Interview">
            
            Interview
            <small>(3)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="46">
<input type="hidden" id="yelog_site_word_count" value="487.7k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="https://yumore.github.io/">Yumore</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>-Framework -AndroidStudio</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>测试</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>架构</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>开发规范</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>面试</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>软技能</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>源码编译</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>运维</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>android</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Android</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>AndroidStudio</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>APP</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Automotive</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Blogger</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>CentOS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>dart</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>FFmpeg</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Flutter</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>git</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Git</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>gRPC</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>hexo</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Keep Live</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Kotlin</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Linux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>MacOS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>MariaDB</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Markdown</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>mvx</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>nodejs</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Optimistic</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Powershell</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Problem</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Q-A</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Raspbian</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Shell</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Ubuntu</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>v2ray xray v2raya</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>View</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        
        <a id="top" class="全部文章 Interview "
           href="/2021/03/29/android-interview-addition/"
           data-tag="Android,面试"
           data-author="" >
            <span class="post-title" title="面试问题集锦">面试问题集锦</span>
            <span class="post-date" title="2021-03-29 14:01:47">2021/03/29</span>
        </a>
        
        
        <a id="top" class="全部文章 blog "
           href="/2021/03/01/kotlin-notes/"
           data-tag="Android,Kotlin"
           data-author="" >
            <span class="post-title" title="Kotlin学习笔记">Kotlin学习笔记</span>
            <span class="post-date" title="2021-03-01 10:28:59">2021/03/01</span>
        </a>
        
        
        <a id="top" class="全部文章 软技能 "
           href="/2021/02/22/keep-your-mind/"
           data-tag="软技能"
           data-author="" >
            <span class="post-title" title="灵魂之力—自控力的强大威力">灵魂之力—自控力的强大威力</span>
            <span class="post-date" title="2021-02-22 10:43:00">2021/02/22</span>
        </a>
        
        
        <a id="top" class="全部文章 Interview "
           href="/2021/01/27/android-interview/"
           data-tag="Android,面试"
           data-author="" >
            <span class="post-title" title="Android高级面试题">Android高级面试题</span>
            <span class="post-date" title="2021-01-27 16:01:47">2021/01/27</span>
        </a>
        
        
        <a id="top" class="全部文章 Interview "
           href="/2021/04/18/android-knowledge/"
           data-tag="Android,面试"
           data-author="" >
            <span class="post-title" title="Android知识点汇总">Android知识点汇总</span>
            <span class="post-date" title="2021-04-18 16:01:47">2021/04/18</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/20222/09/18/powershell-ohmyzsh/"
           data-tag="Powershell"
           data-author="" >
            <span class="post-title" title="Powershell美化">Powershell美化</span>
            <span class="post-date" title="20222-09-18 16:52:00">20222/09/18</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2025/04/13/v2raya-ubuntu/"
           data-tag="v2ray xray v2raya"
           data-author="" >
            <span class="post-title" title="v2raya-ubuntu">v2raya-ubuntu</span>
            <span class="post-date" title="2025-04-13 19:54:44">2025/04/13</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2025/01/03/framework-jar-for-android/"
           data-tag="-Framework -AndroidStudio"
           data-author="" >
            <span class="post-title" title="framework-jar-for-android">framework-jar-for-android</span>
            <span class="post-date" title="2025-01-03 23:48:12">2025/01/03</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2024/01/10/android-automotive-permission/"
           data-tag="Android,Automotive"
           data-author="" >
            <span class="post-title" title="android automotive permission">android automotive permission</span>
            <span class="post-date" title="2024-01-10 21:57:50">2024/01/10</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/11/17/android-aosp-make-md/"
           data-tag="Android,源码编译"
           data-author="" >
            <span class="post-title" title="Android源码编译">Android源码编译</span>
            <span class="post-date" title="2023-11-17 21:08:05">2023/11/17</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/11/16/android-vehicle-property/"
           data-tag="Android,Blogger"
           data-author="" >
            <span class="post-title" title="Android Vehicle Property">Android Vehicle Property</span>
            <span class="post-date" title="2023-11-16 22:59:46">2023/11/16</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2022/11/20/flutter-interview/"
           data-tag="Android,Flutter"
           data-author="" >
            <span class="post-title" title="Flutter 学习笔记">Flutter 学习笔记</span>
            <span class="post-date" title="2022-11-20 15:28:59">2022/11/20</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2022/10/05/git-config/"
           data-tag="git"
           data-author="" >
            <span class="post-title" title="git_config">git_config</span>
            <span class="post-date" title="2022-10-05 07:15:36">2022/10/05</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2022/09/28/Ubuntu-Using/"
           data-tag="Ubuntu"
           data-author="" >
            <span class="post-title" title="Ubuntu日常使用">Ubuntu日常使用</span>
            <span class="post-date" title="2022-09-28 13:10:27">2022/09/28</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/C++%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="C++知识点汇总">C++知识点汇总</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/Android%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86%E7%82%B9/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Android扩展知识点">Android扩展知识点</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Android知识点汇总">Android知识点汇总</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/Gradle%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Gradle知识点汇总">Gradle知识点汇总</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Java知识点汇总">Java知识点汇总</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/Kotlin%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Kotlin知识点汇总">Kotlin知识点汇总</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/Android%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="开源源码库分析">开源源码库分析</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/android-view/"
           data-tag="Android,View"
           data-author="" >
            <span class="post-title" title="View绘制流程">View绘制流程</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/Framework%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Framework知识点汇总">Framework知识点汇总</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="网络知识汇总">网络知识汇总</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B1%87%E6%80%BB/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="常见设计模式汇总">常见设计模式汇总</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98%E6%B1%87%E6%80%BB/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="常见算法汇总">常见算法汇总</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="性能优化知识点汇总">性能优化知识点汇总</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="音视频知识点汇总">音视频知识点汇总</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/08/android-problem-collection/"
           data-tag="Android,Problem,Q-A"
           data-author="" >
            <span class="post-title" title="Android问题集锦">Android问题集锦</span>
            <span class="post-date" title="2021-04-08 11:04:47">2021/04/08</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/03/19/android-optimization/"
           data-tag="Android,Optimistic"
           data-author="" >
            <span class="post-title" title="Android性能优化">Android性能优化</span>
            <span class="post-date" title="2021-03-19 11:04:47">2021/03/19</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/03/08/update-git-shell-v2/"
           data-tag="Shell,运维"
           data-author="" >
            <span class="post-title" title="shell 批量更新多个git仓库 v2">shell 批量更新多个git仓库 v2</span>
            <span class="post-date" title="2021-03-08 10:29:37">2021/03/08</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/02/24/fragment-data-activity/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Fragment和Activity通信">Fragment和Activity通信</span>
            <span class="post-date" title="2021-02-24 11:40:28">2021/02/24</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/02/14/update-git-shell/"
           data-tag="Shell,Git"
           data-author="" >
            <span class="post-title" title="shell 批量更新多个git仓库">shell 批量更新多个git仓库</span>
            <span class="post-date" title="2021-02-14 12:26:56">2021/02/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2020/11/20/ffmpeg-build/"
           data-tag="Android,FFmpeg,MacOS"
           data-author="" >
            <span class="post-title" title="MacOS下基于NDK编译FFmpeg">MacOS下基于NDK编译FFmpeg</span>
            <span class="post-date" title="2020-11-20 15:28:59">2020/11/20</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2020/11/19/android-mvx/"
           data-tag="android,mvx"
           data-author="" >
            <span class="post-title" title="Android-UI架构演进">Android-UI架构演进</span>
            <span class="post-date" title="2020-11-19 15:28:59">2020/11/19</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2020/11/19/dart-gRPC/"
           data-tag="dart,gRPC"
           data-author="" >
            <span class="post-title" title="Dart-gPRC">Dart-gPRC</span>
            <span class="post-date" title="2020-11-19 15:28:59">2020/11/19</span>
        </a>
        
        
        <a  class="全部文章 工具 "
           href="/2020/10/19/android-studio/"
           data-tag="AndroidStudio"
           data-author="" >
            <span class="post-title" title="Android Studio 使用问题">Android Studio 使用问题</span>
            <span class="post-date" title="2020-10-19 16:01:47">2020/10/19</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2020/10/19/hexo-for-node/"
           data-tag="hexo,nodejs"
           data-author="" >
            <span class="post-title" title="Node环境下Hexo的搭建">Node环境下Hexo的搭建</span>
            <span class="post-date" title="2020-10-19 15:28:59">2020/10/19</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2020/09/19/keep-app-alive/"
           data-tag="Android,Keep Live"
           data-author="" >
            <span class="post-title" title="Android保活技术实现">Android保活技术实现</span>
            <span class="post-date" title="2020-09-19 15:28:59">2020/09/19</span>
        </a>
        
        
        <a  class="全部文章 测试 "
           href="/2020/08/29/app-test-helper/"
           data-tag="APP,测试"
           data-author="" >
            <span class="post-title" title="手机APP测试">手机APP测试</span>
            <span class="post-date" title="2020-08-29 16:01:47">2020/08/29</span>
        </a>
        
        
        <a  class="全部文章 Android "
           href="/2020/08/28/android-architecture/"
           data-tag="Android,架构"
           data-author="" >
            <span class="post-title" title="Android 架构技术演进">Android 架构技术演进</span>
            <span class="post-date" title="2020-08-28 14:01:47">2020/08/28</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2020/08/19/kotlin-learning/"
           data-tag="Android,Kotlin"
           data-author="" >
            <span class="post-title" title="Kotlin笔记">Kotlin笔记</span>
            <span class="post-date" title="2020-08-19 15:28:59">2020/08/19</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2020/07/19/MariaDB-on-CentOS/"
           data-tag="CentOS,MariaDB"
           data-author="" >
            <span class="post-title" title="在CentOS7中安装MariaDB">在CentOS7中安装MariaDB</span>
            <span class="post-date" title="2020-07-19 15:28:59">2020/07/19</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2020/05/19/markdown-note/"
           data-tag="Markdown"
           data-author="" >
            <span class="post-title" title="Markdown编辑器语法指南">Markdown编辑器语法指南</span>
            <span class="post-date" title="2020-05-19 15:28:59">2020/05/19</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2020/03/27/using-raspberry/"
           data-tag="Linux,Raspbian"
           data-author="" >
            <span class="post-title" title="树莓派的使用笔记">树莓派的使用笔记</span>
            <span class="post-date" title="2020-03-27 00:16:31">2020/03/27</span>
        </a>
        
        
        <a  class="全部文章 开发规范 "
           href="/2019/05/01/constraint-for-android/"
           data-tag="Android,开发规范"
           data-author="" >
            <span class="post-title" title="关于Android的开发规范">关于Android的开发规范</span>
            <span class="post-date" title="2019-05-01 15:29:59">2019/05/01</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-android-interview-addition" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">面试问题集锦</h1>
    
    <div class="article-meta">
        
        <span class="top"><a>置顶</a></span>
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="Interview">Interview</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color3">Android</a>
            
            <a class="color3">面试</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2023-11-06 22:59:18'>2021-03-29 14:01</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:22.7k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6"><span class="toc-text">问题集锦</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ArrayList%E3%80%81LinkedList%E3%80%81HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-text">1.ArrayList、LinkedList、HashMap线程安全和替代方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9"><span class="toc-text">1.1 数组动态扩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-text">1.2动态扩容的集合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-SharePreferences%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88MMKV%E5%8F%8A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E2%80%93MMKV%E4%BD%BF%E7%94%A8Ashmem%E5%8C%BF%E5%90%8D%E5%86%85%E5%AD%98"><span class="toc-text">2.SharePreferences线程安全和替代方案MMKV及底层原理–MMKV使用Ashmem匿名内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-OOM-JVM%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-text">3.OOM-JVM导致的内存泄露</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%9C%BA%E6%99%AF"><span class="toc-text">内存泄漏场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-text">解决思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-text">代码优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM%E5%A0%86%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%90%8E%EF%BC%8C%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E5%8F%AF%E5%90%A6%E7%BB%A7%E7%BB%AD%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-text">JVM堆内存溢出后，其他线程可否继续工作？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-OkHttp%E5%8F%8A%E9%BB%98%E8%AE%A4%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%8C%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">4.OkHttp及默认拦截器，与自定义拦截器的执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%8E%B7%E5%8F%96%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="toc-text">5.线程池获取实例的方法和参数列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-OKHttp%E5%92%8CHtttpURLConnection%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">6.OKHttp和HtttpURLConnection的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Binder%E5%8E%9F%E7%90%86%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8"><span class="toc-text">7.Binder原理及为什么采用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-TCP%E5%92%8CUDP%E5%9C%A8%E6%8A%A5%E6%96%87%E4%B8%8A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">8.TCP和UDP在报文上有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88ScreenMatch-SmallWidth"><span class="toc-text">9.屏幕适配方案ScreenMatch(SmallWidth)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Kotlin%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-text">10.Kotlin协程实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-synchronized%E5%92%8Cvolatile%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">11.synchronized和volatile的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-HashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E%E5%8F%8A%E6%89%A9%E5%AE%B9%E6%96%B9%E6%A1%88"><span class="toc-text">12.HashMap的实现和哈希碰撞及扩容方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BroadcastReceiver%E4%B8%8ELocalBroadcastManager%E5%BA%94%E7%94%A8%E5%8F%8A%E5%8C%BA%E5%88%AB"><span class="toc-text">BroadcastReceiver与LocalBroadcastManager应用及区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0-DiskLRUCache%E5%AE%9E%E7%8E%B0-LRU%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%89"><span class="toc-text">13.缓存实现 DiskLRUCache实现  LRU数据结构（双向链表）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="toc-text">AOP编程思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E6%82%B2%E8%A7%82%E9%94%81%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81%E3%80%81%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81%E3%80%81%E5%90%84%E7%A7%8D%E9%94%81%E5%8F%8A%E5%85%B6Java%E5%AE%9E%E7%8E%B0"><span class="toc-text">14.悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量&#x2F;重量级锁、读写锁、各种锁及其Java实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARouter%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">ARouter源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-text">注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Launcher%E8%A2%AB%E6%9D%80%E6%AD%BB"><span class="toc-text">Launcher被杀死</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Camera1-Camera2-CameraX%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="toc-text">Camera1 Camera2 CameraX的演进</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Camera1"><span class="toc-text">Camera1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Camera2"><span class="toc-text">Camera2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Multi-Camera"><span class="toc-text">Multi-Camera</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CameraX"><span class="toc-text">CameraX</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%B1%BB"><span class="toc-text">核心类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CameraManager"><span class="toc-text">CameraManager</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CameraDevice"><span class="toc-text">CameraDevice</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CameraCharacteristics"><span class="toc-text">CameraCharacteristics</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CaptureRequest"><span class="toc-text">CaptureRequest</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CaptureRequest-Builder"><span class="toc-text">CaptureRequest.Builder</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CameraCaptureSession"><span class="toc-text">CameraCaptureSession</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ImageReader"><span class="toc-text">ImageReader</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MediaCodec-MediaMuxer"><span class="toc-text">MediaCodec MediaMuxer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SurfaceView-TextureView-SurfaceTexture%E7%AD%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">SurfaceView TextureView SurfaceTexture等的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SurfaceView"><span class="toc-text">SurfaceView</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TextureView"><span class="toc-text">TextureView</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SurfaceTexture"><span class="toc-text">SurfaceTexture</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GLSurfaceView"><span class="toc-text">GLSurfaceView</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%B8%E6%9C%BA%E5%AE%9E%E7%8E%B0"><span class="toc-text">自定义相机实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SurfaceView%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">SurfaceView生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89View%E9%9C%80%E8%A6%81%E9%87%8D%E5%86%99%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">自定义View需要重写的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%96%E5%88%B0view%E7%9A%84%E5%AE%BD%E9%AB%98"><span class="toc-text">自定义View什么时候可以获取到view的宽高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#onTouchEvent-%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BD%9C%E7%94%A8"><span class="toc-text">onTouchEvent()返回值作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84Http-Https%E8%AF%B7%E6%B1%82"><span class="toc-text">一次完整的Http&#x2F;Https请求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E4%B8%8EHTTPS%E7%9A%84%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="toc-text">HTTP与HTTPS的不同点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">HTTPS的优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B"><span class="toc-text">HTTPS请求过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS%E4%BC%98%E5%8C%96"><span class="toc-text">HTTPS优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Glide%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-text">Glide缓存机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Glide%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="toc-text">Glide内存优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8-%E5%BC%B1%E5%BA%94%E7%94%A8-%E8%BD%AF%E5%BC%95%E7%94%A8-%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-text">强引用 弱应用 软引用 虚引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SharedPreferences-apply%E5%92%8Ccommit%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">SharedPreferences apply和commit的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Message%E7%9A%84%E6%BA%90%E7%A0%81"><span class="toc-text">Message的源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Messenger%E4%B8%8EMessage%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Messenger与Message的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Messenger"><span class="toc-text">Messenger</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Messenge"><span class="toc-text">Messenge</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%BE%E4%BE%8B"><span class="toc-text">实现举例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAService"><span class="toc-text">1. 创建一个Service</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%A3%B0%E6%98%8E%E8%BF%9B%E7%A8%8B"><span class="toc-text">2. 声明进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BA%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">3. 创建客户端</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-text">结语</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="问题集锦"><a href="#问题集锦" class="headerlink" title="问题集锦"></a>问题集锦</h2><h3 id="1-ArrayList、LinkedList、HashMap线程安全和替代方案"><a href="#1-ArrayList、LinkedList、HashMap线程安全和替代方案" class="headerlink" title="1.ArrayList、LinkedList、HashMap线程安全和替代方案"></a>1.ArrayList、LinkedList、HashMap线程安全和替代方案</h3><p>ArryList 取值速度快（底层数据结构是数组）<br>LinkedList 插入和删除速度快（底层数据结构为链表）<br>ArrayList 线程替代方案Vector<br>线程安全：Collections.synchronizedList();<br>解决HashMap线程安全方法<br>1、继承HashMap,重写或者按要求编写自己的方法，这些方法要写成synchronized，在这些synchronized的方法中调用HashMap的方法<br>2、使用Collections.synchronizedMap()<br>3、使用ConcurrentHashMap替代，并不推荐新代码使用HashTable，HashTable继承于Dictionary，任意时间只有一个线程能写HashTable,并发性能不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。不需要线程安全的场景使用HashMap,需要线程安全的场合使用ConcurrentHashMap替换。（线程安全的ConcurrentHashMap、记录插入顺序的LinkHashMap、给key排序的TreeMap等）</p>
<h4 id="1-1-数组动态扩容"><a href="#1-1-数组动态扩容" class="headerlink" title="1.1 数组动态扩容"></a>1.1 数组动态扩容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考ArrayList源码实现</span></span><br><span class="line"><span class="type">int</span> <span class="variable">minCapacity</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">Object[] originArray = <span class="keyword">new</span> <span class="title class_">Object</span>[minCaptocity];</span><br><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> originArray.length + ariginArray.length &gt;&gt; <span class="number">1</span>; <span class="comment">// 扩容为原来的1.5倍</span></span><br><span class="line">Object[] objectArray = <span class="keyword">new</span> <span class="title class_">Object</span>[newCapacity];</span><br><span class="line">System.arryCopy(originArray, <span class="number">0</span>, objectArray, <span class="number">0</span>, originArry.length);</span><br></pre></td></tr></table></figure>
<h4 id="1-2动态扩容的集合"><a href="#1-2动态扩容的集合" class="headerlink" title="1.2动态扩容的集合"></a>1.2动态扩容的集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.datastructure.array.sample;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 支持动态扩容的数组</span></span><br><span class="line"><span class="comment"> * 初始容量为8 每次扩容2倍</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Nathaniel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-29 18:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Array</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">init_size</span> <span class="operator">=</span> <span class="number">8</span>; <span class="comment">//设定初始大小</span></span><br><span class="line">    <span class="keyword">private</span> Object [] objectArray;  <span class="comment">//存放值的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Array</span><span class="params">()</span>&#123;</span><br><span class="line">        objectArray = <span class="keyword">new</span> <span class="title class_">Object</span> [init_size];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Array(<span class="type">int</span> size)&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;数组大小不能小于等于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">8</span>)&#123;</span><br><span class="line">            size = init_size;</span><br><span class="line">        &#125;</span><br><span class="line">        objectArray = <span class="keyword">new</span> <span class="title class_">Object</span> [size];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setSize</span><span class="params">(<span class="type">int</span> size)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;数组大小不能小于等于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; objectArray.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;数组大小不能小于原数组&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (size == objectArray.length)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object [] array = <span class="keyword">new</span> <span class="title class_">Object</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; objectArray.length; i++) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> objectArray[i];</span><br><span class="line">            array[i] = o;</span><br><span class="line">        &#125;</span><br><span class="line">        objectArray = array;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;数组角标越界&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T)objectArray[index];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.size &gt; objectArray.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;出大问题了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.size == objectArray.length)&#123;</span><br><span class="line">            setSize(<span class="number">2</span> * objectArray.length);</span><br><span class="line">        &#125;</span><br><span class="line">        objectArray[size++] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-SharePreferences线程安全和替代方案MMKV及底层原理–MMKV使用Ashmem匿名内存"><a href="#2-SharePreferences线程安全和替代方案MMKV及底层原理–MMKV使用Ashmem匿名内存" class="headerlink" title="2.SharePreferences线程安全和替代方案MMKV及底层原理–MMKV使用Ashmem匿名内存"></a>2.SharePreferences线程安全和替代方案MMKV及底层原理–MMKV使用Ashmem匿名内存</h3><p>MMKV是基于mmap内存映射的移动端通用key-value组件，底层序列化&#x2F;反序列化使用protobuf实现，性能高，稳定性强<br>但protobuf不支持增量更新，所以将key-value对象序列化之后直接append到结尾，此时的同一key对应的value非唯一，所以不断替换后取最后一个value为最新有效<br>在文件大小不到1K时采取append方式，并以pagesize大小申请空间，若超过阈值1K则对key进行排重后序列化保存结果，如果此时空间还是不够用则将文件扩大一倍直到空间足够<br>在空间增长时通过crc对文件进行校验甄别无效数据<br>可存储boolean、int、long、float、double、byte[],String、Set<String>以及任何实现了Parcelable的数据类型,对象存储方式是将其转化成json串，通过字符串存储，使用的时候在取出来反序列化<br>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">rootDir</span> <span class="operator">=</span> MMKV.initialize(<span class="built_in">this</span>);</span><br><span class="line"><span class="type">MMKV</span> <span class="variable">mmkv</span> <span class="operator">=</span> MMKV.defaultMMKV();</span><br><span class="line">mmkv.encode(key,mmkv.decodeXXX(<span class="string">&quot;value&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="3-OOM-JVM导致的内存泄露"><a href="#3-OOM-JVM导致的内存泄露" class="headerlink" title="3.OOM-JVM导致的内存泄露"></a>3.OOM-JVM导致的内存泄露</h3><h4 id="内存泄漏场景"><a href="#内存泄漏场景" class="headerlink" title="内存泄漏场景"></a>内存泄漏场景</h4><ol>
<li>内存中数据量太大，比如一次性从数据库中取出来太多数据</li>
<li>静态集合类中对象的引用，在使用完后未清空(只把对象设为null，而不是从集合中移除)，使JVM不能回收，即内存泄漏</li>
<li>静态方法中只能使用全局静态变量，而如果静态变量又持有静态方法传入的参数对象的引用，会引起内存泄漏</li>
<li>代码中存在死循环，或者循环过多，产生过多的重复的对象</li>
<li>JVM启动参数内存值设置过小<br>a. 堆内存：JVM默认为64M，-Xms堆的最小值, -Xmx堆的最大值，OutOfMemoryError: java heap space<br>b. 栈内存：-Xss，StackOverflowError，栈太深<br>c. 永久代内存：-XX:PermSize，-XX:MaxPermSize，OutOfMemoryError: PermGen space，加载的类过多</li>
<li>监听器：addXXListener，没有remove</li>
<li>各种连接没有关闭：例如数据库连接、网络连接</li>
<li>单例模式：如果单例对象持有外部对象的引用，那么外部对象将不会被回收，引起内存泄漏</li>
<li>一个类含有静态变量，这个类的对象就无法被回收</li>
<li>ThreadLocal</li>
</ol>
<h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><ol>
<li>修改JVM启动参数，直接增加内存</li>
<li>检查错误日志</li>
<li>检查代码中有没有一次性查出数据库所有数据</li>
<li>检查代码中是否有死循环</li>
<li>检查代码中循环和递归是否产生大量重复对象</li>
<li>检查List&#x2F;Map等集合，是否未清除</li>
<li>使用内存查看工具</li>
</ol>
<h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><ol>
<li>主动释放无用的对象</li>
<li>尽量使用StringBuilder代替String</li>
<li>尽量少用静态变量，因为静态变量是类的，GC不会回收</li>
<li>避免创建大对象和同时创建多个对象，例如：数组，因为数组的长度是固定的</li>
<li>对象池技术</li>
</ol>
<hr>
<p>commons-pool提供了一套很好用的对象池组件，使用也很简单。<br>org.apache.commons.pool.ObjectPool定义了一个简单的池化接口，有三个对应实现，commons-pool提供了多样的集合，包括先进先出(FIFO)，后进先出(LIFO)</p>
<p>StackObjectPool ：实现了后进先出(LIFO)行为。<br>SoftReferenceObjectPool： 实现了后进先出(LIFO)行为。另外，对象池还在SoftReference 中保存了每个对象引用，允许垃圾收集器针对内存需要回收对象。</p>
<p>KeyedObjectPool定义了一个以任意的key访问对象的接口（可以池化对种对象），有两种对应实现。<br>GenericKeyedObjectPool ：实现了先进先出(FIFO)行为。<br>StackKeyedObjectPool ： 实现了后进先出(LIFO)行为。</p>
<p>PoolableObjectFactory 定义了池化对象的生命周期方法，我们可以使用它分离被池化的不同对象和管理对象的创建，持久，销毁。</p>
<p>BasePoolableObjectFactory这个实现PoolableObjectFactory接口的一个抽象类，我们可用扩展它实现自己的池化工厂。</p>
<h4 id="JVM堆内存溢出后，其他线程可否继续工作？"><a href="#JVM堆内存溢出后，其他线程可否继续工作？" class="headerlink" title="JVM堆内存溢出后，其他线程可否继续工作？"></a>JVM堆内存溢出后，其他线程可否继续工作？</h4><ol>
<li>当前线程OOM后，如果终止，会发生GC，其他线程可以继续工作</li>
<li>如果线程OOM后，没有终止，其他线程也会OOM</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">PooledObject</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">T</span> <span class="variable">objection</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">// 外界使用的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">busy</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 此对象是否正在使用的标志，默认没有正在使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，池化对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PooledObject</span><span class="params">(T objection)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.objection = objection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回此对象中的对象</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> objection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置此对象的，对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObject</span><span class="params">(T objection)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.objection = objection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得对象对象是否忙</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBusy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> busy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置对象的对象正在忙</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBusy</span><span class="params">(<span class="type">boolean</span> busy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.busy = busy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ObjectPool</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">numObjects</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 对象池的大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">maxObjects</span> <span class="operator">=</span> <span class="number">50</span>; <span class="comment">// 对象池最大的大小</span></span><br><span class="line">    <span class="keyword">protected</span> Vector&lt;PooledObject&lt;T&gt;&gt; objects = <span class="literal">null</span>; <span class="comment">// 存放对象池中对象的向量(PooledObject类型)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObjectPool</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 创建一个对象池 ***/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">createPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 确保对象池没有创建。如果创建了，保存对象的向量 objects 不会为空</span></span><br><span class="line">        <span class="keyword">if</span> (objects != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 如果己经创建，则返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建保存对象的向量 , 初始时有 0 个元素</span></span><br><span class="line">        objects = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;PooledObject&lt;T&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numObjects; i++) &#123;</span><br><span class="line">            objects.addElement(create());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> PooledObject&lt;T&gt; <span class="title function_">create</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title function_">getObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 确保对象池己被创建</span></span><br><span class="line">        <span class="keyword">if</span> (objects == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 对象池还没创建，则返回 null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> getFreeObject(); <span class="comment">// 获得一个可用的对象</span></span><br><span class="line">        <span class="comment">// 如果目前没有可以使用的对象，即所有的对象都在使用中</span></span><br><span class="line">        <span class="keyword">while</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            wait(<span class="number">250</span>);</span><br><span class="line">            t = getFreeObject(); <span class="comment">// 重新再试，直到获得可用的对象，如果</span></span><br><span class="line">            <span class="comment">// getFreeObject() 返回的为 null，则表明创建一批对象后也不可获得可用对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;<span class="comment">// 返回获得的可用的对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 本函数从对象池对象 objects 中返回一个可用的的对象，如果 当前没有可用的对象，则创建几个对象，并放入对象池中。</span></span><br><span class="line"><span class="comment">     * 如果创建后，所有的对象都在使用中，则返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T <span class="title function_">getFreeObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 从对象池中获得一个可用的对象</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> findFreeObject();</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">            createObjects(<span class="number">10</span>); <span class="comment">// 如果目前对象池中没有可用的对象，创建一些对象</span></span><br><span class="line">            <span class="comment">// 重新从池中查找是否有可用对象</span></span><br><span class="line">            obj = findFreeObject();</span><br><span class="line">            <span class="comment">// 如果创建对象后仍获得不到可用的对象，则返回 null</span></span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createObjects</span><span class="params">(<span class="type">int</span> increment)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; increment; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (objects.size() &gt; maxObjects) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            objects.addElement(create());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找对象池中所有的对象，查找一个可用的对象， 如果没有可用的对象，返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T <span class="title function_">findFreeObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        PooledObject&lt;T&gt; pObj = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 获得对象池向量中所有的对象</span></span><br><span class="line">        Enumeration&lt;PooledObject&lt;T&gt;&gt; enumerate = objects.elements();</span><br><span class="line">        <span class="comment">// 遍历所有的对象，看是否有可用的对象</span></span><br><span class="line">        <span class="keyword">while</span> (enumerate.hasMoreElements()) &#123;</span><br><span class="line">            pObj = (PooledObject&lt;T&gt;) enumerate.nextElement();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果此对象不忙，则获得它的对象并把它设为忙</span></span><br><span class="line">            <span class="keyword">if</span> (!pObj.isBusy()) &#123;</span><br><span class="line">                obj = pObj.getObject();</span><br><span class="line">                pObj.setBusy(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;<span class="comment">// 返回找到到的可用对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此函数返回一个对象到对象池中，并把此对象置为空闲。 所有使用对象池获得的对象均应在不使用此对象时返回它。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnObject</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">        <span class="comment">// 确保对象池存在，如果对象没有创建（不存在），直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (objects == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PooledObject&lt;T&gt; pObj = <span class="literal">null</span>;</span><br><span class="line">        Enumeration&lt;PooledObject&lt;T&gt;&gt; enumerate = objects.elements();</span><br><span class="line">        <span class="comment">// 遍历对象池中的所有对象，找到这个要返回的对象对象</span></span><br><span class="line">        <span class="keyword">while</span> (enumerate.hasMoreElements()) &#123;</span><br><span class="line">            pObj = (PooledObject&lt;T&gt;) enumerate.nextElement();</span><br><span class="line">            <span class="comment">// 先找到对象池中的要返回的对象对象</span></span><br><span class="line">            <span class="keyword">if</span> (obj == pObj.getObject()) &#123;</span><br><span class="line">                <span class="comment">// 找到了 , 设置此对象为空闲状态</span></span><br><span class="line">                pObj.setBusy(<span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭对象池中所有的对象，并清空对象池。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">closeObjectPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 确保对象池存在，如果不存在，返回</span></span><br><span class="line">        <span class="keyword">if</span> (objects == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PooledObject&lt;T&gt; pObj = <span class="literal">null</span>;</span><br><span class="line">        Enumeration&lt;PooledObject&lt;T&gt;&gt; enumerate = objects.elements();</span><br><span class="line">        <span class="keyword">while</span> (enumerate.hasMoreElements()) &#123;</span><br><span class="line">            pObj = (PooledObject&lt;T&gt;) enumerate.nextElement();</span><br><span class="line">            <span class="comment">// 如果忙，等 0.5 秒</span></span><br><span class="line">            <span class="keyword">if</span> (pObj.isBusy()) &#123;</span><br><span class="line">                wait(<span class="number">500</span>); <span class="comment">// 等</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从对象池向量中删除它</span></span><br><span class="line">            objects.removeElement(pObj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 置对象池为空</span></span><br><span class="line">        objects = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使程序等待给定的毫秒数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> mSeconds)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(mSeconds);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultObjectPool</span> <span class="keyword">extends</span> <span class="title class_">ObjectPool</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PooledObject&lt;String&gt; <span class="title function_">create</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PooledObject</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;&quot;</span>+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ObjectPool&lt;String&gt; objPool = <span class="keyword">new</span> <span class="title class_">DefaultObjectPool</span>();</span><br><span class="line">    objPool.createPool();</span><br><span class="line">    <span class="type">String</span> <span class="variable">obj</span> <span class="operator">=</span> objPool.getObject();</span><br><span class="line">    objPool.returnObject(obj);</span><br><span class="line">    objPool.closeObjectPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-OkHttp及默认拦截器，与自定义拦截器的执行顺序"><a href="#4-OkHttp及默认拦截器，与自定义拦截器的执行顺序" class="headerlink" title="4.OkHttp及默认拦截器，与自定义拦截器的执行顺序"></a>4.OkHttp及默认拦截器，与自定义拦截器的执行顺序</h3><p>RetryAndFollowUpInterceptor：负责失败重试和重定向<br>BridgeInterceptor：负责把用户构造的Request转换为发送给服务器的Request和把服务器返回的Response转换为对用户友好的Response<br>CacheInterceptor：负责读取缓存以及更新缓存<br>ConnectInterceptor：负责与服务器建立连接并管理连接<br>CallServerInterceptor：负责向服务器发送请求和从服务器读取响应<br>RealCall.getResponseWithInterceptorChain() 方法中调用<br>网络请求前后：通过 OkHttpClient.addInterceptor 方法添加<br>读取响应前后：通过 OkHttpClient.addNetworkInterceptor 方法添加</p>
<p>发起请求：<br>自定义Intercepter-&gt;RetryAndFollowUpIntercepter-&gt;BridgeIntercepter-&gt;CacheIntercepter-&gt;ConnectIntercepter-&gt;自定义NetworkIntercepter-&gt;CallServerIntercepter<br>请求响应：<br>顺序与发起请求相反</p>
<p><img src="https://img-blog.csdnimg.cn/20200216133819685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb2xoODk=,size_16,color_FFFFFF,t_70" alt="image"></p>
<h3 id="5-线程池获取实例的方法和参数列表"><a href="#5-线程池获取实例的方法和参数列表" class="headerlink" title="5.线程池获取实例的方法和参数列表"></a>5.线程池获取实例的方法和参数列表</h3><p>Executors的静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newSingleThreadScheduledExecutor</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>内部调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>



<h3 id="6-OKHttp和HtttpURLConnection的区别"><a href="#6-OKHttp和HtttpURLConnection的区别" class="headerlink" title="6.OKHttp和HtttpURLConnection的区别"></a>6.OKHttp和HtttpURLConnection的区别</h3><p>是一个相对比较简单的网络库，最开始通过根据设置的URL信息，创建一个Socket连接，然后获得Socket连接后得到Socket的InputStream和OutputStream，然后通过其获取数据和写入数据，其内部提供的功能比较少，仅限于帮助我们做一些简单的http的包装，核心类是HttpConnection，HttpEngine两个类。</p>
<p>轻巧的api有助于简化管理并减少兼容性问题，可自动处理缓存机制HttpResponseCache，减少网络使用量，并减少电池消耗<br>Android4.4开始HttpURLConnection的底层实现采用的是基于OkHttp的fork，HttpURLConnection本身不与OkHttp绑定；HttpURLConnection存在于谷歌或Square之前。但是HttpURLConnection是一个abstract类，它本身是无用的。Java运行时库需要HttpURLConnection的具体实现，然后可以使用它来实现openConnection()上的URL等方法，这需要返回一些HttpURLConnection实现。<br>在android 4.3及更高版本中，afaik的具体实现基于apache harmony实现，android中的大多数类都是这样的。</p>
<p>okhttp是高性能的http库，支持同步、异步，而且实现了spdy、http2、websocket协议，api很简洁易用，和volley一样实现了http协议的缓存。picasso就是利用okhttp的缓存机制实现其文件缓存，实现的很优雅，很正确，反例就是UIL（universal image loader），自己做的文件缓存，而且不遵守http缓存机制，四大核心类：OkHttpClient、Request、Call 和 Response</p>
<p>HttpClient早就不推荐httpclient，5.0之后干脆废弃，后续会删除。6.0删除了HttpClient</p>
<h3 id="7-Binder原理及为什么采用"><a href="#7-Binder原理及为什么采用" class="headerlink" title="7.Binder原理及为什么采用"></a>7.Binder原理及为什么采用</h3><p>Linux现有的IPC通信机制</p>
<ol>
<li>管道：在创建时分配一个page大小的内存，缓存区大小比较有限；</li>
<li>消息队列：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信；</li>
<li>共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；</li>
<li>套接字：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信；</li>
<li>信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li>信号: 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等；</li>
</ol>
<p>（1）从性能的角度<br>数据拷贝次数：Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，但共享内存方式一次内存拷贝都不需要；从性能角度看，Binder性能仅次于共享内存。<br>（2）从稳定性的角度<br>Binder是基于C&#x2F;S架构的，简单解释下C&#x2F;S架构，是指客户端(Client)和服务端(Server)组成的架构，Client端有什么需求，直接发送给Server端去完成，架构清晰明朗，Server端与Client端相对独立，稳定性较好；而共享内存实现方式复杂，没有客户与服务端之别， 需要充分考虑到访问临界资源的并发同步问题，否则可能会出现死锁等问题；从这稳定性角度看，Binder架构优越于共享内存。仅仅从以上两点，各有优劣，还不足以支撑google去采用binder的IPC机制<br>（3）从安全的角度传统<br>Linux IPC的接收方无法获得对方进程可靠的UID&#x2F;PID，从而无法鉴别对方身份；而Android作为一个开放的开源体系，拥有非常多的开发平台，App来源甚广，因此手机的安全显得额外重要；对于普通用户，绝不希望从App商店下载偷窥隐射数据、后台造成手机耗电等等问题，传统Linux IPC无任何保护措施，完全由上层协议来确保。 Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志，前面提到C&#x2F;S架构，Android系统中对外只暴露Client端，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID&#x2F;PID是否满足访问权限，目前权限控制很多时候是通过弹出权限询问对话框，让用户选择是否运行。Android 6.0，也称为Android M，在6.0之前的系统是在App第一次安装时，会将整个App所涉及的所有权限一次询问，只要留意看会发现很多App根本用不上通信录和短信，但在这一次性权限权限时会包含进去，让用户拒绝不得，因为拒绝后App无法正常使用，而一旦授权后，应用便可以胡作非为。针对这个问题，google在Android M做了调整，不再是安装时一并询问所有权限，而是在App运行过程中，需要哪个权限再弹框询问用户是否给相应的权限，对权限做了更细地控制，让用户有了更多的可控性，但同时也带来了另一个用户诟病的地方，那也就是权限询问的弹框的次数大幅度增多。对于Android M平台上，有些App开发者可能会写出让手机异常频繁弹框的App，企图直到用户授权为止，这对用户来说是不能忍的，用户最后吐槽的可不光是App，还有Android系统以及手机厂商，有些用户可能就跳果粉了，这还需要广大Android开发者以及手机厂商共同努力，共同打造安全与体验俱佳的Android手机。Android中权限控制策略有SELinux等多方面手段，下面列举从Binder的一个角度的权限控制：Android源码的Binder权限是如何控制？ -Gityuan的回答传统IPC只能由用户在数据包里填入UID&#x2F;PID；另外，可靠的身份标记只有由IPC机制本身在内核中添加。其次传统IPC访问接入点是开放的，无法建立私有通道。从安全角度，Binder的安全性更高。说到这，可能有人要反驳，Android就算用了Binder架构，而现如今Android手机的各种流氓软件，不就是干着这种偷窥隐射，后台偷偷跑流量的事吗？没错，确实存在，但这不能说Binder的安全性不好，因为Android系统仍然是掌握主控权，可以控制这类App的流氓行为，只是对于该采用何种策略来控制，在这方面android的确存在很多有待进步的空间，这也是google以及各大手机厂商一直努力改善的地方之一。在Android 6.0，google对于app的权限问题作为较多的努力，大大收紧的应用权限；另外，在Google举办的Android Bootcamp 2016大会中，google也表示在Android 7.0 （也叫Android N）的权限隐私方面会进一步加强加固，比如SELinux，Memory safe language(还在research中)等等，在今年的5月18日至5月20日，google将推出Android N。 话题扯远了，继续说Binder。<br>（4）从语言层面的角度<br>Linux是基于C语言(面向过程的语言)，而Android是基于Java语言(面向对象的语句)，而对于Binder恰恰也符合面向对象的思想，将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体位于一个进程中，而它的引用却遍布于系统的各个进程之中。可以从一个进程传给其它进程，让大家都能访问同一Server，就像将一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。从语言层面，Binder更适合基于面向对象语言的Android系统，对于Linux系统可能会有点“水土不服”。另外，Binder是为Android这类系统而生，而并非Linux社区没有想到Binder IPC机制的存在，对于Linux社区的广大开发人员，我还是表示深深佩服，让世界有了如此精湛而美妙的开源系统。也并非Linux现有的IPC机制不够好，相反地，经过这么多优秀工程师的不断打磨，依然非常优秀，每种Linux的IPC机制都有存在的价值，同时在Android系统中也依然采用了大量Linux现有的IPC机制，根据每类IPC的原理特性，因时制宜，不同场景特性往往会采用其下最适宜的。比如在Android OS中的Zygote进程的IPC采用的是Socket（套接字）机制，Android中的Kill Process采用的signal（信号）机制等等。而Binder更多则用在system_server进程与上层App层的IPC交互。<br>(5) 从公司战略的角度<br>Linux内核是开源的系统，所开放源代码许可协议GPL保护，该协议具有“病毒式感染”的能力，怎么理解这句话呢？受GPL保护的Linux Kernel是运行在内核空间，对于上层的任何类库、服务、应用等运行在用户空间，一旦进行SysCall（系统调用），调用到底层Kernel，那么也必须遵循GPL协议。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/universus/article/details/6211589">binder原理</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6876046258406948878">Linux进程通信</a></p>
<h3 id="8-TCP和UDP在报文上有什么区别"><a href="#8-TCP和UDP在报文上有什么区别" class="headerlink" title="8.TCP和UDP在报文上有什么区别"></a>8.TCP和UDP在报文上有什么区别</h3><p><img src="https://img-blog.csdn.net/2018052919245371?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ3MTEwOTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"><br>源端口（Source port）和目的端口（Destination port）<br>各16 bits。IP地址标识互联网中的不同终端，端口号标识终端中的不同应用进程，具有本地意义。32位IP + 16位端口号 &#x3D; 48位插口。<br>端口由互联网数字分配机构（Internet Assigned Numbers Authority，IANA）分配，TCP和UDP端口号列表。</p>
<p>著名端口号（Well-known）	注册端口号（Registered）	动态端口号（Dynamic）<br>0<del>1023	1024</del>49151	49152~65535<br>IANA统一分配	向IANA申请注册	本地分配</p>
<ul>
<li>序号（Sequence Number）和确认序号（Acknowledgment Number）</li>
</ul>
<p>各32 bits。TCP连接传输的字节流中的每一个字节都有序号。SN指示本报文段所发送的数据第一个字节的序号。AN指示期望收到对方的下一个报文的第一个字节的序号，所有小于AN的报文都被正确接收。</p>
<p>首部长度（Data offset）<br>4 bits，以32-bit字为单位。TCP首部长短，也是TCP报文数据部分的偏移量。范围5~15，即20 bytes ~ 60 bytes。options部分最多允许40 bytes。</p>
<p>保留（Resevered）<br>3 bits，将来使用，目前应设为0。</p>
<p>标志位（Flags）<br>URG &#x3D; 1，指示报文中有紧急数据，应尽快传送（相当于高优先级的数据）。<br>PSH &#x3D; 1，接到后尽快交付给接收的应用进程。<br>RST &#x3D; 1，TCP连接中出现严重差错（如主机崩溃），必须释放连接，在重新建立连接。<br>FIN &#x3D; 1，发送端已完成数据传输，请求释放连接。<br>SYN &#x3D; 1，处于TCP连接建立过程。<br>ACK &#x3D; 1，确认序号（AN）有效。</p>
<p>窗口（Window size）<br>16 bits，接收窗口的大小。接收端希望接收的字节数。</p>
<p>校验和（Checksum）<br>16 bits，校验报文首部、数据。</p>
<p>紧急指针（Urgent pointer）<br>16 bits，如果URG &#x3D; 1，该字段指示紧急数据的大小（相对于SN的偏移），紧急数据在数据部分的最前面。</p>
<p>可选项（Options）<br>TCP报文的字段实现了TCP的功能，标识进程、对字节流拆分组装、差错控制、流量控制、建立和释放连接等。</p>
<p><img src="https://img-blog.csdn.net/20180530204528103?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ3MTEwOTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p>
<p>源端口（Source port）和目的端口（Destination port）</p>
<p>报文长度（Length）</p>
<p>16 bits，指示UDP报文（首部和数据）的总长度。最小8 bytes，只有首部，没有数据。最大值为65535 bytes。实际上，由于IPv4分组的最大数据长度为（65535 - 20 &#x3D; 65515） bytes，UDP的报文长度不超过65515 bytes。IPv6允许UDP的长度超过65535，此时length字段设为0。</p>
<p>校验和（Checksum）</p>
<h3 id="9-屏幕适配方案ScreenMatch-SmallWidth"><a href="#9-屏幕适配方案ScreenMatch-SmallWidth" class="headerlink" title="9.屏幕适配方案ScreenMatch(SmallWidth)"></a>9.屏幕适配方案ScreenMatch(SmallWidth)</h3><p>如果项目中使用SmallWidth适配，而设计师给的标注又是px的，我们只要调整base_dp的值，再使用ScreenMatch生成该base_dp对应的一系列values-swXX，就可以在布局中直接写像素对应的dp_xx<br>优点</p>
<ol>
<li><p>使用成本特别低，操作相当简单，使用该方案后在页面布局时不需要额外的代码和操作。</p>
</li>
<li><p>侵入性非常低，该方案和项目完全解耦，在项目布局时不会依赖哪怕一行该方案的代码，而且还是 Android 官方的 API，意味着当你遇到什么问题无法解决，想切换为其他屏幕适配方案时，基本不需要更改之前的代码，整个切换过程几乎在瞬间完成，会少很多麻烦，节约很多时间，试错成本接近于 0，不会有任何性能的损耗。</p>
</li>
<li><p>可适配三方库的控件和系统的控件(不止是 Activity 和 Fragment，Dialog、Toast 等所有系统控件都可以适配)，由于修改的 density 在整个项目中是全局的，所以只要一次修改，项目中的所有地方都会受益。</p>
</li>
</ol>
<p>缺点</p>
<ol>
<li><p>只需要修改一次 density，项目中的所有地方都会自动适配，这个看似解放了双手，减少了很多操作，但是实际上反应了一个缺点，那就是只能一刀切的将整个项目进行适配，但适配范围是不可控的。</p>
</li>
<li><p>这样不是很好吗？这样本来是很好的，但是应用到这个方案是就不好了，因为我上面的原理也分析了，这个方案依赖于设计图尺寸，但是项目中的系统控件、三方库控件、等非我们项目自身设计的控件，它们的设计图尺寸并不会和我们项目自身的设计图尺寸一样。</p>
</li>
<li><p>当这个适配方案不分类型，将所有控件都强行使用我们项目自身的设计图尺寸进行适配时，这时就会出现问题，当某个系统控件或三方库控件的设计图尺寸和和我们项目自身的设计图尺寸差距非常大时，这个问题就越严重。</p>
</li>
</ol>
<p>其他适配方式</p>
<p>百分比<br>AutoLayout<br>自定义View</p>
<h3 id="10-Kotlin协程实现"><a href="#10-Kotlin协程实现" class="headerlink" title="10.Kotlin协程实现"></a>10.Kotlin协程实现</h3><p>异步编程中最为常见的场景是：在后台线程执行一个复杂任务，下一个任务依赖于上一个任务的执行结果，所以必须等待上一个任务执行完成后才能开始执行。看下面代码中的三个函数，后两个函数都依赖于前一个函数的执行结果<br>协程通过将复杂性放入库来简化异步编程。程序的逻辑可以在协程中顺序地表达，而底层库会为我们解决其异步性。该库可以将用户代码的相关部分包装为回调、订阅相关事件、在不同线程（甚至不同机器）上调度执行，而代码则保持如同顺序执行一样简单<br>Future<br>CompletableFuture-JDK8<br>RxJava</p>
<p>CoroutineContext、CoroutineDispatcher、Job<br>1 CoroutineScope 和 CoroutineContext<br>CoroutineScope，可以理解为协程本身，包含了 CoroutineContext。<br>CoroutineContext，协程上下文，是一些元素的集合，主要包括 Job 和 CoroutineDispatcher 元素，可以代表一个协程的场景。<br>EmptyCoroutineContext 表示一个空的协程上下文。</p>
<p>2 CoroutineDispatcher<br>CoroutineDispatcher，协程调度器，决定协程所在的线程或线程池。它可以指定协程运行于特定的一个线程、一个线程池或者不指定任何线程（这样协程就会运行于当前线程）。coroutines-core中 CoroutineDispatcher 有三种标准实现Dispatchers.Default、Dispatchers.IO，Dispatchers.Main和Dispatchers.Unconfined，Unconfined 就是不指定线程。<br>launch函数定义如果不指定CoroutineDispatcher或者没有其他的ContinuationInterceptor，默认的协程调度器就是Dispatchers.Default，Default是一个协程调度器，其指定的线程为共有的线程池，线程数量至少为 2 最大与 CPU 数相同。</p>
<p>3 Job &amp; Deferred<br>Job，任务，封装了协程中需要执行的代码逻辑。Job 可以取消并且有简单生命周期，它有三种状态：<br>State	[isActive]	[isCompleted]	[isCancelled]<br>New (optional initial state)	false	false	false<br>Active (default initial state)	true	false	false<br>Completing (optional transient state)	true	false	false<br>Cancelling (optional transient state)	false	false	true<br>Cancelled (final state)	false	true	true<br>Completed (final state)	false	true	false<br>Job 完成时是没有返回值的，如果需要返回值的话，应该使用 Deferred，它是 Job 的子类public interface Deferred<out T> : Job。</p>
<p>4 Coroutine builders<br>CoroutineScope.launch函数属于协程构建器 Coroutine builders，Kotlin 中还有其他几种 Builders，负责创建协程。</p>
<p>4.1 CoroutineScope.launch {}<br>CoroutineScope.launch {} 是最常用的 Coroutine builders，不阻塞当前线程，在后台创建一个新协程，也可以指定协程调度器，例如在 Android 中常用的GlobalScope.launch(Dispatchers.Main) {}。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">    GlobalScope.launch(Dispatchers.Main) &#123; <span class="comment">// 在 UI 线程创建一个新协程</span></span><br><span class="line">        <span class="keyword">val</span> token = requestToken()</span><br><span class="line">        <span class="keyword">val</span> post = createPost(token, item)</span><br><span class="line">        processPost(post)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.2 runBlocking {}<br>runBlocking {}是创建一个新的协程同时阻塞当前线程，直到协程结束。这个不应该在协程中使用，主要是为main函数和测试设计的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking &#123; <span class="comment">// start main coroutine</span></span><br><span class="line">    launch &#123; <span class="comment">// launch new coroutine in background and continue</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>) <span class="comment">// main coroutine continues here immediately</span></span><br><span class="line">    delay(<span class="number">2000L</span>)      <span class="comment">// delaying for 2 seconds to keep JVM alive</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testMySuspendingFunction</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">        <span class="comment">// here we can use suspending functions using any assertion style that we like</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.3 withContext {}<br>withContext {}不会创建新的协程，在指定协程上运行挂起代码块，并挂起该协程直至代码块运行完成。</p>
<p>4.4 async {}<br>CoroutineScope.async {}可以实现与 launch builder 一样的效果，在后台创建一个新协程，唯一的区别是它有返回值，因为CoroutineScope.async {}返回的是 Deferred 类型。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> = runBlocking &#123; <span class="comment">// start main coroutine</span></span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">val</span> one = async &#123; doSomethingUsefulOne() &#125;  <span class="comment">// start async one coroutine without suspend main coroutine</span></span><br><span class="line">        <span class="keyword">val</span> two = async &#123; doSomethingUsefulTwo() &#125;  <span class="comment">// start async two coroutine without suspend main coroutine</span></span><br><span class="line">        println(<span class="string">&quot;The answer is <span class="subst">$&#123;one.await() + two.await()&#125;</span>&quot;</span>) <span class="comment">// suspend main coroutine for waiting two async coroutines to finish</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Completed in <span class="variable">$time</span> ms&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取CoroutineScope.async {}的返回值需要通过await()函数，它也是是个挂起函数，调用时会挂起当前协程直到 async 中代码执行完并返回某个值</p>
<h3 id="11-synchronized和volatile的区别"><a href="#11-synchronized和volatile的区别" class="headerlink" title="11.synchronized和volatile的区别"></a>11.synchronized和volatile的区别</h3><p>synchronized的两条规定：<br>线程解锁前，必须把共享变量的最新值刷新到主内存中<br>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时，需要从主内存中重新读取最新的值(注意：加锁与解锁需要是同一把锁)</p>
<p>volatile关键字<br>能够保证volatile变量的可见性<br>不能保证volatile变量复合操作的原子性</p>
<p>synchronized和volatile的区别<br>volatile不需要加锁，比synchronized更轻量级，不会阻塞线程；<br>从内存可见性角度，volatile读相当于加锁，volatile写相当于解锁；<br>synchronized既能够保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性。</p>
<p>volatile本质是在告诉 jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住<br>volatile修饰变量；synchronized修饰方法<br>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞<br>volatile仅能实现变量的修改可见性，不能保证原子性，因为一个线程 A 修改了变量还没结束时，另外的线程 B 可以看到已修改的值，而且可以修改这个变量，而不用等待 A 释放锁，因为volatile变量没上锁。而synchronized则可以保证变量的修改可见性和原子性</p>
<h3 id="12-HashMap的实现和哈希碰撞及扩容方案"><a href="#12-HashMap的实现和哈希碰撞及扩容方案" class="headerlink" title="12.HashMap的实现和哈希碰撞及扩容方案"></a>12.HashMap的实现和哈希碰撞及扩容方案</h3><p>HashMap 采用一种所谓的“Hash 算法”来决定每个元素的存储位置。当程序执行put(String,Obect)方法 时，系统将调用String的 hashCode() 方法得到其 hashCode 值——每个 Java 对象都有 hashCode() 方法，都可通过该方法获得它的 hashCode 值。得到这个对象的 hashCode 值之后，系统会根据该 hashCode 值来决定该元素的存储位置</p>
<p>HashMap里面的bucket出现了单链表的形式，散列表要解决的一个问题就是散列值的冲突问题，通常是两种方法：链表法和开放地址法。链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位；开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。java.util.HashMap采用的链表法的方式，链表是单向链表</p>
<p>系统总是将新添加的 Entry 对象放入 table 数组的 bucketIndex 索引处——如果 bucketIndex 索引处已经有了一个 Entry 对象，那新添加的 Entry 对象指向原有的 Entry 对象(产生一个 Entry 链)，如果 bucketIndex 索引处没有 Entry 对象，也就是新放入的 Entry 对象指向 null，也就是没有产生 Entry 链。 HashMap里面没有出现hash冲突时，没有形成单链表时，hashmap查找元素很快，get()方法能够直接定位到元素，但是出现单链表后，单个bucket 里存储的不是一个 Entry，而是一个 Entry 链，系统只能必须按顺序遍历每个 Entry，直到找到想搜索的 Entry 为止——如果恰好要搜索的 Entry 位于该 Entry 链的最末端(该 Entry 是最早放入该 bucket 中)，那系统必须循环到最后才能找到该元素。</p>
<p>通过上面可知如果多个hashCode()的值落到同一个桶内的时候，这些值是存储到一个链表中的。最坏的情况下，所有的key都映射到同一个桶中，这样HashMap就退化成了一个链表——查找时间从O(1)到O(n)。也就是说我们是通过链表的方式来解决这个Hash碰撞问题的。</p>
<p>如果某个桶中的记录过大的话（当前是TREEIFY_THRESHOLD &#x3D; 8），HashMap会动态的使用一个专门的TreeMap实现来替换掉它。这样做的结果会更好，是O(logn)，而不是糟糕的O(n)。它是如何工作的？前面产生冲突的那些KEY对应的记录只是简单的追加到一个链表后面，这些记录只能通过遍历来进行查找。但是超过这个阈值后HashMap开始将列表升级成一个二叉树，使用哈希值作为树的分支变量，如果两个哈希值不等，但指向同一个桶的话，较大的那个会插入到右子树里。如果哈希值相等，HashMap希望key值最好是实现了Comparable接口的，这样它可以按照顺序来进行插入。这对HashMap的key来说并不是必须的，不过如果实现了当然最好。如果没有实现这个接口，在出现严重的哈希碰撞的时候，你就并别指望能获得性能提升了。这个性能提升有什么用处？比方说恶意的程序，如果它知道我们用的是哈希算法，它可能会发送大量的请求，导致产生严重的哈希碰撞。然后不停的访问这些key就能显著的影响服务器的性能，这样就形成了一次拒绝服务攻击（DoS）。JDK 8中从O(n)到O(logn)的飞跃，可以有效地防止类似的攻击，同时也让HashMap性能的可预测性稍微增强了一些。</p>
<p>HashMap通过高16位与低16位进行异或运算来让高位参与散列，提高散列效果；<br>HashMap控制数组的长度为2的整数次幂来简化取模运算，提高性能；<br>HashMap通过控制初始化的数组长度为2的整数次幂、扩容为原来的2倍来控制数组长度一定为2的整数次幂。</p>
<p>哈希冲突解决方案<br>再优秀的hash算法永远无法避免出现hash冲突。hash冲突指的是两个不同的key经过hash计算之后得到的数组下标是相同的。解决hash冲突的方式很多，如开放定址法、再哈希法、公共溢出表法、链地址法。HashMap采用的是链地址法，jdk1.8之后还增加了红黑树的优化</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39631755/article/details/111807782">HashMap相关</a></p>
<h3 id="BroadcastReceiver与LocalBroadcastManager应用及区别"><a href="#BroadcastReceiver与LocalBroadcastManager应用及区别" class="headerlink" title="BroadcastReceiver与LocalBroadcastManager应用及区别"></a>BroadcastReceiver与LocalBroadcastManager应用及区别</h3><p>应用场景</p>
<ol>
<li>BroadcastReceiver用于应用之间的传递消息；</li>
<li>而LocalBroadcastManager用于应用内部传递消息，比BroadcastReceiver更加高效。</li>
</ol>
<p>安全</p>
<ol>
<li>BroadcastReceiver使用的<strong>Content API</strong>，所以本质上它是跨应用的，所以在使用它时必须要考虑到不要被别的应用滥用；</li>
<li>LocalBroadcastManager不需要考虑安全问题，因为它只在应用内部有效。</li>
</ol>
<p>相同点</p>
<ol>
<li>LocalBroadcastManager和传统广播（Context注册注销）都能通过BroadcastReceiver介绍信息。</li>
</ol>
<p>不同点</p>
<ol>
<li>通过LocalBroadcastManager注册的广播只能通过代码的方式注册即LocalBroadcastManager.getInstance(this).registerReceiver()注册。传统广播能在代码动态注册和XML永久注册。</li>
<li>LocalBroadcastManager注册的广播，您在发送广播的时候务必使用LocalBroadcastManager.sendBroadcast(intent);否则接收不到广播。传统的发送广播的方法：context.sendBroadcast( intent );</li>
<li>LocalBroadcastManager注册广播后，一定要记得取消监听。这一步可以有效的解决内存泄漏的问题。</li>
</ol>
<p>应用场景<br>某些系统广播只能用getApplication().registerReceiver注册 不能使用LocalBroadcastManager注册，否则接受不到信息。比如: 蓝牙接收数据广播和蓝牙状态监听广播。</p>
<h3 id="13-缓存实现-DiskLRUCache实现-LRU数据结构（双向链表）"><a href="#13-缓存实现-DiskLRUCache实现-LRU数据结构（双向链表）" class="headerlink" title="13.缓存实现 DiskLRUCache实现  LRU数据结构（双向链表）"></a>13.缓存实现 DiskLRUCache实现  LRU数据结构（双向链表）</h3><h3 id="AOP编程思想"><a href="#AOP编程思想" class="headerlink" title="AOP编程思想"></a>AOP编程思想</h3><p>AOP应用场景<br>场景一： 记录日志(审计日志，异常处理)<br>场景二： 监控方法运行时间(性能监控)（例如：网络状态，APM埋点）<br>场景三： 权限控制<br>场景四： 缓存优化 （第一次调用查询数据库，将查询结果放入内存对象， 第二次调用， 直接从内存对象返回，不需要查询数据库 ）<br>场景五： 事务管理(事务控制) （调用方法前开启事务， 调用方法后提交关闭事务 ，如声明式事务）<br>场景六： 分布式追踪</p>
<p>AOP相关概念<br>Aspect 切面 通常指@Aspect标识的类<br>Join point 连接点 In Spring AOP, a join point always represents a method execution. 目标对象中的方法就是一个连接点<br>Advice 通知 @Before、@AfterReturning、@AfterThrowing、@After、@Around<br>Pointcut 切点 连接点的集合<br>Introduction：引入，Declaring additional methods or fields on behalf of a type<br>Target object：目标对象，原始对象<br>AOP proxy：代理对象， 包含了原始对象的代码和增强后的代码的那个对象<br>Weaving: 织入</p>
<p>AOP的初衷<br>减少重复代码<br>关注点分离：功能性需求、非功能性需求</p>
<h3 id="14-悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量-重量级锁、读写锁、各种锁及其Java实现"><a href="#14-悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量-重量级锁、读写锁、各种锁及其Java实现" class="headerlink" title="14.悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量&#x2F;重量级锁、读写锁、各种锁及其Java实现"></a>14.悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量&#x2F;重量级锁、读写锁、各种锁及其Java实现</h3><h3 id="ARouter源码分析"><a href="#ARouter源码分析" class="headerlink" title="ARouter源码分析"></a>ARouter源码分析</h3><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ElementType</span> &#123;</span><br><span class="line">    <span class="comment">/**标明该注解可以用于类、接口（包括注解类型）或enum声明*/</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 标明该注解可以用于字段(域)声明，包括enum实例 */</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 标明该注解可以用于方法声明 */</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 标明该注解可以用于参数声明 */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 标明注解可以用于构造函数声明 */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 标明注解可以用于局部变量声明 */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 标明注解可以用于注解声明(应用于另一个注解上)*/</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 标明注解可以用于包声明 */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标明注解可以用于类型参数声明（1.8新加入）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型使用声明（1.8新加入)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Retention用来约束注解的生命周期，分别有三个值，源码级别（source），类文件级别（class）或者运行时级别（runtime），其含有如下：<br>SOURCE：注解将被编译器丢弃（该类型的注解信息只会保留在源码里，源码经过编译后，注解信息会被丢弃，不会保留在编译好的class文件里）<br>CLASS：注解在class文件中可用，但会被VM丢弃（该类型的注解信息会保留在源码里和class文件里，在执行的时候，不会加载到虚拟机中），请注意，当注解未定义Retention值时，默认值是CLASS，如Java内置注解，@Override、@Deprecated、@SuppressWarnning等<br>RUNTIME：注解信息将在运行期(JVM)也保留，因此可以通过反射机制读取注解的信息（源码、class文件和执行的时候都有注解的信息），如SpringMvc中的@Controller、@Autowired、@RequestMapping等。</p>
<h3 id="Launcher被杀死"><a href="#Launcher被杀死" class="headerlink" title="Launcher被杀死"></a>Launcher被杀死</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/82904693">知乎-谁杀了桌面</a></p>
<p>AMS.killBackgroundProcesses发出时Launcher会被杀死<br>ActivityManager.killBackgroundProcesses</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Have the system immediately kill all background processes associated</span></span><br><span class="line"><span class="comment"> * with the given package.  This is the same as the kernel killing those</span></span><br><span class="line"><span class="comment"> * processes to reclaim memory; the system will take care of restarting</span></span><br><span class="line"><span class="comment"> * these processes in the future as needed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> packageName The name of the package whose processes are to</span></span><br><span class="line"><span class="comment"> * be killed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequiresPermission(Manifest.permission.KILL_BACKGROUND_PROCESSES)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">killBackgroundProcesses</span><span class="params">(String packageName)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getService().killBackgroundProcesses(packageName,</span><br><span class="line">                mContext.getUserId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Camera1-Camera2-CameraX的演进"><a href="#Camera1-Camera2-CameraX的演进" class="headerlink" title="Camera1 Camera2 CameraX的演进"></a>Camera1 Camera2 CameraX的演进</h3><h4 id="Camera1"><a href="#Camera1" class="headerlink" title="Camera1"></a>Camera1</h4><blockquote>
<ul>
<li>Camera1 的开发中，打开相机，设置参数的过程是同步的，就跟用户实际使用camera的操作步骤一样。但是如果有耗时情况发生时，会导致整个调用线程等待；</li>
<li>开发者如果想要个性化设置camera效果，无法手动设置调整参数，需要依靠第三方算法对于回调的数据进行处理（NV21）。而且不同手机的回调数据效果都是不一样的，采用第三方算法调整，通常效果不好；</li>
<li>开发者所能获取的Camera状态信息有限；</li>
</ul>
<p>camera1 的开发过程比较简单，对于常规视频采集，如果只要一般的预览功能，是没问题的，然而如果想要挖掘Camera更多的功能，camera1无法满足，于是有了camera2.</p>
</blockquote>
<h4 id="Camera2"><a href="#Camera2" class="headerlink" title="Camera2"></a>Camera2</h4><blockquote>
<ul>
<li>Camera2 的开发中，camera的生命周期都是异步的，即发送请求，等待回调的client-service模式；</li>
<li>系统： Android L+；</li>
<li>这里的关键回调主要是三个：</li>
</ul>
<p>  （1）CameraDevice.StateCallback &#x2F;&#x2F;&#x2F;比如线程A发送打开相机请求, 线程B中收到相机状态回调，线程B中与cameraDevice建立会话，设置参数，数据回调处理；</p>
<p>  （2）CameraCaptureSession.StateCallback &#x2F;&#x2F;&#x2F;与CameraDevice建立会话后，收到的会话状态回调；</p>
<p>  （3）ImageReader.OnImageAvailableListener &#x2F;&#x2F; 开发者可以直接获取并且操作的数据回调；</p>
<ul>
<li>通过跟相机建立的会话，可以更加精细的调整Camera参数：比如ISO感光度，曝光时间，曝光补偿……；</li>
<li>如果开发者想要更多自己的定制，也可以直接使用回调数据（YUV488）；</li>
<li>MultiCamera的支持；</li>
</ul>
</blockquote>
<h4 id="Multi-Camera"><a href="#Multi-Camera" class="headerlink" title="Multi-Camera"></a>Multi-Camera</h4><blockquote>
<ul>
<li>系统：Android P+；</li>
<li>目前支持的multi-camera的设备： Pixel 3， mate20 系列；</li>
<li>Multi-Camera 新功能：</li>
</ul>
<p>  （1）更好的光学变焦：之前的方式通常使用数码变焦或者是单个摄像头的光学变焦来达到变焦的效果， 通过多摄像头的变焦方式，无论远景还是近景，都可以采到更好质量的数据。</p>
<p>  （2）景深计算：通过多摄像头的景深不同，可以得到每一帧图片中不同物体的景深，从而更好的区分前景或者后景。应用范围：背景虚化，背景替换，现实增强。</p>
<p>  （3）更广的视角：更广的视角带来鱼眼镜头的畸变效果，畸变矫正功能。<br>  CaptureRequest.DISTORTION_CORRECTION_MODE</p>
<p>  （4）人脸识别功能：跟畸变效果一样，自带人脸识别功能。应用范围：人脸裁剪，人脸特效。<br>  CaptureResult.STATISTICS_FACE_DETECT_MODE</p>
<p>  （5）多路流同时采集：场景包括（单摄像头输出多流，多摄像头输出多流）</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">normalOutputConfigImageReader.setPhysicalCameraId(normalLensId)</span><br><span class="line">wideOutputConfigImageReader.setPhysicalCameraId(wideAngleId)</span><br><span class="line">params.previewBuilder?.addTarget(normalSurface)</span><br><span class="line">params.previewBuilder?.addTarget(wideSurface)</span><br></pre></td></tr></table></figure>

<ul>
<li>带来的问题：更耗内存，更耗电</li>
<li>趋势：单个手机中，支持更多的摄像头</li>
</ul>
<p>  Camera2 虽然给开发者带来了相机的更多可玩性，然而android的碎片化，导致很多设备的兼容性问题频繁发生。尤其国内的手机厂商，对camera2 的支持程度各不相同，</p>
<p>  所以Camera2的开发难度更多的是在兼容性，于是有了CameraX。</p>
</blockquote>
<h4 id="CameraX"><a href="#CameraX" class="headerlink" title="CameraX"></a>CameraX</h4><blockquote>
<ul>
<li>系统：Android L+</li>
<li>Jetpack 内的一套Camera开发支持库。</li>
<li>特点：</li>
</ul>
<ol>
<li>更简单易用的API，更少的代码量，使开发者更专注业务的个性化实现。比如：对采集到图片做分析处理。</li>
<li>更好的兼容性，减少不同设备适配烦恼：包括宽高比、屏幕方向、旋转、预览大小和高分辨率图片大小。</li>
<li>数据分析: 开发者依然可以对数据进行个性化处理。</li>
<li>第三方Camera特效拓展：对于一些手机厂商特定实现的camera特效，开发者也可以使用。</li>
<li>Code Sample 1（CameraX的常规使用）</li>
</ol>
<p>  （1）CameraX 创建UseCaseConfig; &#x2F;&#x2F;已经提前实现好各种UseCase（preview,ImageCapture,ImageAnalysis…）对应不同的UseCaseConfig, 开发者重要专注自己的业务。</p>
<p>  （2）创建对应UseCase</p>
<p>  （3）CameraX bindToLifecycle(LifeCycleOwner, UseCases) &#x2F;&#x2F;CameraX 会观察生命周期以确定何时打开相机、何时创建拍摄会话以及何时停止和关闭。</p>
<p>  （4）CameraX unbind(UseCase)</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/82010550">参考链接:知乎-Camera进化</a></p>
<table>
<thead>
<tr>
<th></th>
<th>Camera1.0</th>
<th align="left">Camera2.0</th>
</tr>
</thead>
<tbody><tr>
<td>引入时间</td>
<td></td>
<td align="left">5.0</td>
</tr>
<tr>
<td>权限</td>
<td>android.permission.CAMERA</td>
<td align="left">android.permission.CAMERA</td>
</tr>
<tr>
<td>布局</td>
<td>SurfaceView</td>
<td align="left">TextureView</td>
</tr>
<tr>
<td>实现接口</td>
<td>SurfaceHolder.Callback 1.surfaceCreated 2.surfaceChanged 3.surfaceDestroyed</td>
<td align="left">SurfaceTextureListener 1.onSurfaceTextureAvailable 2.onSurfaceTextureSizeChanged 3.onSurfaceTextureDestroyed 4.onSurfaceTextureUpdated</td>
</tr>
<tr>
<td>Camera参数（设置，查看）</td>
<td>Camera.Parameters Camera.Size</td>
<td align="left">查看：CameraCharacteristics中getCameraCharacteristics(CameraID)设置：CaptureRequest.Builder中void set(Key key, T value)举例：曝光：CaptureReqBuilder.set(CaptureRequest.CONTROL_AE_EXPOSURE_COMPENSATION, 2);</td>
</tr>
<tr>
<td>打开摄像头</td>
<td>surfaceCreated中Camera.open(CameraID)</td>
<td align="left">onSurfaceTextureAvailable中CameraManager.openCamera(CameraId,CameraDevice.StateCallback,Handler)</td>
</tr>
<tr>
<td>开始预览</td>
<td>Camera.startPreview()</td>
<td align="left">CaptureReqBuilder &#x3D; camera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);CaptureReqBuilder.addTarget(Surface);Camera.createCaptureSession(Arrays.asList(surface),CaptureSessionStateCallback, Handler);</td>
</tr>
<tr>
<td>设置预览方向</td>
<td>Camera.setDisplayOrientation(degrees)</td>
<td align="left">并没有直接设置预览方向的方法，但是TextureView本身是一个View，支持旋转、平移、缩放，再重写onMeasure方法</td>
</tr>
<tr>
<td>图像原始数据byte[]实时获取</td>
<td>Camera.PreviewCallback中onPreviewFrame(byte[],Camera)</td>
<td align="left">1．onSurfaceTextureUpdated中使用TextureView的getBitmap()方法，但是这里获取到的是Bitmap对象，而我需要的是原始byte[]，所以这个方法不适用。2．设置ImageReader.setOnImageAvailableListener监听，在onImageAvailable(ImageReader)通过回调传递的ImageReader.acquireLatestImage()方法获取到一个Image对象（别忘了close()，否则画面会卡住，停止刷新），然后Image.getPlanes()[0].getBuffer()返回了一个ByteBuffer对象，最后new byte[buffer.remaining()]即可得到原始图像的byte[]。别忘了CaptureReqBuilder.addTarget(ImageReader.getSurface()); 否则看不到效果</td>
</tr>
<tr>
<td>Camera图像预览尺寸大小设置</td>
<td>Camera.Parameters.setPreviewSize(width, height)</td>
<td align="left">TextureView. getSurfaceTexture()拿到SurfaceTexture()对象，再通过setDefaultBufferSize(width, height)进行设置。</td>
</tr>
<tr>
<td>将来获取到的图片的大小设置</td>
<td>Camera.Parameters.setPictureSize(width, height);</td>
<td align="left">ImageReader.newInstance(width, height,ImageFormat.YUV_420_888, MAX_IMAGES);</td>
</tr>
<tr>
<td>将来获取到的图片的格式设置</td>
<td>Camera.Parameters..setPictureFormat(ImageFormat.JPEG);</td>
<td align="left">ImageReader.newInstance(width, height,ImageFormat.YUV_420_888, MAX_IMAGE</td>
</tr>
<tr>
<td>Camera2是通过系统服务拿到CameraManager来管理camera设备对象，camera的一次预览、拍照都是向请求会话（CaptureSession.StateCallback，摄像头打开时由相机设备的输出surface组成）发送一次请求（CaptureRequest.Builder）。需要在它的回调onConfigured中进行处理，例如预览，如果不在此方法中写上CameraCaptureSession.setRepeatingRequest(mCaptureReqBuilder.build(), null, mHandler);那么预览就不会成功。</td>
<td></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>此外，在创建会话，设置ImageReader监听，都需要传递一个Handler对象，这个Handler对象决定着这些会话、监听的回调方法会被在哪个线程中调用，如果传递的是NULL，那么回调会调用在当前线程。</p>
<p>闪关灯的控制方式</p>
<p>Camera1：<br>这行代码可以得到摄像头支持的闪光灯模式<br>List supportedFlashModes &#x3D; params.getSupportedFlashModes();<br>控制闪光灯的方法：<br>params.setFlashMode(Parameters.FLASH_MODE_TORCH );&#x2F;&#x2F;开启闪光灯</p>
<p>Parameters.FLASH_MODE_TORCH ： 闪光灯常开<br>Parameters.FLASH_MODE_ON ：拍照时闪光灯才打开</p>
<p>Camera2：<br>这句代码可以用来检测当前打开的摄像头是否支持闪光灯<br>boolean flashAvailable &#x3D; cameraCharacteristics.get(CameraCharacteristics.FLASH_INFO_AVAILABLE);<br>控制闪光灯的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    mBtnFlash.setImageResource(R.drawable.btn_flash_off);</span><br><span class="line">    mPreviewBuilder.set(CaptureRequest.CONTROL_AE_MODE, CameraMetadata.CONTROL_AE_MODE_ON);</span><br><span class="line">    mPreviewBuilder.set(CaptureRequest.FLASH_MODE, CameraMetadata.FLASH_MODE_OFF);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    mBtnFlash.setImageResource(R.drawable.btn_flash_on);</span><br><span class="line">    mPreviewBuilder.set(CaptureRequest.CONTROL_AE_MODE, CameraMetadata.CONTROL_AE_MODE_ON);</span><br><span class="line">    mPreviewBuilder.set(CaptureRequest.FLASH_MODE, CameraMetadata.FLASH_MODE_SINGLE);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    mBtnFlash.setImageResource(R.drawable.btn_flash_all_on);</span><br><span class="line">    mPreviewBuilder.set(CaptureRequest.CONTROL_AE_MODE, CameraMetadata.CONTROL_AE_MODE_ON);</span><br><span class="line">    mPreviewBuilder.set(CaptureRequest.FLASH_MODE, CameraMetadata.FLASH_MODE_TORCH);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/2/11/170333059e972dad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p>
<h4 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h4><h5 id="CameraManager"><a href="#CameraManager" class="headerlink" title="CameraManager"></a>CameraManager</h5><p>相机系统服务，用于管理和连接相机设备</p>
<h5 id="CameraDevice"><a href="#CameraDevice" class="headerlink" title="CameraDevice"></a>CameraDevice</h5><p>相机设备类，和Camera1中的Camera同级</p>
<h5 id="CameraCharacteristics"><a href="#CameraCharacteristics" class="headerlink" title="CameraCharacteristics"></a>CameraCharacteristics</h5><p>主要用于获取相机信息，内部携带大量的相机信息，包含摄像头的正反(<code>LENS_FACING</code>)、AE模式、AF模式等，和Camera1中的Camera.Parameters类似</p>
<h5 id="CaptureRequest"><a href="#CaptureRequest" class="headerlink" title="CaptureRequest"></a>CaptureRequest</h5><p>相机捕获图像的设置请求，包含传感器，镜头，闪光灯等</p>
<h5 id="CaptureRequest-Builder"><a href="#CaptureRequest-Builder" class="headerlink" title="CaptureRequest.Builder"></a>CaptureRequest.Builder</h5><p>CaptureRequest的构造器，使用Builder模式，设置更加方便</p>
<h5 id="CameraCaptureSession"><a href="#CameraCaptureSession" class="headerlink" title="CameraCaptureSession"></a>CameraCaptureSession</h5><p>请求抓取相机图像帧的会话，会话的建立主要会建立起一个通道。一个CameraDevice一次只能开启一个CameraCaptureSession。 源端是相机，另一端是 Target，Target可以是Preview，也可以是ImageReader。</p>
<h5 id="ImageReader"><a href="#ImageReader" class="headerlink" title="ImageReader"></a>ImageReader</h5><p>用于从相机打开的通道中读取需要的格式的原始图像数据，可以设置多个ImageReader。</p>
<h3 id="MediaCodec-MediaMuxer"><a href="#MediaCodec-MediaMuxer" class="headerlink" title="MediaCodec MediaMuxer"></a>MediaCodec MediaMuxer</h3><p>在Android4.1和Android4.3才引入，只能支持一个audio track和一个video track，而且仅支持mp4输出<br>MediaExtractor用于音视频分路，和MediaMuxer正好是反过程。MediaFormat用于描述多媒体数据的格式。MediaRecorder用于录像+压缩编码，生成编码好的文件如mp4, 3gpp，视频主要是用于录制Camera preview。MediaPlayer用于播放压缩编码后的音视频文件。AudioRecord用于录制PCM数据。AudioTrack用于播放PCM数据。PCM即原始音频采样数据，可以用如vlc播放器播放。<br>从Camera获取YUV实现硬解，从麦克风采集PCM实现音频播放</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 录制常量</span></span><br><span class="line"><span class="comment">/** How long to wait for the next buffer to become available. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIMEOUT_USEC</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"><span class="comment">/** parameters for the video encoder */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OUTPUT_VIDEO_MIME_TYPE</span> <span class="operator">=</span> <span class="string">&quot;video/avc&quot;</span>; <span class="comment">// H.264 Advanced Video Coding</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OUTPUT_VIDEO_BIT_RATE</span> <span class="operator">=</span> <span class="number">512</span> * <span class="number">1024</span>; <span class="comment">// 512 kbps maybe better</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OUTPUT_VIDEO_FRAME_RATE</span> <span class="operator">=</span> <span class="number">25</span>; <span class="comment">// 25fps</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OUTPUT_VIDEO_IFRAME_INTERVAL</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 10 seconds between I-frames</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OUTPUT_VIDEO_COLOR_FORMAT</span> <span class="operator">=</span> MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420SemiPlanar;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** parameters for the audio encoder */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OUTPUT_AUDIO_MIME_TYPE</span> <span class="operator">=</span> <span class="string">&quot;audio/mp4a-latm&quot;</span>; <span class="comment">// Advanced Audio  Coding</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OUTPUT_AUDIO_BIT_RATE</span> <span class="operator">=</span> <span class="number">64</span> * <span class="number">1024</span>; <span class="comment">// 64 kbps</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OUTPUT_AUDIO_AAC_PROFILE</span> <span class="operator">=</span> MediaCodecInfo.CodecProfileLevel.AACObjectLC; <span class="comment">// better then AACObjectHE?</span></span><br><span class="line"><span class="comment">/** parameters for the audio encoder config from input stream */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">OUTPUT_AUDIO_CHANNEL_COUNT</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// Must match the input stream.can not config</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">OUTPUT_AUDIO_SAMPLE_RATE_HZ</span> <span class="operator">=</span> <span class="number">48000</span>; <span class="comment">// Must match the input stream.can not config</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Whether to copy the video from the test video. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">mCopyVideo</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/** Whether to copy the audio from the test audio. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">mCopyAudio</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/** Width of the output frames. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">mWidth</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">/** Height of the output frames. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">mHeight</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The raw resource used as the input file. */</span></span><br><span class="line"><span class="keyword">private</span> String mBaseFileRoot;</span><br><span class="line"><span class="comment">/** The raw resource used as the input file. */</span></span><br><span class="line"><span class="keyword">private</span> String mBaseFile;</span><br><span class="line"><span class="comment">/** The destination file for the encoded output. */</span></span><br><span class="line"><span class="keyword">private</span> String mOutputFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h3 id="SurfaceView-TextureView-SurfaceTexture等的区别"><a href="#SurfaceView-TextureView-SurfaceTexture等的区别" class="headerlink" title="SurfaceView TextureView SurfaceTexture等的区别"></a>SurfaceView TextureView SurfaceTexture等的区别</h3><h4 id="SurfaceView"><a href="#SurfaceView" class="headerlink" title="SurfaceView"></a>SurfaceView</h4><p>1.1 概述<br>SurfaceView继承自类View，因此它本质上是一个View。但与普通View不同的是，它有自己的Surface，在WMS中有对应的WindowState，在SurfaceFlinger中有Layer。<br>调用者可以通过lockCanvas获得了一块类型为Canvas的画布之后，就可以调用Canvas类所提供的绘图函数来绘制任意的UI了，例如，调用Canvas类的成员函数drawLine、drawRect和drawCircle可以分别用来画直线、矩形和圆。<br>调用者在画布上绘制完成所需要的UI之后，通过调用SurfaceHolder类的成员函数unlockCanvasAndPost就可以将这块画布的图形绘冲区的UI数据提交给SurfaceFlinger服务来处理了，以便SurfaceFlinger服务可以在合适的时候将该图形缓冲区合成到屏幕上去显示，这样就可以将对应的SurfaceView的UI展现出来了。</p>
<p>1.2 双缓冲机制<br>SurfaceView在更新视图时用到了两张Canvas，一张frontCanvas和一张backCanvas，每次实际显示的是frontCanvas，backCanvas存储的是上一次更改前的视图，当使用lockCanvas（）获取画布时，得到的实际上是backCanvas而不是正在显示的frontCanvas，之后你在获取到的backCanvas上绘制新视图，再unlockCanvasAndPost（canvas）此视图，那么上传的这张canvas将替换原来的frontCanvas作为新的frontCanvas，原来的frontCanvas将切换到后台作为backCanvas。例如，如果你已经先后两次绘制了视图A和B，那么你再调用lockCanvas（）获取视图，获得的将是A而不是正在显示的B，之后你将重绘的C视图上传，那么C将取代B作为新的frontCanvas显示在SurfaceView上，原来的B则转换为backCanvas。</p>
<p>1.3 SurfaceView优点与缺点<br>优点： 使用双缓冲机制，可以在一个独立的线程中进行绘制，不会影响主线程，播放视频时画面更流畅<br>缺点：Surface不在View hierachy中，它的显示也不受View的属性控制，SurfaceView 不能嵌套使用。在7.0版本之前不能进行平移，缩放等变换，也不能放在其它ViewGroup中，在7.0版本之后可以进行平移，缩放等变换。</p>
<h4 id="TextureView"><a href="#TextureView" class="headerlink" title="TextureView"></a>TextureView</h4><p>2.1 概述<br>在4.0(API level 14)中引入，与SurfaceView一样继承View，它可以将内容流直接投影到View中，TextureView重载了draw()方法，其中主要SurfaceTexture中收到的图像数据作为纹理更新到对应的HardwareLayer中。<br>和SurfaceView不同，它不会在WMS中单独创建窗口，而是作为View hierachy中的一个普通View，因此可以和其它普通View一样进行移动，旋转，缩放，动画等变化。值得注意的是TextureView必须在硬件加速的窗口中。它显示的内容流数据可以来自App进程或是远端进程。</p>
<p>2.2 TextureView优点与缺点<br>优点：支持移动、旋转、缩放等动画，支持截图<br>缺点：必须在硬件加速的窗口中使用，占用内存比SurfaceView高，在5.0以前在主线程渲染，5.0以后有单独的渲染线程。</p>
<p>2.3 TextureView与SurfaceView对比</p>
<table>
<thead>
<tr>
<th></th>
<th>SurfaceView</th>
<th>TextureView</th>
</tr>
</thead>
<tbody><tr>
<td>内存</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>绘制</td>
<td>及时</td>
<td>1~3帧的延迟</td>
</tr>
<tr>
<td>耗电</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>动画与截图</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>TextureView总是使用GL合成，而SurfaceView可以使用硬件overlay后端，可以占用更少的内存带宽，消耗更少的CPU（耗电）；<br>TextureView的内部缓冲队列导致比SurfaceView使用更多的内存；</p>
<h4 id="SurfaceTexture"><a href="#SurfaceTexture" class="headerlink" title="SurfaceTexture"></a>SurfaceTexture</h4><p>3.1 概述<br>SurfaceTexture 类是在 Android 3.0 中引入的。当你创建了一个 SurfaceTexture，你就创建了你的应用作为消费者的 BufferQueue。当一个新的缓冲区由生产者入队列时，你的应用将通过回调 (onFrameAvailable()) 被通知。你的应用调用 updateTexImage()，这将释放之前持有的缓冲区，并从队列中获取新的缓冲区，执行一些 EGL 调用以使缓冲区可作为一个外部 texture 由 GLES 使用。</p>
<p>3.2 SurfaceTexture与SurfaceView对比<br>SurfaceTexture和SurfaceView不同的是，它对图像流的处理并不直接显示，而是转为OpenGL外部纹理，因此可用于图像流数据的二次处理（如Camera滤镜，桌面特效等）。比如Camera的预览数据，变成纹理后可以交给GLSurfaceView直接显示，也可以通过SurfaceTexture交给TextureView作为View heirachy中的一个硬件加速层来显示。</p>
<h4 id="GLSurfaceView"><a href="#GLSurfaceView" class="headerlink" title="GLSurfaceView"></a>GLSurfaceView</h4><p>GLSurfaceView从Android 1.5(API level 3)开始加入。在SurfaceView的基础上，和SurfaceView不同的是，它加入了EGL的管理，并自带了渲染线程。另外它定义了用户需要实现的Render接口，只需要将实现了渲染函数的Renderer的实现类设置给GLSurfaceView即可。<br>GLSurfaceView也可以作为相机的预览，但是需要创建自己的SurfaceTexture并调用OpenGl API绘制出来。GLSurfaceView 本身自带EGL的管理，并有渲染线程，这对于一些需要多个EGLSurface的场景将不适用。</p>
<h3 id="自定义相机实现"><a href="#自定义相机实现" class="headerlink" title="自定义相机实现"></a>自定义相机实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@datetime</span> 2019-05-05 11:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CameraPreview</span> <span class="keyword">extends</span> <span class="title class_">SurfaceView</span> <span class="keyword">implements</span> <span class="title class_">SurfaceHolder</span>.Callback &#123;</span><br><span class="line">    <span class="keyword">private</span> SurfaceHolder mHolder;</span><br><span class="line">    <span class="keyword">private</span> Camera mCamera;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CameraPreview</span><span class="params">(Context context, Camera camera)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context);</span><br><span class="line">        mCamera = camera;</span><br><span class="line">        mHolder = getHolder();</span><br><span class="line">        mHolder.addCallback(<span class="built_in">this</span>);</span><br><span class="line">        mHolder.setType(SurfaceHolder.SURFACE_TYPE_HARDWARE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">surfaceCreated</span><span class="params">(SurfaceHolder holder)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mCamera.setDisplayOrientation(<span class="number">90</span>);</span><br><span class="line">            mCamera.setPreviewDisplay(holder);</span><br><span class="line">            mCamera.startPreview();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">surfaceChanged</span><span class="params">(SurfaceHolder holder, <span class="type">int</span> format, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (holder.getSurface() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mCamera.stopPreview();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mCamera.setPreviewDisplay(mHolder);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        mCamera.startPreview();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 相机界面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CameraActivity</span> <span class="keyword">extends</span> <span class="title class_">BaseActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Camera mCamera;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isAblum;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BindView(R.id.tv_img)</span></span><br><span class="line">    TextView imgTV;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> BasePresenter <span class="title function_">createPresenter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取照片中的接口回调</span></span><br><span class="line">    Camera.<span class="type">PictureCallback</span> <span class="variable">mPictureCallback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Camera</span>.PictureCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPictureTaken</span><span class="params">(<span class="type">byte</span>[] data, Camera camera)</span> &#123;</span><br><span class="line">        <span class="comment">//这里就是拍照成功后返回照片的地方，注意，返回的是原图，可能几兆十几兆大，需要压缩处理</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> Environment.getExternalStorageDirectory().getPath();</span><br><span class="line">            <span class="type">String</span> <span class="variable">mFilePath</span> <span class="operator">=</span> path + File.separator + <span class="string">&quot;tt001.png&quot;</span>;</span><br><span class="line">            <span class="comment">//文件</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">currentTimeMillis</span> <span class="operator">=</span> DateUtils.getCurrentTimeMillis();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">File</span> <span class="variable">jpgFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(mFilePath);</span><br><span class="line">                <span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(jpgFile); <span class="comment">// 文件输出流</span></span><br><span class="line">                outputStream.write(data); <span class="comment">// 写入sd卡中</span></span><br><span class="line">                outputStream.close(); <span class="comment">// 关闭输出流</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> DateUtils.getCurrentTimeMillis() - currentTimeMillis;</span><br><span class="line">                <span class="type">Long</span> <span class="variable">d</span> <span class="operator">=</span> DateUtils.getCurrentTimeMillis();</span><br><span class="line">                Logger.e(<span class="string">&quot;图片存储时间--&quot;</span>+ l1);</span><br><span class="line">                Luban.with(CameraActivity.<span class="built_in">this</span>)</span><br><span class="line">                        .load(jpgFile)                                   <span class="comment">// 传人要压缩的图片列表</span></span><br><span class="line">                        .ignoreBy(<span class="number">200</span>)                                  <span class="comment">// 忽略不压缩图片的大小</span></span><br><span class="line">                        .setTargetDir(path)                        <span class="comment">// 设置压缩后文件存储位置</span></span><br><span class="line">                        .setCompressListener(<span class="keyword">new</span> <span class="title class_">OnCompressListener</span>() &#123; <span class="comment">//设置回调</span></span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(File file)</span> &#123;</span><br><span class="line">                                <span class="type">long</span> <span class="variable">l2</span> <span class="operator">=</span> DateUtils.getCurrentTimeMillis() - d;</span><br><span class="line">                                Logger.e(<span class="string">&quot;图片压缩时间--&quot;</span>+ l2);</span><br><span class="line">                                EventBus.getDefault().post(<span class="keyword">new</span> <span class="title class_">EventMessage</span>&lt;String&gt;(EventBusTag.PIC_SUCCESS,file.getPath()));</span><br><span class="line">                                finish();</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;).launch();    <span class="comment">//启动压缩</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//实现连续拍多张的效果</span></span><br><span class="line"><span class="comment">//                mCamera.startPreview();</span></span><br><span class="line">                <span class="keyword">if</span> (fos != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        fos.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        <span class="keyword">if</span> (mCamera != <span class="literal">null</span>) &#123;</span><br><span class="line">            mCamera.stopPreview();</span><br><span class="line">            mCamera.setPreviewCallback(<span class="literal">null</span>);</span><br><span class="line">            mCamera.release();</span><br><span class="line">            mCamera = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initView</span><span class="params">()</span> &#123;</span><br><span class="line">        mCamera = Camera.open();    <span class="comment">//初始化 Camera对象</span></span><br><span class="line">        <span class="type">CameraPreview</span> <span class="variable">mPreview</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CameraPreview</span>(<span class="built_in">this</span>, mCamera);</span><br><span class="line">        <span class="type">LinearLayout</span> <span class="variable">camera_preview</span> <span class="operator">=</span> (LinearLayout) findViewById(R.id.camera_preview);</span><br><span class="line">        camera_preview.addView(mPreview);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到照相机的参数</span></span><br><span class="line">        Camera.<span class="type">Parameters</span> <span class="variable">parameters</span> <span class="operator">=</span> mCamera.getParameters();</span><br><span class="line">        <span class="comment">//图片的格式</span></span><br><span class="line">        parameters.setPictureFormat(ImageFormat.JPEG);</span><br><span class="line"><span class="comment">//        //预览的大小是多少</span></span><br><span class="line"><span class="comment">//        parameters.setPreviewSize(camera_preview.getMeasuredWidth(), camera_preview.getMeasuredHeight());</span></span><br><span class="line">        <span class="comment">//设置对焦模式，自动对焦</span></span><br><span class="line">        parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);</span><br><span class="line">        mCamera.setParameters(parameters);</span><br><span class="line"></span><br><span class="line">        findViewById(R.id.tv_pic).setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                <span class="comment">//获取照片</span></span><br><span class="line">                mCamera.takePicture(<span class="literal">null</span>, <span class="literal">null</span>, mPictureCallback);</span><br><span class="line"><span class="comment">//                //对焦成功后，自动拍照</span></span><br><span class="line"><span class="comment">//                mCamera.autoFocus(new Camera.AutoFocusCallback() &#123;</span></span><br><span class="line"><span class="comment">//                    @Override</span></span><br><span class="line"><span class="comment">//                    public void onAutoFocus(boolean success, Camera camera) &#123;</span></span><br><span class="line"><span class="comment">//                        if (success) &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                        &#125;</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                &#125;);</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        imgTV.setVisibility(isAblum ? View.VISIBLE:View.GONE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">getData</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        isAblum = intent.getBooleanExtra(IntentCode.IS_ABLUM,<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getLayoutId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> R.layout.activity_camera;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnClick(&#123;R.id.tv_img,R.id.tv_back&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onViewClick</span><span class="params">(View view)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (view.getId())&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.tv_img:</span><br><span class="line">                jumpToMatisse(CameraActivity.<span class="built_in">this</span>, <span class="number">1</span>,PicMgr.REQUEST_CODE_FINSH);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.tv_back:</span><br><span class="line">                finish();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">jumpToMatisse</span><span class="params">(BaseActivity activity, <span class="keyword">final</span> <span class="type">int</span> count, <span class="type">int</span> resultCode)</span> &#123;</span><br><span class="line">        <span class="type">SelectionCreator</span> <span class="variable">selectionCreator</span> <span class="operator">=</span> Matisse.from(activity).choose(MimeType.ofAll());</span><br><span class="line">        selectionCreator.capture(<span class="literal">false</span>).countable(<span class="literal">true</span>)</span><br><span class="line">                .maxSelectable(count)</span><br><span class="line">                .addFilter(<span class="keyword">new</span> <span class="title class_">GifSizeFilter</span>(<span class="number">320</span>, <span class="number">320</span>, <span class="number">5</span> * Filter.K * Filter.K))</span><br><span class="line">                .gridExpectedSize(activity.getResources().getDimensionPixelSize(R.dimen.px300))</span><br><span class="line">                .restrictOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED)</span><br><span class="line">                .captureStrategy(<span class="keyword">new</span> <span class="title class_">CaptureStrategy</span>(<span class="literal">true</span>, activity.getApplicationContext().getPackageName() + <span class="string">&quot;.fileprovider&quot;</span>))</span><br><span class="line">                .thumbnailScale(<span class="number">0.85f</span>)</span><br><span class="line">                .theme(R.style.Matisse_Zhihu)</span><br><span class="line">                .imageEngine(<span class="keyword">new</span> <span class="title class_">Glide4Engine</span>())</span><br><span class="line">                .setOnSelectedListener(<span class="keyword">new</span> <span class="title class_">OnSelectedListener</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSelected</span><span class="params">(<span class="meta">@NonNull</span> List&lt;Uri&gt; uriList, <span class="meta">@NonNull</span> List&lt;String&gt; pathList)</span> &#123;</span><br><span class="line">                        Log.e(<span class="string">&quot;onSelected&quot;</span>, <span class="string">&quot;onSelected: pathList=&quot;</span> + pathList);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .originalEnable(<span class="literal">true</span>)</span><br><span class="line">                .maxOriginalSize(<span class="number">10</span>)</span><br><span class="line">                .forResult(resultCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onActivityResult</span><span class="params">(<span class="type">int</span> requestCode, <span class="type">int</span> resultCode, Intent data)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">        <span class="keyword">if</span> (requestCode == PicMgr.REQUEST_CODE_FINSH &amp;&amp; resultCode == RESULT_OK) &#123;</span><br><span class="line">            setResult(Activity.RESULT_OK,data);</span><br><span class="line">            finish();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SurfaceView生命周期"><a href="#SurfaceView生命周期" class="headerlink" title="SurfaceView生命周期"></a>SurfaceView生命周期</h3><p>SurfaceHolder.Callback的回调<br>surfaceCreated()<br>surfaceChanged()</p>
<h3 id="自定义View需要重写的方法"><a href="#自定义View需要重写的方法" class="headerlink" title="自定义View需要重写的方法"></a>自定义View需要重写的方法</h3><ol>
<li>构造器:重写构造器是定制View的最基本方式，当Java代码创建一个View实例，或根据XML布局文件加载并构建界面时将需要调用该构造器。</li>
<li>onFinishinflate():这是一个回调方法，当应用从XML布局文件加载该组件并利用它来构建界面之后，该方法就会被回调。</li>
<li>onMeasure(int,int):调用该方法来检测View组件及它所包含的所有子组件的大小。</li>
<li>onLayout(boolean,int,int,int,int):当该组件需要分配其子控件的位置、大小时该方法就会被调用。</li>
<li>onSizeChanged(int, int, int, int):当该组件的大小被改变时回调该方法。</li>
<li>onDraw(Canvas):当该组件将要绘制它的内容时回调该方法进行绘制。</li>
<li>onKeyDown(int, KeyEvent):当某个键被按下时触发该方法。</li>
<li>onKeyUp(int, KeyEvent):当松开某个键时触发该方法。</li>
<li>onTrackballEvent(MotionEvent):当发生轨迹球事件时触发该方法。</li>
<li>onTouchEvent(MotionEvent):当发生触摸屏事件时触发该方法。</li>
<li>onWindowFocusChanged(boolean):当该组件得到、失去焦点时触发该方法。</li>
<li>onAttachedToWindow():当把该组件放入某个窗口时触发该方法。</li>
<li>onDetachedFromWindow():当把该组件从某个窗口上分离时触发该方法。</li>
<li>onWindowVisibilityChanged(int):当包含该组件的窗口的可见性发生改变时触发该方法。</li>
</ol>
<h3 id="自定义View什么时候可以获取到view的宽高"><a href="#自定义View什么时候可以获取到view的宽高" class="headerlink" title="自定义View什么时候可以获取到view的宽高"></a>自定义View什么时候可以获取到view的宽高</h3><p>Constructor-&gt;onFinishInflate-&gt;onMeasure-&gt;onSizeChanged-&gt;onLayout-&gt;addOnGlobalLayoutListener-&gt;onWindowFocusChanged-&gt;onMeasure-&gt;onLayout</p>
<ol>
<li>Constructor:构造方法,View初始化的时候调用,在这里是无法获取其子控件的引用的.更加无法获取宽高了.</li>
<li>onFinishInflate:当布局初始化完毕后回调,在这里可以获取所有直接子View的引用,但是无法获取宽高.</li>
<li>onMeasure:当测量控件宽高时回调,当调用了requestLayout()也会回调onMeasure.在这里一定可以通过getMeasuredHeight()和getMeasuredWidth()来获取控件的高和宽,但不一定可以通过getHeight()和getWidth()来获取控件宽高,因为getHeight()和getWidth()必须要等onLayout方法回调之后才能确定.</li>
<li>onSizeChanged:当控件的宽高发生变化时回调,和onMeasure一样,一定可以通过getMeasuredHeight()和getMeasuredWidth()来获取控件的高和宽,因为它是在onMeasure方法执行之后和onLayout方法之前回调的.</li>
<li>onLayout:当确定控件的位置时回调,当调用了requestLayout()也会回调onLayout.在这里一定可以通过getHeight()和getWidth()获取控件的宽高,同时由于onMeasure方法比onLayout方法先执行,所以在这里也可以通过getMeasuredHeight()和getMeasuredWidth()来获取控件的高和宽.</li>
<li>addOnGlobalLayoutListener:当View的位置确定完后会回调改监听方法,它是紧接着onLayout方法执行而执行的,只要onLayout方法调用了,那么addOnGlobalLayoutListener的监听器就会监听到.在这里getMeasuredHeight()和getMeasuredWidth()和getHeight()和getWidth()都可以获取到宽高.</li>
<li>onWindowFocusChanged:当View的焦点发送改变时回调,在这里getMeasuredHeight()和getMeasuredWidth()和getHeight()和getWidth()都可以获取到宽高.Activity也可以通过重写该方法来判断当前的焦点是否发送改变了;需要注意的是这里View获取焦点和失去焦点都会回调.</li>
</ol>
<p>那么,上面分析了那么多方法来获取控件的宽高,那到底用哪一种呢?</p>
<p>具体要用哪一种,是需要根据View的宽高是否会发生变化来决定:</p>
<ol>
<li>如果自定义的View在使用的过程中宽高信息是不会改变的,那么上面方式3~方式7都可以使用.</li>
<li>如果自定义的View在使用过程中宽高信息都会发生改变的,而且又需要获取一开始时的宽高信息,那么建议使用View.getViewTreeObserver().addOnGlobalLayoutListener(OnGlobalLayoutListener listener)的方式,因为这种方式有getViewTreeObserver().removeOnGlobalLayoutListener(this);来避免回调函数因宽高信息的变化而多次调用,如果使用其他方式的话,就要借助额外的变量来保证获取到的宽高是View的初始高度.</li>
</ol>
<h3 id="onTouchEvent-返回值作用"><a href="#onTouchEvent-返回值作用" class="headerlink" title="onTouchEvent()返回值作用"></a>onTouchEvent()返回值作用</h3><p>true表示已经消耗了<br>false表示没有操作完，继续分发</p>
<h3 id="一次完整的Http-Https请求"><a href="#一次完整的Http-Https请求" class="headerlink" title="一次完整的Http&#x2F;Https请求"></a>一次完整的Http&#x2F;Https请求</h3><p><img src="https://pic1.zhimg.com/80/v2-4a9996d1f96058dc50a49caa8ddb5b90_1440w.jpg" alt="image"></p>
<h4 id="HTTP与HTTPS的不同点"><a href="#HTTP与HTTPS的不同点" class="headerlink" title="HTTP与HTTPS的不同点"></a>HTTP与HTTPS的不同点</h4><ul>
<li>1、HTTPS需要用到CA申请证书。</li>
<li>2、HTTP是超文本传输协议，信息是明文的；HTTPS则是具有安全性的SSL加密传输协议。</li>
<li>3、HTTPS和HTTP使用的是完全不同的连接方式，用的端口也不一样，HTTP是80,HTTPS是443。</li>
<li>4、HTTP的连接很简单，是无状态的，HTTPS是HTTP+SSL协议构建的，可进行加密传输、身份认证的网络协议，比HTTP协议安全。</li>
</ul>
<h4 id="HTTPS的优势"><a href="#HTTPS的优势" class="headerlink" title="HTTPS的优势"></a>HTTPS的优势</h4><ul>
<li>1、内容加密，建立一个信息的安全通道，来保证数据传输过程的安全性。</li>
<li>2、身份认证，确认网站的真是性。</li>
<li>3、数据完整性，防止内容被第三方冒充或者篡改。</li>
</ul>
<h4 id="HTTPS请求过程"><a href="#HTTPS请求过程" class="headerlink" title="HTTPS请求过程"></a>HTTPS请求过程</h4><p>HTTPS协议的本质就是HTTP + SSL(or TLS)。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层级结构看它位于HTTP协议与TCP协议之间。</p>
<p><img src="http://jiaxf.github.io/img/http&https.png" alt="image"></p>
<p>HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS&#x2F;SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。</p>
<p><img src="http://jiaxf.github.io/img/https%E8%BF%87%E7%A8%8B.png" alt="image"></p>
<blockquote>
<p>  1、浏览器发起往服务器的 443 端口发起请求，请求携带了浏览器支持的加密算法和哈希算法。<br>  2、服务器收到请求，选择浏览器支持的加密算法和哈希算法。<br>  3、服务器将数字证书返回给浏览器，这里的数字证书可以是向某个可靠机构申请的，也可以是自制的。<br>      （注释：证书包括以下这些内容：1. 证书序列号。2. 证书过期时间。3. 站点组织名。4. 站点DNS主机名。5. 站点公钥。6. 证书颁发者名。7. 证书签名。因为证书是要给大家用的，所以不需要加密传输）<br>  4、浏览器进入数字证书认证环节，这一部分是浏览器内置的 TSL 完成的：<br>      4.1 首先浏览器会从内置的证书列表中索引，找到服务器下发证书对应的机构，如果没有找到，此时就会提示用户该证书是不是由权威机构颁发，是不可信任的。如果查到了对应的机构，则取出该机构颁发的公钥。<br>      4.2 用机构的证书公钥解密得到证书的内容和证书签名，内容包括网站的网址、网站的公钥、证书的有效期等。浏览器会先验证证书签名的合法性（验证过程类似上面 Bob 和 Susan 的通信）。<br>      签名通过后，浏览器验证证书记录的网址是否和当前网址是一致的，不一致会提示用户。如果网址一致会检查证书有效期，证书过期了也会提示用户。这些都通过认证时，浏览器就可以安全使用证书中的网站公钥了。<br>      4.3 浏览器生成一个随机数 R，并使用网站公钥对 R 进行加密。<br>  5、浏览器将加密的 R 传送给服务器。<br>  6、服务器用自己的私钥解密得到 R。<br>  7、服务器以 R 为密钥使用了对称加密算法加密网页内容并传输给浏览器。<br>  8、浏览器以 R 为密钥使用之前约定好的解密算法获取网页内容。</p>
<p>  数字证书如何认证？ 首先你的证书会在https握手过程中被传递到浏览器，浏览器从你的证书中找到了颁发者，从颁发者的证书（如果你电脑上有的话）又找到了CA的证书<br>  （CA证书会在操作系统安装时就安装好，所以每个人电脑上都有根证书），使用CA证书中带的公钥来对颁发者证书做验签，一旦匹配，说明你电脑上的颁发者证书不是伪造的，<br>  同理，再用颁发者证书中的公钥去验证你的证书，以此证明你的证书不是伪造的。这样整个链状的验证，从而确保你的证书一定是直接或间接从CA签发的，<br>  这样浏览器地址栏会显示一个绿色的盾牌，表示你的网站能通过证书验证。<br>  如果你的电脑上没有颁发者证书（断链）或者你自己本身就是自签名证书（自己做CA，但是要记得，人家电脑上并没有装你的自签名根证书），那么浏览器会报警提示不能验证证书，问你是否还需要继续。</p>
</blockquote>
<p><img src="http://jiaxf.github.io/img/zhengshu.png" alt="image"></p>
<p><img src="http://jiaxf.github.io/img/https%E4%BC%A0%E8%BE%93.png" alt="image"></p>
<blockquote>
<p>  HTTPS 连接大致上可以划分为两个部分，第一个是建立连接时时的非对称加密握手，第二个是握手后的对称加密报文传输。<br>  在最差的情况下，也就是不做任何的优化措施，HTTPS 建立连立连接可能会比HTTP 慢上几百毫秒甚至几秒，这其中既有网络耗时，也有计算耗时，就会让人产生“打开一个 HTTPS 网站好慢啊”的感觉。</p>
</blockquote>
<h4 id="HTTPS优化"><a href="#HTTPS优化" class="headerlink" title="HTTPS优化"></a>HTTPS优化</h4><p><img src="http://jiaxf.github.io/img/https%E4%BC%98%E5%8C%96.png" alt="image"></p>
<ul>
<li><p>硬件优化</p>
</li>
<li><p>更快的CPU</p>
</li>
<li><p>SSL加速卡 如：阿里的Tengine</p>
</li>
<li><p>SSL加速服务器</p>
</li>
<li><p>软件优化</p>
</li>
<li><p>软件升级 如：Linux 内核由 2.x 升级到 4.x，把 把 Nginx 由 1.6 升级到 1.16，把 OpenSSL 由 1.0.1 升级到 1.1.0&#x2F;1.1.1。</p>
</li>
<li><p>协议优化</p>
</li>
<li><p>采用 TLS1.3</p>
</li>
<li><p>握手时使用的密钥交换协议应当尽量选用椭圆曲线的 ECDHE 算法。它不仅运算速度快，安全性高，还支持“False Start”</p>
</li>
<li><p>椭圆曲线也要选择高性能的曲线，最好是 x25519，次优选择是 P-256。对称加密算法方面，也可以选用“AES_128_GCM”，它能比“AES_256_GCM”略快一点点。</p>
</li>
<li><p>证书优化</p>
</li>
<li><p>采用选择椭圆曲线（ECDSA）证书而不是 RSA 证书，因为 224 位的 ECC 相当于 2048 位的 RSA，节约带宽和计算量</p>
</li>
<li><p>“OCSP Stapling”（OCSP 装订），它可以让服务器预先访问 CA 获取 OCSP 响应，然后在握手时随着证书一起发给客户端，免去了客户端连接 CA 服务器查询的时间。</p>
</li>
<li><p>会话复用</p>
</li>
<li><p>会话复用的效果类似 Cache，前提是客户端必须之前成功建立连接，后面就可以用“Session ID”“Session Ticket”等凭据跳过密钥交换、证书验证等步骤，直接开始加密通信。</p>
</li>
</ul>
<h3 id="Glide缓存机制"><a href="#Glide缓存机制" class="headerlink" title="Glide缓存机制"></a>Glide缓存机制</h3><p><strong>Glide5大磁盘缓存策略</strong><br><code>DiskCacheStrategy.DATA</code>: 只缓存原始图片；<br><code>DiskCacheStrategy.RESOURCE</code>:只缓存转换过后的图片；<br><code>DiskCacheStrategy.ALL</code>:既缓存原始图片，也缓存转换过后的图片；对于远程图片，缓存 <code>DATA</code>和 <code>RESOURCE</code>；对于本地图片，只缓存 <code>RESOURCE</code>；<br><code>DiskCacheStrategy.NONE</code>：不缓存任何内容；<br><code>DiskCacheStrategy.AUTOMATIC</code>：默认策略，尝试对本地和远程图片使用最佳的策略。当下载网络图片时，使用<code>DATA</code>；对于本地图片，使用<code>RESOURCE</code>；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key是为了解决缓存图片的唯一性</span></span><br><span class="line"><span class="comment">// Engine#load()</span></span><br><span class="line"><span class="comment">//生成缓存key</span></span><br><span class="line"><span class="type">EngineKey</span> <span class="variable">key</span> <span class="operator">=</span> keyFactory.buildKey(model, signature, width, height, transformations,</span><br><span class="line">        resourceClass, transcodeClass, options);</span><br></pre></td></tr></table></figure>

<p>内存缓存逻辑：首先通过<code>loadFromActiveResources</code>从弱引用读取；如果没有再通过<code>loadFromCache</code>从LruCache读取；2者中的任意一个获取到数据就会调用<code>onResourceReady</code>就是将资源回调给ImageView去加载。</p>
<p><strong>Glide缓存分为<code>弱引用(WeakReference) + LruCache + DiskLruCache</code>，其中读取数据的顺序是：弱引用 &gt; LruCache &gt; DiskLruCache&gt;网络；写入缓存的顺序是：网络 –&gt; DiskLruCache–&gt; LruCache–&gt;弱引用</strong></p>
<p><strong>内存缓存分为弱引用的和 LruCache ，其中正在使用的图片使用弱引用缓存，暂时不使用的图片用 LruCache缓存，这一点是通过 图片引用计数器（acquired变量）来实现的，详情可以看内存缓存的小结。</strong></p>
<p><strong>磁盘缓存就是通过DiskLruCache实现的，根据缓存策略的不同会获取到不同类型的缓存图片。它的逻辑是：先从转换后的缓存中取；没有的话再从原始的（没有转换过的）缓存中拿数据；再没有的话就从网络加载图片数据，获取到数据之后，再依次缓存到磁盘和弱引用。</strong></p>
<h3 id="Glide内存优化"><a href="#Glide内存优化" class="headerlink" title="Glide内存优化"></a>Glide内存优化</h3><blockquote>
<p>  首先，内存总量有限，必须限制图片加载的内存</p>
<p>  弱引用</p>
<p>  这个大家都懂，好多第三方加载组件也体现了这个思路。</p>
<p>  最早，大家将Bitmap用弱引用管理起来，当内存不足时，系统会自动GC回收掉部分引用，从而达到内存管理的目的。 这种方式很简单，组件本身不管理图片内存，而是交给GC，有GC来自动回收内存。</p>
<p>  这种方法会有几个问题：</p>
<p>  应用占有的内存量会不断攀升，知道内存不足时，出现断崖时的内存回收</p>
<p>  GC的时间可能会比较长，造成界面会有明显的卡顿。</p>
<p>  GC回收的内存，没有区分，可能回收了最近在使用的Bitmap，造成二次加载。</p>
<p>  最严重的，新的Android系统开始每次GC都会回收弱引用，这就使内存缓存没有用处。</p>
<p>  强引用+LRU算法</p>
<p>  基于以上问题，有些组件开始用强引用+LRU算法的方式处理图片加载的问题，其思路大概是：</p>
<p>  给定一个固定图片缓存大小，将所有的使用的Bitmap用强引用的方式管理起来，并利用LRU算法，将旧的Bitmap释放，新的bitmap增加。</p>
<p>  这样，图片缓存不会无限制的增长，内存量也能处在一个较理想的范围，申请和释放。UIL就是采用这种方法。</p>
<p>  但这个思路也会有问题：</p>
<p>  图片缓存的内存不会无限制增长，但会周期性的释放和申请。特别是对于一个长列表页面，图片会不断的申请，不断的释放。因为最终的内存释放还是GC去处理，快速滑动时，会造成大量的图片申请内存，大量的图片释放，系统的GC会很频繁，就产生了所谓的内存抖动。</p>
<p>  内存的抖动同样也会造成界面卡顿，在快速滑动时，会非常明显。</p>
<p>  提到界面卡顿，我要说明下卡顿的原因。</p>
<p>  人眼能识别的帧数是一秒24帧，就是所若一个屏幕以每秒24帧显示时，人眼是看不出什么的，感觉很流畅。但若少于24帧，我们就能感觉出卡顿，不流畅。 最佳的帧数是每秒60帧，再高就没有任何意义了，一般显卡会跟屏幕的刷新速率保持一致，大部分都是60hz。</p>
<p>  那我们来计算下，最高60帧，1000ms&#x2F;60帧&#x3D;16ms&#x2F;帧，最低24帧，1000ms&#x2F;24帧&#x3D;42ms，也就是说每次ui线程里面的计算最佳的情况是少于16ms，最高则不能超过42ms。</p>
<p>  以ListView为例，getView的运行时间不能大于42ms, 推荐大家用<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/JakeWharton/hugo">hugo</a>统计运行时间，很方便。</p>
<p>  特殊情况下，即便是不大于42ms，接近也会造成卡顿，因为还会有其他的函数运行。</p>
<p>  在这种情况下，若出现内存抖动，就会频繁的暂停进程，释放内存，极易出现卡顿。</p>
<p>  GLide的BitmapPool</p>
<p>  Glide对这个环节做了非常好的优化，解决了内存抖动的问题。</p>
<p>  Glide构建了一个BitmapPool，Bitmap申请和回收都是透过BitmapPool来处理的。新加载图片时，会先从BitmapPool里面找有没有相应大小的Bitmap，有则直接使用，没有才会申请新的Bitmap；回收时，则会提交给BitmapPool, 供下次使用。</p>
<p>  这种方式极大的减少了Bitmap的申请和回收操作，使得GC频度降低了很多。</p>
<p>  图片与显示区域大小一致</p>
<p>  图片加载最终的目的是显示到界面上，因此若是图片缓存的尺寸大于显示区域的尺寸是没有必要的。不光是造成内存浪费，占用较大的内存，而且会造成图片解析速度比较慢。</p>
<p>  因此，不管是UIL，Glide和Freso等等都建议ImageView需要给定固定的长和宽，这样图片加载时，就可以根据显示区域的大小，加载最小的图片，又不会造成损失。</p>
<p>  另外，七牛的云服务提供了imageView2参数，可以给定长宽，在网络加载层次上就可以降低加载的图片尺寸，提高加载速度。</p>
<p>  另外，UIL，Glide都将缩放后的图片缓存到本地，下次加载时直接从磁盘缓存加载，也会有比原始尺寸加载更好的速度。</p>
<p>  图片的加载优化有很多内容可以做，比如现在的图片加载，都是等将要显示时开始加载，这样图片可能需要等待一下才能加载出来，我们是不是可以提前加载呢？</p>
</blockquote>
<h3 id="强引用-弱应用-软引用-虚引用"><a href="#强引用-弱应用-软引用-虚引用" class="headerlink" title="强引用 弱应用 软引用 虚引用"></a>强引用 弱应用 软引用 虚引用</h3><ol>
<li>强引用</li>
</ol>
<blockquote>
<p>  强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出<code>OutOfMmoryError</code>错误，使程序异常终止，也不会靠随意回收具有强引用对象来解决内存不足的问题。</p>
</blockquote>
<ol>
<li>软引用</li>
</ol>
<blockquote>
<p>  软引用是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<p>  软引用关联的对象不会被<code>GC</code>回收。<code>JVM</code>在分配空间时，若果<code>Heap</code>空间不足，就会进行相应的<code>GC</code>，但是这次<code>GC</code>并不会收集软引用关联的对象，但是在JVM发现就算进行了一次回收后还是不足（<code>Allocation Failure</code>），<code>JVM</code>会尝试第二次<code>GC</code>，回收软引用关联的对象。</p>
<p>  像这种如果内存充足，<code>GC</code>时就保留，内存不够，<code>GC</code>再来收集的功能很适合用在缓存的引用场景中。在使用缓存时有一个原则，如果缓存中有就从缓存获取，如果没有就从数据库中获取，缓存的存在是为了加快计算速度，如果因为缓存导致了内存不足进而整个程序崩溃，那就得不偿失了。</p>
</blockquote>
<ol start="3">
<li>弱引用</li>
</ol>
<blockquote>
<p>  弱引用也是用来描述非必须对象的，他的强度比软引用更弱一些，被弱引用关联的对象，在垃圾回收时，如果这个对象只被弱引用关联（没有任何强引用关联他），那么这个对象就会被回收。</p>
<p>  设计 <code>WeakHashMap</code>类是为了解决一个有趣的问题。如果有一个值，对应的键已经不再 使用了， 将会出现什么情况呢？ 假定对某个键的最后一次引用已经消亡，不再有任何途径引 用这个值的对象了。但是，由于在程序中的任何部分没有再出现这个键，所以，这个键 &#x2F; 值 对无法从映射中删除。为什么垃圾回收器不能够删除它呢？ 难道删除无用的对象不是垃圾回 收器的工作吗？</p>
<p>  遗憾的是，事情没有这样简单。垃圾回收器跟踪活动的对象。只要映射对象是活动的， 其中的所有桶也是活动的， 它们不能被回收。因此，需要由程序负责从长期存活的映射表中 删除那些无用的值。 或者使用 <code>WeakHashMap</code>完成这件事情。当对键的唯一引用来自散列条<br>  目时， 这一数据结构将与垃圾回收器协同工作一起删除键 &#x2F; 值对。</p>
<p>  下面是这种机制的内部运行情况。<code>WeakHashMap</code> 使用弱引用（<code>weak references</code>) 保存键。 <code>WeakReference</code> 对象将引用保存到另外一个对象中，在这里，就是散列键。对于这种类型的 对象，垃圾回收器用一种特有的方式进行处理。通常，如果垃圾回收器发现某个特定的对象 已经没有他人引用了，就将其回收。然而， 如果某个对象只能由 <code>WeakReference</code> 引用， 垃圾 回收器仍然回收它，但要将引用这个对象的弱引用放人队列中。<code>WeakHashMap</code>将周期性地检 查队列， 以便找出新添加的弱引用。一个弱引用进人队列意味着这个键不再被他人使用， 并 且已经被收集起来。于是， <code>WeakHashMap</code>将删除对应的条目。</p>
<p>  除了<code>WeakHashMap</code>使用了弱引用，<code>ThreadLocal</code>类中也是用了弱引用。</p>
</blockquote>
<ol start="4">
<li>虚引用</li>
</ol>
<blockquote>
<p>  一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获取一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。虚引用和弱引用对关联对象的回收都不会产生影响，如果只有虚引用活着弱引用关联着对象，那么这个对象就会被回收。它们的不同之处在于弱引用的<code>get</code>方法，虚引用的<code>get</code>方法始终返回<code>null</code>,弱引用可以使用<code>ReferenceQueue</code>,虚引用必须配合<code>ReferenceQueue</code>使用。</p>
<p>  <code>jdk</code>中直接内存的回收就用到虚引用，由于<code>jvm</code>自动内存管理的范围是堆内存，而直接内存是在堆内存之外（其实是内存映射文件，自行去理解虚拟内存空间的相关概念），所以直接内存的分配和回收都是有<code>Unsafe</code>类去操作，<code>java</code>在申请一块直接内存之后，会在堆内存分配一个对象保存这个堆外内存的引用，这个对象被垃圾收集器管理，一旦这个对象被回收，相应的用户线程会收到通知并对直接内存进行清理工作。</p>
</blockquote>
<h3 id="SharedPreferences-apply和commit的区别"><a href="#SharedPreferences-apply和commit的区别" class="headerlink" title="SharedPreferences apply和commit的区别"></a>SharedPreferences apply和commit的区别</h3><p>commit特点如下</p>
<blockquote>
<ol>
<li>存储的过程是原子操作</li>
<li>commit方法有返回值，设置成功为ture，否则为false</li>
<li>同时对一个SharedPreferences设置值最后一次的设置会直接覆盖前次值</li>
<li>如果不关心设置成功与否，并且是在主线程设置值，建议用apply方法</li>
</ol>
</blockquote>
<p>apply特点如下</p>
<blockquote>
<ol>
<li>存储的过程也是原子操作</li>
<li>apply没有返回值，存储是否成功无从知道。</li>
<li>apply写入过程分两步，第一步先同步写入内存，第二部在异步写入物理磁盘。并且写入的过程会阻塞同一个SharedPreferences对象的其他写入操作。</li>
</ol>
</blockquote>
<p>原子操作的意思是”不可中断的一个或一系列操作”,通俗的讲一个操作一旦开始，在结束前不会被打断。比如常见的++i操作就不具有原子性，因为它实际上包含了3个步骤，1-读取i的值，2-对读取的i值加1，3-写入加1后的值。单独看此三个步骤都是原子操作，但组合起来就是非原子操作了。</p>
<p>总结<br>commit相对于apply效率较低，commit直接是向物理介质写入内容，而apply是先同步将内容提交到内存，然后在异步的向物理介质写入内容。这样做显然提高了效率。</p>
<h3 id="Message的源码"><a href="#Message的源码" class="headerlink" title="Message的源码"></a>Message的源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object obj; <span class="comment">// 用来保存对象</span></span><br><span class="line"><span class="keyword">public</span> Messenger replyTo; <span class="comment">// 回复跨进程的Messenger</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="variable">sendingUid</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// Messenger发送时使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FLAG_IN_USE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">0</span>; <span class="comment">// 正在使用标志值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FLAG_ASYNCHRONOUS</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">1</span>; <span class="comment">// 异步标志值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FLAGS_TO_CLEAR_ON_COPY_FROM</span> <span class="operator">=</span> FLAG_IN_USE;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flags; <span class="comment">// 消息标志，上面三个常量 FLAG_* 用在这里</span></span><br><span class="line"><span class="type">long</span> when; <span class="comment">// 估计和arg1、arg2性质一样，存时间戳</span></span><br><span class="line"></span><br><span class="line">Bundle data;    <span class="comment">// 存放Bundle</span></span><br><span class="line">Handler target; <span class="comment">// 存放Handler实例，用于判断是哪个Handler发送的Message</span></span><br><span class="line">Runnable callback; <span class="comment">// 消息的回调操作</span></span><br><span class="line">Message next;   <span class="comment">// 消息池用链表的方式存储</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">sPoolSync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 消息池同步公用标志</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool; <span class="comment">// 消息池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">sPoolSize</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 消息池已缓存数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">50</span>; <span class="comment">// 消息池最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">gCheckRecycle</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 该版本系统是否支持回收标志位</span></span><br></pre></td></tr></table></figure>

<h3 id="Messenger与Message的区别"><a href="#Messenger与Message的区别" class="headerlink" title="Messenger与Message的区别"></a>Messenger与Message的区别</h3><blockquote>
<p><strong>Messenger</strong> 可以翻译为信使，顾名思义，通过它可以在不同进程中传递Message对象.<br><strong>Message</strong> 可以翻译为信封，顾名思义，信封里附带着数据</p>
</blockquote>
<h5 id="Messenger"><a href="#Messenger" class="headerlink" title="Messenger"></a>Messenger</h5><p>Messenger是一种轻量级的IPC方案，它的底层实现是AIDL，为什么这么说呢，大致看一下Messenger这个类的构造方法就明白了。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new Messenger pointing to the given Handler.  Any Message</span></span><br><span class="line"><span class="comment"> * objects sent through this Messenger will appear in the Handler as if</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Handler#sendMessage(Message) Handler.sendMessage(Message)&#125; had</span></span><br><span class="line"><span class="comment"> * been called directly.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target The Handler that will receive sent messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_ invoke__">Messenger</span>(Handler target) &#123;</span><br><span class="line">    mTarget = target.<span class="title function_ invoke__">getIMessenger</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a Messenger from a raw IBinder, which had previously been</span></span><br><span class="line"><span class="comment"> * retrieved with &#123;<span class="doctag">@link</span> #getBinder&#125;.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target The IBinder this Messenger should communicate with.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_ invoke__">Messenger</span>(IBinder target) &#123;</span><br><span class="line">    mTarget = IMessenger.Stub.<span class="title function_ invoke__">asInterface</span>(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从Messenger两个构造方法的实现上我们可以明显看出AIDL的痕迹，不管是IMessenger还是Stub.asInterface，这种使用方法都表明它的底层是AIDL。</p>
<p>我们接着来看Messenger的两个重要方法：</p>
<blockquote>
<p>  <strong>getBinder()</strong> : 返回一个IBinder对象，一般在服务端的onBind方法调用这个方法，返回给客户端一个IBinder对象<br>  <strong>send(Message msg)</strong> : 发送一个message对象到messengerHandler。这里，我们传递的参数是一个Message对象，</p>
</blockquote>
<h5 id="Messenge"><a href="#Messenge" class="headerlink" title="Messenge"></a>Messenge</h5><p>如果说Messenger充当了信使的角色，那么Message就充当了一个信封的角色。同样地，先看官方文档的描述：</p>
<blockquote>
<p>  Defines a message containing a description and arbitrary data object that can be sent to a Handler. This object contains two extra int fields and an extra object field that allow you to not do allocations in many cases.While the constructor of Message is public,the best way to get one of these is to call Message.obtain() or one of the Handler.obtainMessage() methods, which will pull them from a pool of recycled objects.</p>
</blockquote>
<p>从官文的描述可知，该Message对象含有两个Int型的属性和一个object型的属性，然后创建Message的实例，最好调用Message.obtain()方法而不是直接通过构造器。我们来看看主要参数以及重要方法：</p>
<ul>
<li>属性 public int arg1,public int arg2,public Object obj : 一般这三个属性用于保存数据，其中Object对象用于保存一个对象。</li>
<li>属性 public Messenger replyTo : 这个属性一般用于服务端需要返回消息给客户端的时候用到，下面会说到。</li>
<li>属性 public int what:这个属性用于描述这个message，一般在实例化的时候会传递这个参数。</li>
<li>方法 obtain()：提供了多个参数的重载方法，为了获得message实例。</li>
<li>setData(Bundle data):设置obj的值，Bundle将在下节单独讲一下。</li>
</ul>
<h4 id="实现举例"><a href="#实现举例" class="headerlink" title="实现举例"></a>实现举例</h4><p>Messenger的使用方法很简单，它对AIDL做了封装，使得我们可以更简便地进行进程间通信。同时，由于因为Handler的机制一次处理一个请求，因此在服务端我们不用考虑线程同步的问题。实现一个Messenger有如下几个步骤，分为服务端和客户端。</p>
<h5 id="1-创建一个Service"><a href="#1-创建一个Service" class="headerlink" title="1. 创建一个Service"></a>1. 创建一个Service</h5><p>首先，我们需要在服务端创建一个Service来处理客户端的连接请求，同时创建一个Handler并通过它来创建一个Messenger对象，然后在Service的onBind中返回这个Messenger对象底层的Binder即可。<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessengerService</span> <span class="keyword">extends</span> <span class="title class_">Service</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">IncomingHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.handleMessage(msg);</span><br><span class="line">            <span class="keyword">switch</span> (msg.what)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    Toast.makeText(getApplicationContext(), <span class="string">&quot;hello, trampcr&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Messenger</span> <span class="variable">mMessenger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Messenger</span>(<span class="keyword">new</span> <span class="title class_">IncomingHandler</span>());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        Toast.makeText(getApplicationContext(), <span class="string">&quot;binding&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        <span class="keyword">return</span> mMessenger.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-声明进程"><a href="#2-声明进程" class="headerlink" title="2. 声明进程"></a>2. 声明进程</h5><p>然后，在AndroidManifest中声明Service并给一个进程名，使该服务成为一个单独的进程。<br>AndroidManifest配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">&quot;.MessengerService&quot;</span>  </span></span><br><span class="line"><span class="tag">         <span class="attr">android:process</span>=<span class="string">&quot;yb.demo.myProcesses.musicservice&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="3-创建客户端"><a href="#3-创建客户端" class="headerlink" title="3. 创建客户端"></a>3. 创建客户端</h5><p>户端进程中，首先要绑定服务端的Service，绑定成功后用服务端返回的IBinder对象创建一个Messenger，通过这个Messenger就可以向服务端发送消息了，发消息类型为Message对象。这听起来可能还是有点抽象，不过看了下面的两个例子，读者肯定就都明白了。首先，我们来看一个简单点的例子，在这个例子中服务端无法回应客户端。<br>首先看服务端的代码，这是服务端的典型代码，可以看到MessengerHandler用来处理客户端发送的消息，并从消息中取出客户端发来的文本信息。而mMessenger是一个Messenger对象，它和MessengerHandler相关联，并在onBind方法中返回它里面的Binder对象，可以看出，这里Messenger的作用是将客户端发送的消息传递给MessengerHandler处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessengerActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> mBound;</span><br><span class="line">    <span class="keyword">private</span> Messenger mMessenger;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ServiceConnection</span> <span class="variable">mServiceConnection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> &#123;</span><br><span class="line">            mMessenger = <span class="keyword">new</span> <span class="title class_">Messenger</span>(service);</span><br><span class="line">            mBound = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceDisconnected</span><span class="params">(ComponentName name)</span> &#123;</span><br><span class="line">            mMessenger = <span class="literal">null</span>;</span><br><span class="line">            mBound = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(View v)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!mBound)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain(<span class="literal">null</span>, <span class="number">0</span> , <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mMessenger.send(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_messenger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStart();</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MessengerActivity.<span class="built_in">this</span>, MessengerService.class);</span><br><span class="line">        bindService(intent, mServiceConnection, BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStop();</span><br><span class="line">        <span class="keyword">if</span>(mBound)&#123;</span><br><span class="line">            unbindService(mServiceConnection);</span><br><span class="line">            mBound = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上代码，可以看到Messenger的使用方法：</p>
<ol>
<li>服务实现一个Handler，由其接收来自客户端的每个调用的回调。</li>
<li>Handler用于创建Messenger对象（对Handler的引用）。</li>
<li>Messenger创建一个IBinder，服务通过onBind()使其返回客户端。</li>
<li>客户端使用IBinder将Messenger（引用服务的Handler）实例化，然后使用后者将Message对象发送给服务。</li>
<li>服务在其Handler中（具体地讲，是在handleMessage()方法中）接收每个Message。</li>
</ol>
<p>这样，客户端并没有调用服务的“方法”。而客户端传递的“消息”（Message对象）是服务在其Handler中接收的。</p>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>注意，绑定解绑服务最好在onstart和onStop内，在activity的生命周期里，onStart和onStop是activity在栈顶与否的出口和入口，我们的服务一般是绑定当前activity，顾在这两个位置比较合适。</p>
<p>另外，如果需要服务端能够回应客户端，就和服务端一样，我们还需要创建一个Handler并创建一个新的Messenger，并把这个Messenger对象通过Message的replyTo参数传递给服务端，服务端通过这个replyTo参数就可以回应客户端。</p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 nathanwriting@126.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>


<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>面试问题集锦</p>
    <p><span class="copy-title">字数:</span><span class="post-count">22.7k</span></p>
    <p><span class="copy-title">本文作者:</span><a  title="Nathaniel">Nathaniel</a></p>
    <p><span class="copy-title">发布时间:</span>2021-03-29, 14:01:47</p>
    <p><span class="copy-title">最后更新:</span>2023-11-06, 22:59:18</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2021/03/29/android-interview-addition/" title="面试问题集锦">http://example.com/2021/03/29/android-interview-addition/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">&#34;署名-非商用-相同方式共享 4.0&#34;</a> 转载请保留原文链接及作者。
    </p>
</div>





    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2023 Nathaniel
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
