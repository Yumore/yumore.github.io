<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Framework知识点汇总 | Nathaniel</title>
  <meta name="keywords" content=" Android ">
  <meta name="description" content="Framework知识点汇总 | Nathaniel">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="WeChat加我微信 QQ448216285  EmailContact me 开不开心 意不意外 惊不惊喜 啪叽没了">
<meta property="og:type" content="website">
<meta property="og:title" content="关于我">
<meta property="og:url" content="http://example.com/about/index.html">
<meta property="og:site_name" content="Nathaniel">
<meta property="og:description" content="WeChat加我微信 QQ448216285  EmailContact me 开不开心 意不意外 惊不惊喜 啪叽没了">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/about.png">
<meta property="article:published_time" content="2020-12-21T09:21:33.000Z">
<meta property="article:modified_time" content="2023-11-06T14:59:19.000Z">
<meta property="article:author" content="Nathaniel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/about.png">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.0.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>Nathaniel</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/yelog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="facebook"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-facebook"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
            <a title="instagram"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-instagram"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="reddit"
               href="https://www.reddit.com/user/yelog/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-reddit"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="weibo"
               href="http://weibo.com/u/2307534817"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-weibo"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="jianshu"
               href="https://www.jianshu.com/u/ff56736de7cf"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-jianshu"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/people/jaytp/activities"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="oschina"
               href="https://my.oschina.net/yelog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-oschina"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="email"
               href="mailto:jaytp@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=872336115&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="kugou"
               href="https://www.kugou.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-kugou"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="neteasemusic"
               href="https://music.163.com/#/user/home?id=88151013"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-neteasemusic"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(41)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="工具">
            
            工具
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="测试">
            
            测试
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="开发规范">
            
            开发规范
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="软技能">
            
            软技能
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Android">
            
            Android
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="blog">
            
            blog
            <small>(33)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Interview">
            
            Interview
            <small>(3)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="41">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>测试</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>架构</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>开发规范</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>面试</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>软技能</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>运维</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>android</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Android</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>AndroidStudio</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>APP</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>CentOS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>dart</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>FFmpeg</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Flutter</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>git</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Git</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>gRPC</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>hexo</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Keep Live</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Kotlin</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Linux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>MacOS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>MariaDB</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Markdown</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>mvx</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>nodejs</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Optimistic</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Powershell</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Problem</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Q-A</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Raspbian</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Shell</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Ubuntu</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>View</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a id="top" class="全部文章 Interview "
           href="/2021/03/29/android-interview-addition/"
           data-tag="Android,面试"
           data-author="" >
            <span class="post-title" title="面试问题集锦">面试问题集锦</span>
            <span class="post-date" title="2021-03-29 14:01:47">2021/03/29</span>
        </a>
        
        
        <a id="top" class="全部文章 blog "
           href="/2021/03/01/kotlin-notes/"
           data-tag="Android,Kotlin"
           data-author="" >
            <span class="post-title" title="Kotlin学习笔记">Kotlin学习笔记</span>
            <span class="post-date" title="2021-03-01 10:28:59">2021/03/01</span>
        </a>
        
        
        <a id="top" class="全部文章 软技能 "
           href="/2021/02/22/keep-your-mind/"
           data-tag="软技能"
           data-author="" >
            <span class="post-title" title="灵魂之力—自控力的强大威力">灵魂之力—自控力的强大威力</span>
            <span class="post-date" title="2021-02-22 10:43:00">2021/02/22</span>
        </a>
        
        
        <a id="top" class="全部文章 Interview "
           href="/2021/01/27/android-interview/"
           data-tag="Android,面试"
           data-author="" >
            <span class="post-title" title="Android高级面试题">Android高级面试题</span>
            <span class="post-date" title="2021-01-27 16:01:47">2021/01/27</span>
        </a>
        
        
        <a id="top" class="全部文章 Interview "
           href="/2021/04/18/android-knowledge/"
           data-tag="Android,面试"
           data-author="" >
            <span class="post-title" title="Android知识点汇总">Android知识点汇总</span>
            <span class="post-date" title="2021-04-18 16:01:47">2021/04/18</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/20222/09/18/powershell-ohmyzsh/"
           data-tag="Powershell"
           data-author="" >
            <span class="post-title" title="Powershell美化">Powershell美化</span>
            <span class="post-date" title="20222-09-18 16:52:00">20222/09/18</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2022/11/20/flutter-interview/"
           data-tag="Android,Flutter"
           data-author="" >
            <span class="post-title" title="Flutter 学习笔记">Flutter 学习笔记</span>
            <span class="post-date" title="2022-11-20 15:28:59">2022/11/20</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2022/10/05/git-config/"
           data-tag="git"
           data-author="" >
            <span class="post-title" title="git_config">git_config</span>
            <span class="post-date" title="2022-10-05 07:15:36">2022/10/05</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2022/09/28/Ubuntu-Using/"
           data-tag="Ubuntu"
           data-author="" >
            <span class="post-title" title="Ubuntu日常使用">Ubuntu日常使用</span>
            <span class="post-date" title="2022-09-28 13:10:27">2022/09/28</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/Android%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86%E7%82%B9/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Android扩展知识点">Android扩展知识点</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/C++%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="C++知识点汇总">C++知识点汇总</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/Android%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Android知识点汇总">Android知识点汇总</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/Gradle%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Gradle知识点汇总">Gradle知识点汇总</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Java知识点汇总">Java知识点汇总</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/Kotlin%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Kotlin知识点汇总">Kotlin知识点汇总</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/Android%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="开源源码库分析">开源源码库分析</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/android-view/"
           data-tag="Android,View"
           data-author="" >
            <span class="post-title" title="View绘制流程">View绘制流程</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/Framework%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Framework知识点汇总">Framework知识点汇总</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="网络知识汇总">网络知识汇总</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B1%87%E6%80%BB/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="常见设计模式汇总">常见设计模式汇总</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98%E6%B1%87%E6%80%BB/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="常见算法汇总">常见算法汇总</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="性能优化知识点汇总">性能优化知识点汇总</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/14/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="音视频知识点汇总">音视频知识点汇总</span>
            <span class="post-date" title="2021-04-14 16:01:47">2021/04/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/04/08/android-problem-collection/"
           data-tag="Android,Problem,Q-A"
           data-author="" >
            <span class="post-title" title="Android问题集锦">Android问题集锦</span>
            <span class="post-date" title="2021-04-08 11:04:47">2021/04/08</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/03/19/android-optimization/"
           data-tag="Android,Optimistic"
           data-author="" >
            <span class="post-title" title="Android性能优化">Android性能优化</span>
            <span class="post-date" title="2021-03-19 11:04:47">2021/03/19</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/03/08/update-git-shell-v2/"
           data-tag="Shell,运维"
           data-author="" >
            <span class="post-title" title="shell 批量更新多个git仓库 v2">shell 批量更新多个git仓库 v2</span>
            <span class="post-date" title="2021-03-08 10:29:37">2021/03/08</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/02/24/fragment-data-activity/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Fragment和Activity通信">Fragment和Activity通信</span>
            <span class="post-date" title="2021-02-24 11:40:28">2021/02/24</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2021/02/14/update-git-shell/"
           data-tag="Shell,Git"
           data-author="" >
            <span class="post-title" title="shell 批量更新多个git仓库">shell 批量更新多个git仓库</span>
            <span class="post-date" title="2021-02-14 12:26:56">2021/02/14</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2020/11/20/ffmpeg-build/"
           data-tag="Android,FFmpeg,MacOS"
           data-author="" >
            <span class="post-title" title="MacOS下基于NDK编译FFmpeg">MacOS下基于NDK编译FFmpeg</span>
            <span class="post-date" title="2020-11-20 15:28:59">2020/11/20</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2020/11/19/android-mvx/"
           data-tag="android,mvx"
           data-author="" >
            <span class="post-title" title="Android-UI架构演进">Android-UI架构演进</span>
            <span class="post-date" title="2020-11-19 15:28:59">2020/11/19</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2020/11/19/dart-gRPC/"
           data-tag="dart,gRPC"
           data-author="" >
            <span class="post-title" title="Dart-gPRC">Dart-gPRC</span>
            <span class="post-date" title="2020-11-19 15:28:59">2020/11/19</span>
        </a>
        
        
        <a  class="全部文章 工具 "
           href="/2020/10/19/android-studio/"
           data-tag="AndroidStudio"
           data-author="" >
            <span class="post-title" title="Android Studio 使用问题">Android Studio 使用问题</span>
            <span class="post-date" title="2020-10-19 16:01:47">2020/10/19</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2020/10/19/hexo-for-node/"
           data-tag="hexo,nodejs"
           data-author="" >
            <span class="post-title" title="Node环境下Hexo的搭建">Node环境下Hexo的搭建</span>
            <span class="post-date" title="2020-10-19 15:28:59">2020/10/19</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2020/09/19/keep-app-alive/"
           data-tag="Android,Keep Live"
           data-author="" >
            <span class="post-title" title="Android保活技术实现">Android保活技术实现</span>
            <span class="post-date" title="2020-09-19 15:28:59">2020/09/19</span>
        </a>
        
        
        <a  class="全部文章 测试 "
           href="/2020/08/29/app-test-helper/"
           data-tag="APP,测试"
           data-author="" >
            <span class="post-title" title="手机APP测试">手机APP测试</span>
            <span class="post-date" title="2020-08-29 16:01:47">2020/08/29</span>
        </a>
        
        
        <a  class="全部文章 Android "
           href="/2020/08/28/android-architecture/"
           data-tag="Android,架构"
           data-author="" >
            <span class="post-title" title="Android 架构技术演进">Android 架构技术演进</span>
            <span class="post-date" title="2020-08-28 14:01:47">2020/08/28</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2020/08/19/kotlin-learning/"
           data-tag="Android,Kotlin"
           data-author="" >
            <span class="post-title" title="Kotlin笔记">Kotlin笔记</span>
            <span class="post-date" title="2020-08-19 15:28:59">2020/08/19</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2020/07/19/MariaDB-on-CentOS/"
           data-tag="CentOS,MariaDB"
           data-author="" >
            <span class="post-title" title="在CentOS7中安装MariaDB">在CentOS7中安装MariaDB</span>
            <span class="post-date" title="2020-07-19 15:28:59">2020/07/19</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2020/05/19/markdown-note/"
           data-tag="Markdown"
           data-author="" >
            <span class="post-title" title="Markdown编辑器语法指南">Markdown编辑器语法指南</span>
            <span class="post-date" title="2020-05-19 15:28:59">2020/05/19</span>
        </a>
        
        
        <a  class="全部文章 blog "
           href="/2020/03/27/using-raspberry/"
           data-tag="Linux,Raspbian"
           data-author="" >
            <span class="post-title" title="树莓派的使用笔记">树莓派的使用笔记</span>
            <span class="post-date" title="2020-03-27 00:16:31">2020/03/27</span>
        </a>
        
        
        <a  class="全部文章 开发规范 "
           href="/2019/05/01/constraint-for-android/"
           data-tag="Android,开发规范"
           data-author="" >
            <span class="post-title" title="关于Android的开发规范">关于Android的开发规范</span>
            <span class="post-date" title="2019-05-01 15:29:59">2019/05/01</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-Framework知识点汇总" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Framework知识点汇总</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="blog">blog</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color3">Android</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2023-11-06 22:59:18'>2021-04-14 16:01</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Handler"><span class="toc-text">Handler</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Handler%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E4%B8%80-%E5%AE%8F%E8%A7%82%E7%90%86%E8%AE%BA%E5%88%86%E6%9E%90%E4%B8%8EMessage%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">Handler机制实现原理(一)宏观理论分析与Message源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Message"><span class="toc-text">Message:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9C%8B%E4%B8%80%E4%B8%8B%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%EF%BC%9A%E6%9C%89%E5%A5%BD%E5%A4%9A%E5%AD%98%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%B9%E8%B1%A1%E3%80%82"><span class="toc-text">看一下全局变量：有好多存数据的对象。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Obtain%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">Obtain方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#recycle-%E5%9B%9E%E6%94%B6%E5%BD%93%E5%89%8Dmessage%E5%88%B0%E5%85%A8%E5%B1%80%E6%B1%A0"><span class="toc-text">recycle():回收当前message到全局池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setData%EF%BC%9A"><span class="toc-text">setData：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">发送消息的一些方法：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">构造方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#writeToParcel%EF%BC%9A"><span class="toc-text">writeToParcel：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Handler%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89MessageQueue%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">Handler机制实现原理（二）MessageQueue的源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86"><span class="toc-text">消息队列存储原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8JNI%E5%AE%9E%E7%8E%B0%E7%9A%84native%E6%96%B9%E6%B3%95"><span class="toc-text">使用JNI实现的native方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%94%80%E6%AF%81"><span class="toc-text">创建与销毁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%85%A5%E9%98%9F%E7%AE%A1%E7%90%86enqueueMessage-%E6%96%B9%E6%B3%95"><span class="toc-text">消息入队管理enqueueMessage()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%B6%88%E6%81%AF%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-text">同步消息拦截器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%A9%BA%E9%97%B2%E5%A4%84%E7%90%86%E5%99%A8IdleHandler"><span class="toc-text">队列空闲处理器IdleHandler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%87%BA%E9%98%9F%E7%AE%A1%E7%90%86next-%E6%96%B9%E6%B3%95"><span class="toc-text">消息出队管理next()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Handler%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89Looper%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">Handler机制实现原理（三）Looper的源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%80%80%E5%87%BALooper"><span class="toc-text">创建与退出Looper</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8CLooper%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF"><span class="toc-text">运行Looper处理消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Handler%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89handler%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">Handler机制实现原理（四）handler的源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-text">发送消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF"><span class="toc-text">接收消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8F%AF%E8%83%BD"><span class="toc-text">内存泄漏的可能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Handler%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%94%EF%BC%89%E6%80%BB%E7%BB%93"><span class="toc-text">Handler机制实现原理（五）总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Message%E7%BC%93%E5%AD%98%E6%B1%A0"><span class="toc-text">Message缓存池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%9F%E6%AD%A3%E7%9A%84%E9%98%BB%E5%A1%9E%E5%8F%91%E7%94%9F%E5%9C%A8MessageQueue"><span class="toc-text">真正的阻塞发生在MessageQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8Handler%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">为什么推荐使用Handler实现线程间通信</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Binder"><span class="toc-text">Binder</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Binder%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%E5%AD%A6%E4%B9%A0Binder%E5%89%8D%E5%BF%85%E9%A1%BB%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-text">Binder原理（一）学习Binder前必须要了解的知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E5%92%8CAndroid%E7%9A%84IPC%E6%9C%BA%E5%88%B6%E7%A7%8D%E7%B1%BB"><span class="toc-text">Linux和Android的IPC机制种类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E4%B8%AD%E7%9A%84IPC%E6%9C%BA%E5%88%B6%E7%A7%8D%E7%B1%BB"><span class="toc-text">Linux中的IPC机制种类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android%E4%B8%AD%E7%9A%84IPC%E6%9C%BA%E5%88%B6"><span class="toc-text">Android中的IPC机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E5%92%8CBinder%E7%9A%84IPC%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="toc-text">Linux和Binder的IPC通信原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E7%9A%84IPC%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="toc-text">Linux的IPC通信原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Binder%E7%9A%84%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="toc-text">Binder的通信原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Binder"><span class="toc-text">为什么要使用Binder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0Binder"><span class="toc-text">为什么要学习Binder?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binder%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89ServiceManager%E4%B8%AD%E7%9A%84Binder%E6%9C%BA%E5%88%B6"><span class="toc-text">Binder原理（二）ServiceManager中的Binder机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EBinder%E9%80%9A%E4%BF%A1%E7%9A%84C-S%E6%9E%B6%E6%9E%84"><span class="toc-text">基于Binder通信的C&#x2F;S架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MediaServer%E7%9A%84main%E5%87%BD%E6%95%B0"><span class="toc-text">MediaServer的main函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%8F%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%94%AF%E4%B8%80%E7%9A%84ProcessState"><span class="toc-text">每个进程唯一的ProcessState</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ServiceManager%E4%B8%AD%E7%9A%84Binder%E6%9C%BA%E5%88%B6"><span class="toc-text">ServiceManager中的Binder机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BpBinder%E5%92%8CBBinder"><span class="toc-text">BpBinder和BBinder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%AF%86IServiceManager"><span class="toc-text">解密IServiceManager</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IServiceManager%E5%AE%B6%E6%97%8F"><span class="toc-text">IServiceManager家族</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binder%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">Binder原理（三）系统服务的注册过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E8%B0%83%E7%94%A8%E9%93%BE%E8%A7%92%E5%BA%A6%E8%AF%B4%E6%98%8EMediaPlayerService%E6%98%AF%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E7%9A%84"><span class="toc-text">从调用链角度说明MediaPlayerService是如何注册的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#writeTransactionData%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="toc-text">writeTransactionData函数分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#waitForResponse%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="toc-text">waitForResponse函数分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E8%BF%9B%E7%A8%8B%E8%A7%92%E5%BA%A6%E8%AF%B4%E6%98%8EMediaPlayerService%E6%98%AF%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E7%9A%84"><span class="toc-text">从进程角度说明MediaPlayerService是如何注册的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binder%E5%8E%9F%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89ServiceManager%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">Binder原理（四）ServiceManager的启动过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ServiceManager%E7%9A%84%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-text">ServiceManager的入口函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%BC%80binder%E8%AE%BE%E5%A4%87"><span class="toc-text">打开binder设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E6%88%90%E4%B8%BABinder%E6%9C%BA%E5%88%B6%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E8%80%85"><span class="toc-text">注册成为Binder机制的上下文管理者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%E5%92%8C%E5%A4%84%E7%90%86client%E7%AB%AF%E5%8F%91%E6%9D%A5%E7%9A%84%E8%AF%B7%E6%B1%82"><span class="toc-text">循环等待和处理client端发来的请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binder%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%94%EF%BC%89%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%8E%B7%E5%8F%96%E8%BF%87%E7%A8%8B"><span class="toc-text">Binder原理（五）系统服务的获取过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AFMediaPlayerService%E8%AF%B7%E6%B1%82%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1"><span class="toc-text">客户端MediaPlayerService请求获取服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AFServiceManager%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82"><span class="toc-text">服务端ServiceManager处理请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binder%E5%8E%9F%E7%90%86%EF%BC%88%E5%85%AD%EF%BC%89Java-Binder%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">Binder原理（六）Java Binder的初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-Binder%E7%9A%84JNI%E6%B3%A8%E5%86%8C"><span class="toc-text">Java Binder的JNI注册</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Binder%E7%B1%BB%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="toc-text">Binder类的注册</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BinderInternal%E7%B1%BB%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="toc-text">BinderInternal类的注册</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binder%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%83%EF%BC%89Java-Binder%E4%B8%AD%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">Binder原理（七）Java Binder中系统服务的注册过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86AMS%E6%B3%A8%E5%86%8C%E5%88%B0ServiceManager"><span class="toc-text">将AMS注册到ServiceManager</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BinderInternal-getContextObject"><span class="toc-text">BinderInternal.getContextObject()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ServiceManagerNative-asInterface"><span class="toc-text">ServiceManagerNative.asInterface()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getIServiceManager-addService"><span class="toc-text">getIServiceManager().addService()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%87%BAJavaBBinder"><span class="toc-text">引出JavaBBinder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90JavaBBinder"><span class="toc-text">解析JavaBBinder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-Binder%E6%9E%B6%E6%9E%84"><span class="toc-text">Java Binder架构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Zygote"><span class="toc-text">Zygote</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Zygote-%E4%B8%80-%EF%BC%9AAndroid%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%8F%8AZygote%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">Zygote(一)：Android系统的启动过程及Zygote的启动过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#init%E8%BF%9B%E7%A8%8B"><span class="toc-text">init进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%9C%8D%E5%8A%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%90%AF%E5%8A%A8"><span class="toc-text">属性服务初始化与启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86"><span class="toc-text">设置进程信号处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90init%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">解析init配置文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Zygote%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8"><span class="toc-text">Zygote进程启动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SystemServer%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">SystemServer启动过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zygote%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">Zygote（二）：应用进程的启动过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Zygote%E7%9B%91%E5%90%AC%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82"><span class="toc-text">Zygote监听客户端请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AMS%E5%8F%91%E9%80%81%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E8%AF%B7%E6%B1%82"><span class="toc-text">AMS发送创建进程请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Zygote%E6%8E%A5%E6%94%B6%E4%BF%A1%E6%81%AF%E5%B9%B6%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="toc-text">Zygote接收信息并创建进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8Binder%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">启动Binder线程池</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AMS"><span class="toc-text">AMS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AMS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%80-Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="toc-text">AMS源码分析(一)Activity生命周期管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">Activity的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AAActivity%E4%BB%8E%E5%90%AF%E5%8A%A8%E5%88%B0%E9%94%80%E6%AF%81%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E5%91%A8%E6%9C%9F"><span class="toc-text">一个Activity从启动到销毁所经历的周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E4%B8%80%E4%B8%AAActivity%E5%90%AF%E5%8A%A8%E5%8F%A6%E4%B8%80%E4%B8%AAActivity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">从一个Activity启动另一个Activity的生命周期</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Binder-1"><span class="toc-text">Binder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IdleHandler"><span class="toc-text">IdleHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Activity%E5%9C%A8AMS%E4%B8%AD%E7%9A%84%E6%A0%87%E8%AF%86"><span class="toc-text">Activity在AMS中的标识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%97%B6%E5%BA%8F%E5%9B%BE"><span class="toc-text">启动过程时序图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8EAActivity%E8%B7%B3%E8%BD%ACBActivity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%88%86%E6%9E%90"><span class="toc-text">从AActivity跳转BActivity的生命周期分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#AActivity-onPause"><span class="toc-text">AActivity#onPause</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BActivity-onCreate"><span class="toc-text">BActivity#onCreate</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BActivity-onStart"><span class="toc-text">BActivity#onStart</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BActivity-onResume"><span class="toc-text">BActivity#onResume</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AActivity-onStop"><span class="toc-text">AActivity#onStop</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8EBActivity%E8%BF%94%E5%9B%9E%E5%88%B0AActivity"><span class="toc-text">从BActivity返回到AActivity</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BActivity-onPause"><span class="toc-text">BActivity#onPause</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AActivity-onStart%E3%80%81AActivity-onResume"><span class="toc-text">AActivity#onStart、AActivity#onResume</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BActivity-onStop%E3%80%81BActivity-onDestroy"><span class="toc-text">BActivity#onStop、BActivity#onDestroy</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AMS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C-onActivityResult%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">AMS源码分析(二)onActivityResult执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#onActivityResult"><span class="toc-text">onActivityResult</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AActivity%E8%B7%B3%E8%BD%ACBAcitivty%E5%B9%B6%E4%BB%8EBActivity%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE"><span class="toc-text">AActivity跳转BAcitivty并从BActivity返回数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Intent-FLAG-ACTIVITY-FORWARD-RESULT"><span class="toc-text">Intent.FLAG_ACTIVITY_FORWARD_RESULT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">示例：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#AActivity%E4%BB%A5startActivityForResult%E6%96%B9%E5%BC%8F%E6%89%93%E5%BC%80BActivity"><span class="toc-text">AActivity以startActivityForResult方式打开BActivity</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BActivity%E4%BB%A5%E6%99%AE%E9%80%9A%E6%96%B9%E5%BC%8F%E6%89%93%E5%BC%80CActivity%EF%BC%8C%E8%AE%BE%E7%BD%AEIntent-%E7%9A%84Flag-Intent-FLAG-ACTIVITY-FORWARD-RESULT"><span class="toc-text">BActivity以普通方式打开CActivity，设置Intent 的Flag Intent.FLAG_ACTIVITY_FORWARD_RESULT</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ActivityResult%E6%95%B0%E6%8D%AE%E7%9A%84%E5%86%99%E5%85%A5"><span class="toc-text">ActivityResult数据的写入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ActivityResult%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-text">ActivityResult数据的传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Intent-FLAG-ACTIVITY-FORWARD-RESULT%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">Intent.FLAG_ACTIVITY_FORWARD_RESULT的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AMS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%89-AMS%E4%B8%ADActivity%E6%A0%88%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3"><span class="toc-text">AMS源码分析(三)AMS中Activity栈管理详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Activity%E6%A0%88%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3%E7%B1%BB"><span class="toc-text">Activity栈管理相关类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ActivityStackSupervisor"><span class="toc-text">ActivityStackSupervisor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ActivityDisplay"><span class="toc-text">ActivityDisplay</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TaskRecord"><span class="toc-text">TaskRecord</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ActivityStack"><span class="toc-text">ActivityStack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E5%9B%BE%EF%BC%9A"><span class="toc-text">关系图：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">启动模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#standard"><span class="toc-text">standard</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Intent-FLAG-ACTIVITY-CLEAR-TOP"><span class="toc-text">Intent.FLAG_ACTIVITY_CLEAR_TOP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1"><span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8A%A0%E5%85%A5TaskRecord"><span class="toc-text">加入TaskRecord</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#standard-Intent-FLAG-ACTIVITY-CLEAR-TOP"><span class="toc-text">standard + Intent.FLAG_ACTIVITY_CLEAR_TOP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#singleTop"><span class="toc-text">singleTop</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE%EF%BC%9A"><span class="toc-text">流程图：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8E%9FActivity%E4%B8%8D%E5%9C%A8%E6%A0%88%E9%A1%B6"><span class="toc-text">原Activity不在栈顶</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8E%9FActivity%E5%9C%A8%E6%A0%88%E9%A1%B6"><span class="toc-text">原Activity在栈顶</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#singleTop-Intent-FLAG-ACTIVITY-CLEAR-TOP"><span class="toc-text">singleTop + Intent.FLAG_ACTIVITY_CLEAR_TOP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#log"><span class="toc-text">log</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8E%9FActivity%E4%B8%8D%E5%9C%A8%E6%A0%88%E9%A1%B6-1"><span class="toc-text">原Activity不在栈顶</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8E%9FActivity%E5%9C%A8%E6%A0%88%E9%A1%B6-1"><span class="toc-text">原Activity在栈顶</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8E%9FActiivty%E5%9C%A8%E6%A0%88%E9%A1%B6%E4%B8%94%E8%AE%BE%E7%BD%AEIntent-FLAG-ACTIVITY-CLEAR-TOP"><span class="toc-text">原Actiivty在栈顶且设置Intent.FLAG_ACTIVITY_CLEAR_TOP</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-2"><span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#singleTop-Intent-FLAG-ACTIVITY-CLEAR-TOP-1"><span class="toc-text">singleTop + Intent.FLAG_ACTIVITY_CLEAR_TOP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#singleTask"><span class="toc-text">singleTask</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%80"><span class="toc-text">场景一</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%BA%8C"><span class="toc-text">场景二</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%89"><span class="toc-text">场景三</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#singeTask%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">singeTask源码分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#singleInstance"><span class="toc-text">singleInstance</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Intent-FLAG-ACTIVITY-NEW-TASK%E3%80%81taskAffinity%E3%80%81%E6%96%B0Task%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">Intent.FLAG_ACTIVITY_NEW_TASK、taskAffinity、新Task的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Intent-FLAG-ACTIVITY-NEW-TASK%E7%9A%84%E8%87%AA%E5%8A%A8%E8%AE%BE%E7%BD%AE"><span class="toc-text">Intent.FLAG_ACTIVITY_NEW_TASK的自动设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#taskAffinity%E7%9A%84%E8%AF%86%E5%88%AB"><span class="toc-text">taskAffinity的识别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E5%88%9B%E5%BB%BA%E6%96%B0task%E7%9A%84%E8%AF%86%E5%88%AB"><span class="toc-text">是否创建新task的识别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PMS"><span class="toc-text">PMS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5PMS%E6%BA%90%E7%A0%81%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94-PMS%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">深入PMS源码（一）—— PMS的启动过程和执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PMS%E7%AE%80%E4%BB%8B"><span class="toc-text">PMS简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PMS%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">PMS的启动过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PMS%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">PMS构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PMS%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-text">PMS的工作过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6package-xml"><span class="toc-text">解析配置文件package.xml</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E5%AE%89%E8%A3%85%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-text">扫描安装的应用程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86apk%E8%A7%A3%E6%9E%90%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%88%B0PMS%E7%9A%84%E5%B1%9E%E6%80%A7%E4%B8%AD"><span class="toc-text">将apk解析数据同步到PMS的属性中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">更新配置文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5PMS%E6%BA%90%E7%A0%81%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94-APK%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">深入PMS源码（二）—— APK的安装和卸载源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85%E5%9F%BA%E7%A1%80"><span class="toc-text">应用程序安装基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PMS%E4%B8%ADAPK%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B"><span class="toc-text">PMS中APK安装过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8D%B8%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-text">应用程序的卸载过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5PMS%E6%BA%90%E7%A0%81%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-PMS%E4%B8%ADintent-filter%E7%9A%84%E5%8C%B9%E9%85%8D%E6%9E%B6%E6%9E%84"><span class="toc-text">深入PMS源码（三）—— PMS中intent-filter的匹配架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PMS%E4%BF%9D%E5%AD%98IntentFilter"><span class="toc-text">PMS保存IntentFilter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IntentFilter%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8C%B9%E9%85%8D"><span class="toc-text">IntentFilter的查找匹配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#WMS"><span class="toc-text">WMS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#WMS%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AWMS%E7%9A%84%E8%AF%9E%E7%94%9F"><span class="toc-text">WMS（一）：WMS的诞生</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WMS%E6%A6%82%E8%BF%B0"><span class="toc-text">WMS概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86"><span class="toc-text">窗口管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%8A%A8%E7%94%BB"><span class="toc-text">窗口动画</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%AD%E8%BD%AC%E7%AB%99"><span class="toc-text">输入系统的中转站</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Surface%E7%AE%A1%E7%90%86"><span class="toc-text">Surface管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WMS%E7%9A%84%E8%AF%9E%E7%94%9F"><span class="toc-text">WMS的诞生</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WMS%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AWMS%E7%9A%84%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%92%8CWindow%E7%9A%84%E6%B7%BB%E5%8A%A0%E8%BF%87%E7%A8%8B"><span class="toc-text">WMS（二）：WMS的重要成员和Window的添加过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WMS%E7%9A%84%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98"><span class="toc-text">WMS的重要成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Window%E7%9A%84%E6%B7%BB%E5%8A%A0%E8%BF%87%E7%A8%8B%EF%BC%88WMS%E9%83%A8%E5%88%86%EF%BC%89"><span class="toc-text">Window的添加过程（WMS部分）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#addWindow%E6%96%B9%E6%B3%95part1"><span class="toc-text">addWindow方法part1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#addWindow%E6%96%B9%E6%B3%95part2"><span class="toc-text">addWindow方法part2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#addWindow%E6%96%B9%E6%B3%95part3"><span class="toc-text">addWindow方法part3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#addWindow%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-text">addWindow方法总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-text">结语</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WMS%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AWindow%E7%9A%84%E5%88%A0%E9%99%A4%E8%BF%87%E7%A8%8B"><span class="toc-text">WMS（三）：Window的删除过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Window%E7%9A%84%E5%88%A0%E9%99%A4%E8%BF%87%E7%A8%8B"><span class="toc-text">Window的删除过程</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#handler">Handler</a><ul>
<li><a href="#handler%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%80%E5%AE%8F%E8%A7%82%E7%90%86%E8%AE%BA%E5%88%86%E6%9E%90%E4%B8%8Emessage%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Handler机制实现原理(一)宏观理论分析与Message源码分析</a><ul>
<li><a href="#message">Message:</a><ul>
<li><a href="#%E7%9C%8B%E4%B8%80%E4%B8%8B%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E6%9C%89%E5%A5%BD%E5%A4%9A%E5%AD%98%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%B9%E8%B1%A1">看一下全局变量：有好多存数据的对象。</a></li>
<li><a href="#obtain%E6%96%B9%E6%B3%95">Obtain方法：</a></li>
<li><a href="#recycle%E5%9B%9E%E6%94%B6%E5%BD%93%E5%89%8Dmessage%E5%88%B0%E5%85%A8%E5%B1%80%E6%B1%A0">recycle():回收当前message到全局池</a></li>
</ul>
</li>
<li><a href="#setdata">setData：</a></li>
<li><a href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95">发送消息的一些方法：</a><ul>
<li><a href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">构造方法：</a></li>
<li><a href="#writetoparcel">writeToParcel：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#handler%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BA%8Cmessagequeue%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Handler机制实现原理（二）MessageQueue的源码分析</a><ul>
<li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86">消息队列存储原理</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8jni%E5%AE%9E%E7%8E%B0%E7%9A%84native%E6%96%B9%E6%B3%95">使用JNI实现的native方法</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%94%80%E6%AF%81">创建与销毁</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E5%85%A5%E9%98%9F%E7%AE%A1%E7%90%86enqueuemessage%E6%96%B9%E6%B3%95">消息入队管理enqueueMessage()方法</a></li>
<li><a href="#%E5%90%8C%E6%AD%A5%E6%B6%88%E6%81%AF%E6%8B%A6%E6%88%AA%E5%99%A8">同步消息拦截器</a></li>
<li><a href="#%E9%98%9F%E5%88%97%E7%A9%BA%E9%97%B2%E5%A4%84%E7%90%86%E5%99%A8idlehandler">队列空闲处理器IdleHandler</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E5%87%BA%E9%98%9F%E7%AE%A1%E7%90%86next%E6%96%B9%E6%B3%95">消息出队管理next()方法</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
<li><a href="#handler%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%89looper%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Handler机制实现原理（三）Looper的源码分析</a><ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%80%80%E5%87%BAlooper">创建与退出Looper</a></li>
<li><a href="#%E8%BF%90%E8%A1%8Clooper%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF">运行Looper处理消息</a></li>
<li><a href="#%E6%80%BB%E7%BB%93-1">总结</a></li>
</ul>
</li>
<li><a href="#handler%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%9B%9Bhandler%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Handler机制实现原理（四）handler的源码分析</a><ul>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a></li>
<li><a href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF">发送消息</a></li>
<li><a href="#%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF">接收消息</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8F%AF%E8%83%BD">内存泄漏的可能</a></li>
</ul>
</li>
<li><a href="#handler%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BA%94%E6%80%BB%E7%BB%93">Handler机制实现原理（五）总结</a><ul>
<li><a href="#message%E7%BC%93%E5%AD%98%E6%B1%A0">Message缓存池</a></li>
<li><a href="#%E7%9C%9F%E6%AD%A3%E7%9A%84%E9%98%BB%E5%A1%9E%E5%8F%91%E7%94%9F%E5%9C%A8messagequeue">真正的阻塞发生在MessageQueue</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8handler%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1">为什么推荐使用Handler实现线程间通信</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#binder">Binder</a><ul>
<li><a href="#binder%E5%8E%9F%E7%90%86%E4%B8%80%E5%AD%A6%E4%B9%A0binder%E5%89%8D%E5%BF%85%E9%A1%BB%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9">Binder原理（一）学习Binder前必须要了解的知识点</a><ul>
<li><a href="#linux%E5%92%8Candroid%E7%9A%84ipc%E6%9C%BA%E5%88%B6%E7%A7%8D%E7%B1%BB">Linux和Android的IPC机制种类</a><ul>
<li><a href="#linux%E4%B8%AD%E7%9A%84ipc%E6%9C%BA%E5%88%B6%E7%A7%8D%E7%B1%BB">Linux中的IPC机制种类</a></li>
<li><a href="#android%E4%B8%AD%E7%9A%84ipc%E6%9C%BA%E5%88%B6">Android中的IPC机制</a></li>
</ul>
</li>
<li><a href="#linux%E5%92%8Cbinder%E7%9A%84ipc%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86">Linux和Binder的IPC通信原理</a><ul>
<li><a href="#linux%E7%9A%84ipc%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86">Linux的IPC通信原理</a></li>
<li><a href="#binder%E7%9A%84%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86">Binder的通信原理</a></li>
</ul>
</li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8binder">为什么要使用Binder</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0binder">为什么要学习Binder?</a></li>
</ul>
</li>
<li><a href="#binder%E5%8E%9F%E7%90%86%E4%BA%8Cservicemanager%E4%B8%AD%E7%9A%84binder%E6%9C%BA%E5%88%B6">Binder原理（二）ServiceManager中的Binder机制</a><ul>
<li><a href="#%E5%9F%BA%E4%BA%8Ebinder%E9%80%9A%E4%BF%A1%E7%9A%84cs%E6%9E%B6%E6%9E%84">基于Binder通信的C&#x2F;S架构</a></li>
<li><a href="#mediaserver%E7%9A%84main%E5%87%BD%E6%95%B0">MediaServer的main函数</a></li>
<li><a href="#%E6%AF%8F%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%94%AF%E4%B8%80%E7%9A%84processstate">每个进程唯一的ProcessState</a></li>
<li><a href="#servicemanager%E4%B8%AD%E7%9A%84binder%E6%9C%BA%E5%88%B6">ServiceManager中的Binder机制</a><ul>
<li><a href="#bpbinder%E5%92%8Cbbinder">BpBinder和BBinder</a></li>
<li><a href="#%E8%A7%A3%E5%AF%86iservicemanager">解密IServiceManager</a></li>
<li><a href="#iservicemanager%E5%AE%B6%E6%97%8F">IServiceManager家族</a></li>
</ul>
</li>
<li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li>
</ul>
</li>
<li><a href="#binder%E5%8E%9F%E7%90%86%E4%B8%89%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B">Binder原理（三）系统服务的注册过程</a><ul>
<li><a href="#%E4%BB%8E%E8%B0%83%E7%94%A8%E9%93%BE%E8%A7%92%E5%BA%A6%E8%AF%B4%E6%98%8Emediaplayerservice%E6%98%AF%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E7%9A%84">从调用链角度说明MediaPlayerService是如何注册的</a><ul>
<li><a href="#writetransactiondata%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90">writeTransactionData函数分析</a></li>
<li><a href="#waitforresponse%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90">waitForResponse函数分析</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-1">小结</a></li>
</ul>
</li>
<li><a href="#%E4%BB%8E%E8%BF%9B%E7%A8%8B%E8%A7%92%E5%BA%A6%E8%AF%B4%E6%98%8Emediaplayerservice%E6%98%AF%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E7%9A%84">从进程角度说明MediaPlayerService是如何注册的</a></li>
<li><a href="#%E6%80%BB%E7%BB%93-2">总结</a></li>
</ul>
</li>
<li><a href="#binder%E5%8E%9F%E7%90%86%E5%9B%9Bservicemanager%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B">Binder原理（四）ServiceManager的启动过程</a><ul>
<li><a href="#servicemanager%E7%9A%84%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0">ServiceManager的入口函数</a><ul>
<li><a href="#%E6%89%93%E5%BC%80binder%E8%AE%BE%E5%A4%87">打开binder设备</a></li>
<li><a href="#%E6%B3%A8%E5%86%8C%E6%88%90%E4%B8%BAbinder%E6%9C%BA%E5%88%B6%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E8%80%85">注册成为Binder机制的上下文管理者</a></li>
<li><a href="#%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%E5%92%8C%E5%A4%84%E7%90%86client%E7%AB%AF%E5%8F%91%E6%9D%A5%E7%9A%84%E8%AF%B7%E6%B1%82">循环等待和处理client端发来的请求</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93-3">总结</a></li>
</ul>
</li>
<li><a href="#binder%E5%8E%9F%E7%90%86%E4%BA%94%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%8E%B7%E5%8F%96%E8%BF%87%E7%A8%8B">Binder原理（五）系统服务的获取过程</a><ul>
<li><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AFmediaplayerservice%E8%AF%B7%E6%B1%82%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1">客户端MediaPlayerService请求获取服务</a></li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AFservicemanager%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82">服务端ServiceManager处理请求</a></li>
<li><a href="#%E6%80%BB%E7%BB%93-4">总结</a></li>
</ul>
</li>
<li><a href="#binder%E5%8E%9F%E7%90%86%E5%85%ADjava-binder%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">Binder原理（六）Java Binder的初始化</a><ul>
<li><a href="#java-binder%E7%9A%84jni%E6%B3%A8%E5%86%8C">Java Binder的JNI注册</a><ul>
<li><a href="#binder%E7%B1%BB%E7%9A%84%E6%B3%A8%E5%86%8C">Binder类的注册</a></li>
<li><a href="#binderinternal%E7%B1%BB%E7%9A%84%E6%B3%A8%E5%86%8C">BinderInternal类的注册</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#binder%E5%8E%9F%E7%90%86%E4%B8%83java-binder%E4%B8%AD%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B">Binder原理（七）Java Binder中系统服务的注册过程</a><ul>
<li><a href="#%E5%B0%86ams%E6%B3%A8%E5%86%8C%E5%88%B0servicemanager">将AMS注册到ServiceManager</a><ul>
<li><a href="#binderinternalgetcontextobject">BinderInternal.getContextObject()</a></li>
<li><a href="#servicemanagernativeasinterface">ServiceManagerNative.asInterface()</a></li>
<li><a href="#getiservicemanageraddservice">getIServiceManager().addService()</a></li>
</ul>
</li>
<li><a href="#%E5%BC%95%E5%87%BAjavabbinder">引出JavaBBinder</a></li>
<li><a href="#%E8%A7%A3%E6%9E%90javabbinder">解析JavaBBinder</a></li>
<li><a href="#java-binder%E6%9E%B6%E6%9E%84">Java Binder架构</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#zygote">Zygote</a><ul>
<li><a href="#zygote%E4%B8%80android%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%8F%8Azygote%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B">Zygote(一)：Android系统的启动过程及Zygote的启动过程</a><ul>
<li><a href="#init%E8%BF%9B%E7%A8%8B">init进程</a><ul>
<li><a href="#%E5%B1%9E%E6%80%A7%E6%9C%8D%E5%8A%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%90%AF%E5%8A%A8">属性服务初始化与启动</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86">设置进程信号处理</a></li>
<li><a href="#%E8%A7%A3%E6%9E%90init%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">解析init配置文件</a></li>
</ul>
</li>
<li><a href="#zygote%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8">Zygote进程启动</a><ul>
<li><a href="#systemserver%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B">SystemServer启动过程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#zygote%E4%BA%8C%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B">Zygote（二）：应用进程的启动过程</a><ul>
<li><a href="#zygote%E7%9B%91%E5%90%AC%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82">Zygote监听客户端请求</a></li>
<li><a href="#ams%E5%8F%91%E9%80%81%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E8%AF%B7%E6%B1%82">AMS发送创建进程请求</a></li>
<li><a href="#zygote%E6%8E%A5%E6%94%B6%E4%BF%A1%E6%81%AF%E5%B9%B6%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B">Zygote接收信息并创建进程</a></li>
<li><a href="#%E5%90%AF%E5%8A%A8binder%E7%BA%BF%E7%A8%8B%E6%B1%A0">启动Binder线程池</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ams">AMS</a><ul>
<li><a href="#ams%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%80activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86">AMS源码分析(一)Activity生命周期管理</a><ul>
<li><a href="#activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">Activity的生命周期</a><ul>
<li><a href="#%E4%B8%80%E4%B8%AAactivity%E4%BB%8E%E5%90%AF%E5%8A%A8%E5%88%B0%E9%94%80%E6%AF%81%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E5%91%A8%E6%9C%9F">一个Activity从启动到销毁所经历的周期</a></li>
<li><a href="#%E4%BB%8E%E4%B8%80%E4%B8%AAactivity%E5%90%AF%E5%8A%A8%E5%8F%A6%E4%B8%80%E4%B8%AAactivity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">从一个Activity启动另一个Activity的生命周期</a></li>
</ul>
</li>
<li><a href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">源码分析</a><ul>
<li><a href="#binder-1">Binder</a></li>
<li><a href="#idlehandler">IdleHandler</a></li>
<li><a href="#activity%E5%9C%A8ams%E4%B8%AD%E7%9A%84%E6%A0%87%E8%AF%86">Activity在AMS中的标识</a></li>
<li><a href="#%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%97%B6%E5%BA%8F%E5%9B%BE">启动过程时序图</a></li>
<li><a href="#%E4%BB%8Eaactivity%E8%B7%B3%E8%BD%ACbactivity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%88%86%E6%9E%90">从AActivity跳转BActivity的生命周期分析</a><ul>
<li><a href="#aactivityonpause">AActivity#onPause</a></li>
<li><a href="#bactivityoncreate">BActivity#onCreate</a></li>
<li><a href="#bactivityonstart">BActivity#onStart</a></li>
<li><a href="#bactivityonresume">BActivity#onResume</a></li>
<li><a href="#aactivityonstop">AActivity#onStop</a></li>
</ul>
</li>
<li><a href="#%E4%BB%8Ebactivity%E8%BF%94%E5%9B%9E%E5%88%B0aactivity">从BActivity返回到AActivity</a><ul>
<li><a href="#bactivityonpause">BActivity#onPause</a></li>
<li><a href="#aactivityonstartaactivityonresume">AActivity#onStart、AActivity#onResume</a></li>
<li><a href="#bactivityonstopbactivityondestroy">BActivity#onStop、BActivity#onDestroy</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#ams%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%8Conactivityresult%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B">AMS源码分析(二)onActivityResult执行过程</a><ul>
<li><a href="#onactivityresult">onActivityResult</a><ul>
<li><a href="#aactivity%E8%B7%B3%E8%BD%ACbacitivty%E5%B9%B6%E4%BB%8Ebactivity%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE">AActivity跳转BAcitivty并从BActivity返回数据</a></li>
</ul>
</li>
<li><a href="#intentflag_activity_forward_result">Intent.FLAG_ACTIVITY_FORWARD_RESULT</a><ul>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例：</a><ul>
<li><a href="#aactivity%E4%BB%A5startactivityforresult%E6%96%B9%E5%BC%8F%E6%89%93%E5%BC%80bactivity">AActivity以startActivityForResult方式打开BActivity</a></li>
<li><a href="#bactivity%E4%BB%A5%E6%99%AE%E9%80%9A%E6%96%B9%E5%BC%8F%E6%89%93%E5%BC%80cactivity%E8%AE%BE%E7%BD%AEintent-%E7%9A%84flag-intentflag_activity_forward_result">BActivity以普通方式打开CActivity，设置Intent 的Flag Intent.FLAG_ACTIVITY_FORWARD_RESULT</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">源码解析</a><ul>
<li><a href="#activityresult%E6%95%B0%E6%8D%AE%E7%9A%84%E5%86%99%E5%85%A5">ActivityResult数据的写入</a></li>
<li><a href="#activityresult%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BC%A0%E9%80%92">ActivityResult数据的传递</a></li>
<li><a href="#intentflag_activity_forward_result%E7%9A%84%E5%AE%9E%E7%8E%B0">Intent.FLAG_ACTIVITY_FORWARD_RESULT的实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ams%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89ams%E4%B8%ADactivity%E6%A0%88%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3">AMS源码分析(三)AMS中Activity栈管理详解</a><ul>
<li><a href="#activity%E6%A0%88%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3%E7%B1%BB">Activity栈管理相关类</a><ul>
<li><a href="#activitystacksupervisor">ActivityStackSupervisor</a></li>
<li><a href="#activitydisplay">ActivityDisplay</a></li>
<li><a href="#taskrecord">TaskRecord</a></li>
<li><a href="#activitystack">ActivityStack</a></li>
<li><a href="#%E5%85%B3%E7%B3%BB%E5%9B%BE">关系图：</a></li>
</ul>
</li>
<li><a href="#%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F">启动模式</a><ul>
<li><a href="#standard">standard</a><ul>
<li><a href="#intentflag_activity_clear_top">Intent.FLAG_ACTIVITY_CLEAR_TOP</a></li>
<li><a href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1">源码分析</a><ul>
<li><a href="#%E5%8A%A0%E5%85%A5taskrecord">加入TaskRecord</a></li>
<li><a href="#standard--intentflag_activity_clear_top">standard + Intent.FLAG_ACTIVITY_CLEAR_TOP</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#singletop">singleTop</a><ul>
<li><a href="#%E6%B5%81%E7%A8%8B%E5%9B%BE">流程图：</a><ul>
<li><a href="#%E5%8E%9Factivity%E4%B8%8D%E5%9C%A8%E6%A0%88%E9%A1%B6">原Activity不在栈顶</a></li>
<li><a href="#%E5%8E%9Factivity%E5%9C%A8%E6%A0%88%E9%A1%B6">原Activity在栈顶</a></li>
</ul>
</li>
<li><a href="#singletop--intentflag_activity_clear_top">singleTop + Intent.FLAG_ACTIVITY_CLEAR_TOP</a></li>
<li><a href="#log">log</a><ul>
<li><a href="#%E5%8E%9Factivity%E4%B8%8D%E5%9C%A8%E6%A0%88%E9%A1%B6-1">原Activity不在栈顶</a></li>
<li><a href="#%E5%8E%9Factivity%E5%9C%A8%E6%A0%88%E9%A1%B6-1">原Activity在栈顶</a></li>
<li><a href="#%E5%8E%9Factiivty%E5%9C%A8%E6%A0%88%E9%A1%B6%E4%B8%94%E8%AE%BE%E7%BD%AEintentflag_activity_clear_top">原Actiivty在栈顶且设置Intent.FLAG_ACTIVITY_CLEAR_TOP</a></li>
</ul>
</li>
<li><a href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-2">源码分析</a><ul>
<li><a href="#singletop--intentflag_activity_clear_top-1">singleTop + Intent.FLAG_ACTIVITY_CLEAR_TOP</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#singletask">singleTask</a><ul>
<li><a href="#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">启动流程</a><ul>
<li><a href="#%E5%9C%BA%E6%99%AF%E4%B8%80">场景一</a></li>
<li><a href="#%E5%9C%BA%E6%99%AF%E4%BA%8C">场景二</a></li>
<li><a href="#%E5%9C%BA%E6%99%AF%E4%B8%89">场景三</a></li>
</ul>
</li>
<li><a href="#singetask%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">singeTask源码分析</a></li>
</ul>
</li>
<li><a href="#singleinstance">singleInstance</a></li>
</ul>
</li>
<li><a href="#intentflag_activity_new_tasktaskaffinity%E6%96%B0task%E7%9A%84%E5%88%9B%E5%BB%BA">Intent.FLAG_ACTIVITY_NEW_TASK、taskAffinity、新Task的创建</a><ul>
<li><a href="#intentflag_activity_new_task%E7%9A%84%E8%87%AA%E5%8A%A8%E8%AE%BE%E7%BD%AE">Intent.FLAG_ACTIVITY_NEW_TASK的自动设置</a></li>
<li><a href="#taskaffinity%E7%9A%84%E8%AF%86%E5%88%AB">taskAffinity的识别</a></li>
<li><a href="#%E6%98%AF%E5%90%A6%E5%88%9B%E5%BB%BA%E6%96%B0task%E7%9A%84%E8%AF%86%E5%88%AB">是否创建新task的识别</a></li>
<li><a href="#%E6%80%BB%E7%BB%93-5">总结</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#pms">PMS</a><ul>
<li><a href="#%E6%B7%B1%E5%85%A5pms%E6%BA%90%E7%A0%81%E4%B8%80-pms%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B">深入PMS源码（一）—— PMS的启动过程和执行流程</a><ul>
<li><a href="#pms%E7%AE%80%E4%BB%8B">PMS简介</a></li>
<li><a href="#pms%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B">PMS的启动过程</a></li>
<li><a href="#pms%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">PMS构造函数</a><ul>
<li><a href="#pms%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B">PMS的工作过程</a></li>
<li><a href="#%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6packagexml">解析配置文件package.xml</a></li>
<li><a href="#%E6%89%AB%E6%8F%8F%E5%AE%89%E8%A3%85%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">扫描安装的应用程序</a></li>
<li><a href="#%E5%B0%86apk%E8%A7%A3%E6%9E%90%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%88%B0pms%E7%9A%84%E5%B1%9E%E6%80%A7%E4%B8%AD">将apk解析数据同步到PMS的属性中</a></li>
<li><a href="#%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">更新配置文件</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%B7%B1%E5%85%A5pms%E6%BA%90%E7%A0%81%E4%BA%8C-apk%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">深入PMS源码（二）—— APK的安装和卸载源码分析</a><ul>
<li><a href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85%E5%9F%BA%E7%A1%80">应用程序安装基础</a></li>
<li><a href="#pms%E4%B8%ADapk%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B">PMS中APK安装过程</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8D%B8%E8%BD%BD%E8%BF%87%E7%A8%8B">应用程序的卸载过程</a></li>
</ul>
</li>
<li><a href="#%E6%B7%B1%E5%85%A5pms%E6%BA%90%E7%A0%81%E4%B8%89-pms%E4%B8%ADintent-filter%E7%9A%84%E5%8C%B9%E9%85%8D%E6%9E%B6%E6%9E%84">深入PMS源码（三）—— PMS中intent-filter的匹配架构</a><ul>
<li><a href="#pms%E4%BF%9D%E5%AD%98intentfilter">PMS保存IntentFilter</a></li>
<li><a href="#intentfilter%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8C%B9%E9%85%8D">IntentFilter的查找匹配</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#wms">WMS</a><ul>
<li><a href="#wms%E4%B8%80wms%E7%9A%84%E8%AF%9E%E7%94%9F">WMS（一）：WMS的诞生</a><ul>
<li><a href="#wms%E6%A6%82%E8%BF%B0">WMS概述</a><ul>
<li><a href="#%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86">窗口管理</a></li>
<li><a href="#%E7%AA%97%E5%8F%A3%E5%8A%A8%E7%94%BB">窗口动画</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%AD%E8%BD%AC%E7%AB%99">输入系统的中转站</a></li>
<li><a href="#surface%E7%AE%A1%E7%90%86">Surface管理</a></li>
</ul>
</li>
<li><a href="#wms%E7%9A%84%E8%AF%9E%E7%94%9F">WMS的诞生</a></li>
</ul>
</li>
<li><a href="#wms%E4%BA%8Cwms%E7%9A%84%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%92%8Cwindow%E7%9A%84%E6%B7%BB%E5%8A%A0%E8%BF%87%E7%A8%8B">WMS（二）：WMS的重要成员和Window的添加过程</a><ul>
<li><a href="#wms%E7%9A%84%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98">WMS的重要成员</a></li>
<li><a href="#window%E7%9A%84%E6%B7%BB%E5%8A%A0%E8%BF%87%E7%A8%8Bwms%E9%83%A8%E5%88%86">Window的添加过程（WMS部分）</a><ul>
<li><a href="#addwindow%E6%96%B9%E6%B3%95part1">addWindow方法part1</a></li>
<li><a href="#addwindow%E6%96%B9%E6%B3%95part2">addWindow方法part2</a></li>
<li><a href="#addwindow%E6%96%B9%E6%B3%95part3">addWindow方法part3</a></li>
<li><a href="#addwindow%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93">addWindow方法总结</a></li>
</ul>
</li>
<li><a href="#%E7%BB%93%E8%AF%AD">结语</a></li>
</ul>
</li>
<li><a href="#wms%E4%B8%89window%E7%9A%84%E5%88%A0%E9%99%A4%E8%BF%87%E7%A8%8B">WMS（三）：Window的删除过程</a><ul>
<li><a href="#window%E7%9A%84%E5%88%A0%E9%99%A4%E8%BF%87%E7%A8%8B">Window的删除过程</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h1><h2 id="Handler机制实现原理-一-宏观理论分析与Message源码分析"><a href="#Handler机制实现原理-一-宏观理论分析与Message源码分析" class="headerlink" title="Handler机制实现原理(一)宏观理论分析与Message源码分析"></a>Handler机制实现原理(一)宏观理论分析与Message源码分析</h2><h3 id="Message"><a href="#Message" class="headerlink" title="Message:"></a>Message:</h3><p>定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>` `<span class="keyword">final</span>` `class` `Message ``implements` `Parcelable</span><br></pre></td></tr></table></figure>

<p>Message类是个final类，就是说不能被继承，同时Message类实现了Parcelable接口，我们知道android提供了一种新的类型：Parcel。<strong>本类被用作封装数据的容器，是链表结构，</strong>有个属性next和sPool，这两个变量是不同的，具体什么不同看下文。</p>
<p>文档描述：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Defines a message containing a description and arbitrary data object that can be sent to a &#123;<span class="meta">@link</span> Handler&#125;.  This object contains two extra <span class="type">int</span> fields and an</span><br><span class="line">extra object field that allow you to not <span class="keyword">do</span> allocations in many cases. </span><br></pre></td></tr></table></figure>

<p>定义一个包含任意类型的描述数据对象，此对象可以发送给Handler。对象包含两个额外的int字段和一个额外的对象字段，这样可以使得在很多情况下不用做分配工作。尽管Message的构造器是公开的，但是获取Message对象的最好方法是调用Message.obtain()或者Handler.obtainMessage(), 这样是从一个可回收对象池中获取Message对象。</p>
<h4 id="看一下全局变量：有好多存数据的对象。"><a href="#看一下全局变量：有好多存数据的对象。" class="headerlink" title="看一下全局变量：有好多存数据的对象。"></a>看一下全局变量：有好多存数据的对象。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> what;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> arg1;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> arg2;</span><br><span class="line"><span class="keyword">public</span> Object obj;</span><br><span class="line"><span class="keyword">public</span> Messenger replyTo;</span><br><span class="line"><span class="comment">/*package*/</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="comment">/*package*/</span> <span class="type">long</span> when;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*package*/</span> Bundle data;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*package*/</span> Handler target;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*package*/</span> Runnable callback;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// sometimes we store linked lists of these things</span></span><br><span class="line"><span class="comment">/*package*/</span> Message next;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">sPoolSync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">sPoolSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">gCheckRecycle</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>what：用户定义消息代码以便收件人可以识别这是哪一个Message。每个Handler用它自己的名称空间为消息代码,所以您不需要担心你的Handler与其他handler冲突。</li>
<li>arg1、arg2：如果只是想向message内放一些整数值，可以使用arg1和arg2来代替setData方法。</li>
<li>obj：发送给接收器的任意对象。当使用Message对象在线程间传递消息时，如果它包含一个Parcelable的结构类（不是由应用程序实现的类），此字段必须为非空（non-null）。其他的数据传输则使用setData(Bundle)方法。注意Parcelable对象是从FROYO版本以后才开始支持的。</li>
<li>replyTo：指明此message发送到何处的可选Messenger对象。具体的使用方法由发送者和接受者决定。</li>
<li>FLAG_IN_USE：判断Message是否在使用（ default 包内可见）</li>
<li>FLAG_ASYNCHRONOUS：如果设置message是异步的。</li>
<li>FLAGS_TO_CLEAR_ON_COPY_FROM：明确在copyFrom方法</li>
<li>其他参数都比较简单，不详述</li>
</ol>
<h4 id="Obtain方法："><a href="#Obtain方法：" class="headerlink" title="Obtain方法："></a>Obtain方法：</h4><p>　</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从全局池中返回一个新的Message实例。在大多数情况下这样可以避免分配新的对象。</span></span><br><span class="line"><span class="comment">//是一个静态方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title function_">obtain</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sPool != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> sPool;</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                m.next = <span class="literal">null</span>;</span><br><span class="line">                m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">                sPoolSize--;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>　　在看它一系列的重载方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Same as &#123;<span class="doctag">@link</span> #obtain()&#125;, but copies the values of an existing</span></span><br><span class="line"><span class="comment">     * message (including its target) into the new one.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> orig Original message to copy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A Message object from the global pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title function_">obtain</span><span class="params">(Message orig)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> obtain();</span><br><span class="line">        m.what = orig.what;</span><br><span class="line">        m.arg1 = orig.arg1;</span><br><span class="line">        m.arg2 = orig.arg2;</span><br><span class="line">        m.obj = orig.obj;</span><br><span class="line">        m.replyTo = orig.replyTo;</span><br><span class="line">        m.sendingUid = orig.sendingUid;</span><br><span class="line">        <span class="keyword">if</span> (orig.data != <span class="literal">null</span>) &#123;</span><br><span class="line">            m.data = <span class="keyword">new</span> <span class="title class_">Bundle</span>(orig.data);</span><br><span class="line">        &#125;</span><br><span class="line">        m.target = orig.target;</span><br><span class="line">        m.callback = orig.callback;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     设置target</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title function_">obtain</span><span class="params">(Handler h)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> obtain();</span><br><span class="line">        m.target = h;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Same as &#123;<span class="doctag">@link</span> #obtain(Handler)&#125;, but assigns a callback Runnable on</span></span><br><span class="line"><span class="comment">     * the Message that is returned.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h  Handler to assign to the returned Message object&#x27;s &lt;em&gt;target&lt;/em&gt; member.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callback Runnable that will execute when the message is handled.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A Message object from the global pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title function_">obtain</span><span class="params">(Handler h, Runnable callback)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> obtain();</span><br><span class="line">        m.target = h;</span><br><span class="line">        m.callback = callback;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Same as &#123;<span class="doctag">@link</span> #obtain()&#125;, but sets the values of the &lt;em&gt;target&lt;/em&gt;, &lt;em&gt;what&lt;/em&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;em&gt;arg1&lt;/em&gt;, &lt;em&gt;arg2&lt;/em&gt;, and &lt;em&gt;obj&lt;/em&gt; members.</span></span><br><span class="line"><span class="comment">      。。。。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj  The &lt;em&gt;obj&lt;/em&gt; value to set.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  A Message object from the global pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title function_">obtain</span><span class="params">(Handler h, <span class="type">int</span> what,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> arg1, <span class="type">int</span> arg2, Object obj)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> obtain();</span><br><span class="line">        m.target = h;</span><br><span class="line">        m.what = what;</span><br><span class="line">        m.arg1 = arg1;</span><br><span class="line">        m.arg2 = arg2;</span><br><span class="line">        m.obj = obj;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>还有几个没列举出来，都是先调用obtain()方法，然后把获取的Message实例加上各种参数。代码一目了然。。。</p>
<h4 id="recycle-回收当前message到全局池"><a href="#recycle-回收当前message到全局池" class="headerlink" title="recycle():回收当前message到全局池"></a>recycle():回收当前message到全局池</h4><p>　</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return a Message instance to the global pool.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * You MUST NOT touch the Message after calling this function because it has</span></span><br><span class="line"><span class="comment">     * effectively been freed.  It is an error to recycle a message that is currently</span></span><br><span class="line"><span class="comment">     * enqueued or that is in the process of being delivered to a Handler.</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recycle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;This message cannot be recycled because it &quot;</span></span><br><span class="line">                        + <span class="string">&quot;is still in use.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Recycles a Message that may be in-use.</span></span><br><span class="line"><span class="comment">     * Used internally by the MessageQueue and Looper when disposing of queued Messages.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">recycleUnchecked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">        <span class="comment">// Clear out all other details.</span></span><br><span class="line">        flags = FLAG_IN_USE;</span><br><span class="line">        what = <span class="number">0</span>;</span><br><span class="line">        arg1 = <span class="number">0</span>;</span><br><span class="line">        arg2 = <span class="number">0</span>;</span><br><span class="line">        obj = <span class="literal">null</span>;</span><br><span class="line">        replyTo = <span class="literal">null</span>;</span><br><span class="line">        sendingUid = -<span class="number">1</span>;</span><br><span class="line">        when = <span class="number">0</span>;</span><br><span class="line">        target = <span class="literal">null</span>;</span><br><span class="line">        callback = <span class="literal">null</span>;</span><br><span class="line">        data = <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">                next = sPool;</span><br><span class="line">                sPool = <span class="built_in">this</span>;</span><br><span class="line">                sPoolSize++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>向全局池中返回一个Message实例。一定不能在调用此函数后再使用Message——它实际上已经被释放。</p>
<p>getWhen：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the targeted delivery time of this message, in milliseconds.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getWhen</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> when;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>返回此消息的传输时间，以毫秒为单位。</p>
<p> setTarget，getTarget：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置handler和返回handler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTarget</span><span class="params">(Handler target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Retrieve the a &#123;<span class="doctag">@link</span> android.os.Handler Handler&#125; implementation that</span></span><br><span class="line"><span class="comment">     * will receive this message. The object must implement</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> android.os.Handler#handleMessage(android.os.Message)</span></span><br><span class="line"><span class="comment">     * Handler.handleMessage()&#125;. Each Handler has its own name-space for</span></span><br><span class="line"><span class="comment">     * message codes, so you do not need to</span></span><br><span class="line"><span class="comment">     * worry about yours conflicting with other handlers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Handler <span class="title function_">getTarget</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>获取将接收此消息的Handler对象。此对象必须要实现Handler.handleMessage()方法。每个handler各自包含自己的消息代码，所以不用担心自定义的消息跟其他handlers有冲突。</p>
<h3 id="setData："><a href="#setData：" class="headerlink" title="setData："></a>setData：</h3><p> 设置一个可以是任何类型值的bundle。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets a Bundle of arbitrary data values. Use arg1 and arg2 members</span></span><br><span class="line"><span class="comment">     * as a lower cost way to send a few simple integer values, if you can.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getData()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #peekData()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Bundle data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>　　getData，peekData</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Bundle <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">null</span>) &#123;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> Bundle <span class="title function_">peekData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送消息的一些方法："><a href="#发送消息的一些方法：" class="headerlink" title="发送消息的一些方法："></a>发送消息的一些方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**向Handler发送此消息，getTarget()方法可以获取此Handler。如果这个字段没有设置会抛出个空指针异常。</span></span><br><span class="line"><span class="comment">     * Sends this Message to the Handler specified by &#123;<span class="doctag">@link</span> #getTarget&#125;.</span></span><br><span class="line"><span class="comment">     * Throws a null pointer exception if this field has not been set.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendToTarget</span><span class="params">()</span> &#123;</span><br><span class="line">        target.sendMessage(<span class="built_in">this</span>);</span><br><span class="line">    &#125;　　</span><br></pre></td></tr></table></figure>

<h4 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Constructor (but the preferred way to get a Message is to call &#123;<span class="doctag">@link</span> #obtain() Message.obtain()&#125;).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Message</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//推荐使用Message.obtain()</span></span><br></pre></td></tr></table></figure>

<h4 id="writeToParcel："><a href="#writeToParcel：" class="headerlink" title="writeToParcel："></a>writeToParcel：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeToParcel</span><span class="params">(Parcel dest, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                <span class="string">&quot;Can&#x27;t marshal callbacks across processes.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dest.writeInt(what);</span><br><span class="line">        dest.writeInt(arg1);</span><br><span class="line">        dest.writeInt(arg2);</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Parcelable</span> <span class="variable">p</span> <span class="operator">=</span> (Parcelable)obj;</span><br><span class="line">                dest.writeInt(<span class="number">1</span>);</span><br><span class="line">                dest.writeParcelable(p, flags);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                    <span class="string">&quot;Can&#x27;t marshal non-Parcelable objects across processes.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dest.writeInt(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dest.writeLong(when);</span><br><span class="line">        dest.writeBundle(data);</span><br><span class="line">        Messenger.writeMessengerOrNullToParcel(replyTo, dest);</span><br><span class="line">        dest.writeInt(sendingUid);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>　将类的数据写入外部提供的Parcel中和从Parcel中读取数据。</p>
<h2 id="Handler机制实现原理（二）MessageQueue的源码分析"><a href="#Handler机制实现原理（二）MessageQueue的源码分析" class="headerlink" title="Handler机制实现原理（二）MessageQueue的源码分析"></a>Handler机制实现原理（二）MessageQueue的源码分析</h2><blockquote>
<p>看源码有一段时间了，越来越能从代码中感觉到工程师们满满的激情，无论是基础Java语法还是高级的语言特性都被发挥的淋漓尽致，写的恰到好处。分析源码的过程，何尝不是与大神们进行灵魂沟的过程。</p>
</blockquote>
<p>MessageQueue属于低层类且依附于Looper，Looper外其他类不应该单独创建它，如果想使用MessageQueue可以从Looper类中得到它。</p>
<h3 id="消息队列存储原理"><a href="#消息队列存储原理" class="headerlink" title="消息队列存储原理"></a>消息队列存储原理</h3><p>再上一章Message源码分析中我们知道了Message内部维持了一个链表缓存池来避免重复创建Message对象造成的额外消耗，以静态属性<code>private static Message sPool</code>作为缓存池链表头，<code>Message next;</code>作为链表的next指针。</p>
<p>有意思的是Message对象中<code>next</code>指针的不止用于链表缓存池，在MessageQueue中也采用同样的方法存储消息对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MessageQueue</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    Message mMessages;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中的<code>mMessages</code>就是MessageQueue用来维持消息队列的链表头，至于它是如何存储的，后面再说。</p>
<h3 id="使用JNI实现的native方法"><a href="#使用JNI实现的native方法" class="headerlink" title="使用JNI实现的native方法"></a>使用JNI实现的native方法</h3><p>MessageQueue的源码调用了多个的C&#x2F;C++方法，这类方法使用前都会用关键字<code>native</code>声明一下。</p>
<p>这些方法所属的底层C++代码创建了属于native层自己的<code>NativeMessageQueue</code>和<code>NativeLooper</code>消息模型。它们对Java层作用其实就是<strong>控制线程是否阻塞</strong>。</p>
<p>当我们想要从MessageQueue中取出消息时，碰巧队列是空的或即将取出的消息还没到被处理时间，那么我们就需要将线程阻塞掉等待队列中有消息时再取出。</p>
<p>下面就是MessageQueue中的<code>native</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">nativeInit</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 注销</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">nativeDestroy</span><span class="params">(<span class="type">long</span> ptr)</span>;</span><br><span class="line"><span class="comment">// 让线程阻塞timeoutMillis毫秒</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativePollOnce</span><span class="params">(<span class="type">long</span> ptr, <span class="type">int</span> timeoutMillis)</span>; </span><br><span class="line"><span class="comment">// 立刻唤醒线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">nativeWake</span><span class="params">(<span class="type">long</span> ptr)</span>;</span><br><span class="line"><span class="comment">// 线程是否处于阻塞状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">nativeIsPolling</span><span class="params">(<span class="type">long</span> ptr)</span>;</span><br><span class="line"><span class="comment">// 设置文件描述符</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">nativeSetFileDescriptorEvents</span><span class="params">(<span class="type">long</span> ptr, <span class="type">int</span> fd, <span class="type">int</span> events)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>文件描述符与ePoll指令</strong></p>
<p>消息队列里控制线程阻塞状态的<code>native</code>代码本质是用Linux指令<code>ePoll</code>完成的，在这之前需要先了解一点，Linux内核依靠“文件描述符（file descriptor）”来完成所有的文件读写访问操作，它更像是一个文件的索引值。而我们用到的<code>ePoll</code>指令就是用来监听文件描述符是否有可I&#x2F;O操作的。<em>（这都是一些Linux相关知识）</em></p>
<h3 id="创建与销毁"><a href="#创建与销毁" class="headerlink" title="创建与销毁"></a>创建与销毁</h3><p>上面说了MessageQueue是依附于Looper的，所以本节分析的创建与销毁方法其实都是给Looper调用的，MessageQueue只提供了一个带参的构造方法来创建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前MessageQueue是否可以退出</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> mQuitAllowed;</span><br><span class="line"></span><br><span class="line"><span class="comment">// native层中NativeMessageQueue队列指针的地址</span></span><br><span class="line"><span class="comment">// mPtr等于0时表示退出队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> mPtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// native层代码，创建native层中NativeMessageQueue</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">nativeInit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line">MessageQueue(<span class="type">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    <span class="comment">// 执行native层方法</span></span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法中<code>boolean quitAllowed</code>参数的意思是当前这个MessageQueue是否可以手动退出，为什么要控制能否手动退出呢？这里先说一个结论：Android 系统中要求UI线程不可手动退出，而其他Worker线程则<strong>全部都是</strong>可以的。<em>（具体的操作在Looper和UI线程中）</em></p>
<p><strong>那么退出是什么意思呢？</strong></p>
<p>退出就是当前这个MessageQueue停止服务，将队列中已存在的所有消息全部清空，看看源码中退出方法都做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否已经退出了</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> mQuitting;</span><br><span class="line"></span><br><span class="line"><span class="comment">// native方法，退出队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">nativeDestroy</span><span class="params">(<span class="type">long</span> ptr)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出队列</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">quit</span><span class="params">(<span class="type">boolean</span> safe)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果不是可以手动退出的，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!mQuitAllowed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Main thread not allowed to quit.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果已经退出了直接结束方法</span></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标记为已退出状态</span></span><br><span class="line">        mQuitting = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两种清除队列中消息的方法</span></span><br><span class="line">        <span class="keyword">if</span> (safe) &#123;</span><br><span class="line">            removeAllFutureMessagesLocked();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            removeAllMessagesLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注销</span></span><br><span class="line">        nativeWake(mPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法<code>quit(boolean safe)</code>中的参数<code>safe</code>决定了到底执行哪种清除消息的方法：</p>
<ul>
<li><code>removeAllMessagesLocked()</code>，简单暴力直接清除掉队列中所有的消息。</li>
<li><code>removeAllFutureMessagesLocked()</code>，清除掉可能还没有被处理的消息。</li>
</ul>
<p><code>removeAllMessagesLocked()</code>方法的逻辑很简单，从队列头中取消息，有一个算一个，全部拿出来回收掉。：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeAllMessagesLocked</span>()</span> &#123;</span><br><span class="line">    Message p = mMessages;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        Message n = p.next;</span><br><span class="line">        p.recycleUnchecked();</span><br><span class="line">        p = n;</span><br><span class="line">    &#125;</span><br><span class="line">    mMessages = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，<code>removeAllFutureMessagesLocked()</code>方法的逻辑稍微多一点：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeAllFutureMessagesLocked</span>()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前系统时间</span></span><br><span class="line">    final <span class="built_in">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">    Message p = mMessages;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断当前消息对象的预处理时间是否晚于当前时间</span></span><br><span class="line">        <span class="keyword">if</span> (p.<span class="keyword">when</span> &gt; now) &#123;</span><br><span class="line">            <span class="comment">// 如果当前消息对象的预处理时间晚于当前时间直接全部暴力清除</span></span><br><span class="line">            removeAllMessagesLocked();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Message n;</span><br><span class="line">            <span class="comment">// 如果当前消息对象的预处理时间并不晚于当前时间</span></span><br><span class="line">            <span class="comment">// 说明有可能这个消息正在被分发处理</span></span><br><span class="line">            <span class="comment">// 那么就跳过这个消息往后找晚于当前时间的消息</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                n = p.next;</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (n.<span class="keyword">when</span> &gt; now) &#123;</span><br><span class="line">                    <span class="comment">// 如果找到了晚于当前时间的消息结束循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p = n;</span><br><span class="line">            &#125;</span><br><span class="line">            p.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// n就是那个晚于当前时间的消息</span></span><br><span class="line">                <span class="comment">// 从n开始之后的消息全部回收</span></span><br><span class="line">                p = n;</span><br><span class="line">                n = p.next;</span><br><span class="line">                p.recycleUnchecked();</span><br><span class="line">            &#125; <span class="keyword">while</span> (n != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么看来这个方法名字起的还挺靠谱的，很好的解释了是要删除还没有被处理的消息。</p>
<h3 id="消息入队管理enqueueMessage-方法"><a href="#消息入队管理enqueueMessage-方法" class="headerlink" title="消息入队管理enqueueMessage()方法"></a>消息入队管理enqueueMessage()方法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息入队</span></span><br><span class="line"><span class="comment">// 参数when就是此消息应该被处理的时间</span></span><br><span class="line"><span class="function">boolean <span class="title">enqueueMessage</span>(<span class="params">Message msg, <span class="built_in">long</span> <span class="keyword">when</span></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果此消息的target也就是宿主handler是空的抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果此消息是in-use状态抛异常，in-use的消息不可拿来使用</span></span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上锁</span></span><br><span class="line">    synchronized (<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前MessageQueue已经退出了抛异常并释放掉此消息</span></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将消息标记为in-use状态</span></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        <span class="comment">// 设置应该被处理的时间</span></span><br><span class="line">        msg.<span class="keyword">when</span> = <span class="keyword">when</span>;</span><br><span class="line">        <span class="comment">// 拿到队列头</span></span><br><span class="line">        Message p = mMessages;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否需要唤醒线程</span></span><br><span class="line">        boolean needWake;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p等于空说明队列是空的</span></span><br><span class="line">        <span class="comment">// when等于0表示强制把此消息插入队列头部，最先处理</span></span><br><span class="line">        <span class="comment">// when小于队列头的when说明此消息应该被处理的时间比队列中第一个要处理的时间还早</span></span><br><span class="line">        <span class="comment">// 以上情况满足任意一种直接将消息插入队列头部</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || <span class="keyword">when</span> == <span class="number">0</span> || <span class="keyword">when</span> &lt; p.<span class="keyword">when</span>) &#123;</span><br><span class="line">            <span class="comment">// 将消息插入队列头部</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 线程已经被阻塞&amp;&amp;消息存在宿主Handler&amp;&amp;消息是异步的</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">            <span class="comment">//如果上述条件都不满足就要按照消息应该被处理的时间插入队列中    </span></span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 两根相邻的引用一前一后从队列头开始依次向后移动</span></span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="comment">// 如果队列到尾部了或者找到了处理时间早于自身的消息就结束循环</span></span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || <span class="keyword">when</span> &lt; p.<span class="keyword">when</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果入队的消息是异步的而排在它前面的消息有异步的就不需要唤醒</span></span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将新消息插在这一前一后两个引用中间，完成入队</span></span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否需要唤醒线程</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下消息入队的逻辑大致分为如下几步：</p>
<ol>
<li>检查消息合法性，包括宿主<code>target</code>是否为空，是否为in-use状态，队列是否还存活。</li>
<li>如果满足条件【队列为空、when等于0、此消息应被处理的时间比队列中第一个要处理的时间还早】中的任意一个直接将此消息插在队列头部最先被处理。</li>
<li>如果以上三个条件均不满足，那么就从头遍历队列根据被处理时间找到它的位置。</li>
</ol>
<h3 id="同步消息拦截器"><a href="#同步消息拦截器" class="headerlink" title="同步消息拦截器"></a>同步消息拦截器</h3><p>除了<code>enqueueMessage()</code>方法可以向队列中添加消息外，还有一个<code>postSyncBarrier()</code>方法也可以向队列添加消息，但它不是添加普通的消息，我们将它添加的特殊Message称为<strong>同步消息拦截器</strong>。</p>
<p>顾名思义，该拦截器只会影响同步消息。复习一下上节中分析到的东西，我们默认发送的消息都是同步的，只有某个Message被调用了<code>setAsynchronous(true)</code>后才是异步消息。同步消息受队列限制依次有序的等待处理，异步消息也不受限制。</p>
<p>消息拦截器与普通消息的差异在于拦截器的<code>target</code>是空的，正常我们通过<code>enqueueMessage()</code>方法入队的消息由于限制<code>target</code>是不能为空的。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标识拦截器的token</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> mNextBarrierToken;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">postSyncBarrier</span>(<span class="params"><span class="built_in">long</span> <span class="keyword">when</span></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    synchronized (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 得到拦截器token</span></span><br><span class="line">        final <span class="built_in">int</span> token = mNextBarrierToken++;</span><br><span class="line">        <span class="comment">// 实例化一个消息对象</span></span><br><span class="line">        final Message msg = Message.obtain();</span><br><span class="line">        <span class="comment">// 将对象设置为in-use状态</span></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        <span class="comment">// 设置时间</span></span><br><span class="line">        msg.<span class="keyword">when</span> = <span class="keyword">when</span>;</span><br><span class="line">        <span class="comment">// 将token存于消息的常用属性arg1中</span></span><br><span class="line">        msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">        Message prev = <span class="literal">null</span>;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果when不等于0就在队列中按时间找到它的位置</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">when</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; p.<span class="keyword">when</span> &lt;= <span class="keyword">when</span>) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果prev不等于空就把拦截器插入</span></span><br><span class="line">        <span class="comment">// 如果prev等于空直接插入队列头部</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 拦截器入队成功，返回对应token</span></span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总体来说添加拦截器的方法跟正常消息入队差不多，值得一提的就是Message的<code>target</code>是空的，然后<code>arg1</code>保存着拦截器的唯一标识<code>token</code>。</p>
<p><code>token</code>的作用是找到对应的拦截器删除，看看删除拦截器的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeSyncBarrier</span><span class="params">(<span class="type">int</span> token)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="comment">// 遍历队列找到指定拦截器</span></span><br><span class="line">        <span class="comment">// 查找条件：target为空，arg1等于指定token值</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; (p.target != <span class="literal">null</span> || p.arg1 != token)) &#123;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果p等于空说明没找到</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The specified message queue synchronization &quot;</span></span><br><span class="line">                    + <span class="string">&quot; barrier token has not been posted or has already been removed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否需要唤醒线程</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> needWake;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在队列中移除掉拦截器</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123;</span><br><span class="line">            prev.next = p.next;</span><br><span class="line">            <span class="comment">// 如果prev不等于空说明拦截器前面还有别的消息，就不需要唤醒</span></span><br><span class="line">            needWake = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessages = p.next;</span><br><span class="line">            <span class="comment">// 拦截器在队列头部，移除它之后如果队列空了或者它的下一个消息是个正常消息就需要唤醒</span></span><br><span class="line">            needWake = mMessages == <span class="literal">null</span> || mMessages.target != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回收</span></span><br><span class="line">        p.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否需要唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="队列空闲处理器IdleHandler"><a href="#队列空闲处理器IdleHandler" class="headerlink" title="队列空闲处理器IdleHandler"></a>队列空闲处理器IdleHandler</h3><p>由于在从队列中取出消息时队里可能是空的，这时候就会阻塞线程等待消息到来。每次队列中没有消息而进入的阻塞状态，我们叫它为“空闲状态”。</p>
<p>讲道理实际使用中队列空闲状态的情况还是很常见的，为了更好的利用资源，也为了更好的掌握线程的状态，开发人员就设计了这么一个“队列空闲处理器IdleHandler”。</p>
<p><code>IdleHandler</code>是MessageQueue类下的一个子接口，只包含了一个方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">interface</span> <span class="title">IdleHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当线程的MessageQueue等待更多消息时会调用该方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 返回值：true代表只执行一次，false代表会一直执行它</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">boolean <span class="title">queueIdle</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MessageQueue为我们提供了添加和删除IdleHandler的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用一个ArrayList存储IdleHandler</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;IdleHandler&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个IdleHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addIdleHandler</span><span class="params">(<span class="meta">@NonNull</span> IdleHandler handler)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;Can&#x27;t add a null IdleHandler&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">         mIdleHandlers.add(handler);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 删除一个IdleHandler</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeIdleHandler</span><span class="params">(<span class="meta">@NonNull</span> IdleHandler handler)</span> &#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">         mIdleHandlers.remove(handler);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息出队管理next-方法"><a href="#消息出队管理next-方法" class="headerlink" title="消息出队管理next()方法"></a>消息出队管理next()方法</h3><p><code>next()</code>方法很长，先大致看一下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> IdleHandler[] mPendingIdleHandlers;</span><br><span class="line"></span><br><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mPtr是从native方法中得到的NativeMessageQueue地址</span></span><br><span class="line">   <span class="comment">// 如果mPtr等于0说明队列不存在或被清除掉了</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ptr</span> <span class="operator">=</span> mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待处理的IdleHandler数量，因为代表数量，所以只有第一次初始化时为-1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pendingIdleHandlerCount</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程将被阻塞的时间</span></span><br><span class="line">    <span class="comment">// -1：一直阻塞</span></span><br><span class="line">    <span class="comment">// 0：不阻塞</span></span><br><span class="line">    <span class="comment">// &gt;0:阻塞nextPollTimeoutMillis 毫秒</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextPollTimeoutMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始死循环，下面的代码都是在循环中，贼长！</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果nextPollTimeoutMillis 不等于0说明要阻塞线程了</span></span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 为即将长时间阻塞做准备把该释放的对象都释放了</span></span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞线程操作</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 得到当前时间</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">            <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断队列头是不是同步拦截器</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是拦截器就向后找一个异步消息</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断队列是否有可以取出的消息</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// 如果待取出的消息还没有到应该被处理的时间就让线程阻塞到应该被处理的时间</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 直接就能取出消息，所以不用阻塞线程</span></span><br><span class="line">                    mBlocked = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                    将消息从队列中剥离出来</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 让消息脱离队列</span></span><br><span class="line">                    msg.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 设置为in-use状态</span></span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="comment">// 返回取出的消息，结束循环，结束next()方法</span></span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 队列中没有可取出的消息，nextPollTimeoutMillis 等于-1让线程一直阻塞</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果队列已经退出了直接注销和结束方法</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// IdleHandler初始化为-1，所以在本循环中该条件成立的次数 &lt;= 1</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span> &amp;&amp; (mMessages == <span class="literal">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                <span class="comment">// 得到IdleHandler的数量</span></span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// pendingIdleHandlerCount 小于或等于0说明既没有合适的消息也没有合适的闲时处理</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 直接进入下次循环阻塞线程</span></span><br><span class="line">                mBlocked = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 代码执行到此处就说明线程中有待处理的IdleHandler</span></span><br><span class="line">            <span class="comment">// 那么就从IdleHandler集合列表中取出待处理的IdleHandler</span></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 初始化待处理IdleHandler数组，最小长度为4</span></span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> <span class="title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从IdleHandler集合中获取待处理的IdleHandler</span></span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// ==========到此处同步代码块已经结束==========</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="comment">// 取出一个IdleHandler</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers[i];</span><br><span class="line">            <span class="comment">// 释放掉引用</span></span><br><span class="line">            mPendingIdleHandlers[i] = <span class="literal">null</span>; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// IdleHandler的执行模式，true=执行一次，false=总是执行</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行IdleHandler的queueIdle()代码，得到执行模式</span></span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过执行模式判断是否需要移除掉对应的IdleHandler</span></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理完了所有IdleHandler把数量清0</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为执行了IdleHandler的代码块，有可能已经有新的消息入队了</span></span><br><span class="line">        <span class="comment">// 所以到这里就不阻塞线程，直接去查看有没有新消息</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息出队的核心代码的逻辑都在一个庞大的死循环<code>for(;;)</code>中，其流程如下：</p>
<p>0，循环开始。</p>
<p>1，根据nextPollTimeoutMillis值阻塞线程，初始值为0：不阻塞线程。</p>
<p>2，将【待取出消息指针】指向队列头。</p>
<p>3，如果队列头是同步拦截器的话就将【待取出消息指针】指向队列头后面最近的一个异步消息。</p>
<p>4，如果【待取出消息指针】不可用（msg &#x3D;&#x3D; null）说明队列中没有可取出的消息，让nextPollTimeoutMillis 等于-1让线程一直阻塞，等待新消息到来时唤醒它。</p>
<p>5，如果【待取出消息指针】可用（msg !&#x3D; null）再判断一下消息的待处理时间。</p>
<ul>
<li>如果消息的待处理时间大于当前时间（now &lt; msg.when）说明当前消息还没到要处理的时间，让线程阻塞到消息待处理的指定时间。</li>
<li>如果消息的待处理时间小于当前时间（now &gt; msg.when）就直接从队列中取出消息返回给调用处。（此处会直接结束整个循环，结束next()方法。）</li>
</ul>
<p>6，如果队列已经退出了直接结束next()方法。</p>
<p>7，如果是第一次循环就初始化IdleHandler数量的局部变量pendingIdleHandlerCount 。</p>
<p>8，如果IdleHandler数量小于等于0说明没有合适的IdleHandler，直接进入下次循环阻塞线程。（此处会直接结束本次循环。）</p>
<p>9，初始化IdleHandler数组，里面保存着本地待处理的IdleHandler。</p>
<p>10，遍历IdleHandler数组，执行对应的queueIdle()方法。</p>
<p>11，执行完所有IdleHandler之后，将IdleHandler数量清0。</p>
<p>12，因为执行了IdleHandler的代码块，有可能已经有新的消息入队了， 所以让nextPollTimeoutMillis 等于0不阻塞线程，直接去查看有没有新消息。</p>
<p>13，本次循环结束，开始新一轮循环。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>MessageQueue队列消息是有序的，按消息待处理时间依次排序。</li>
<li>同步拦截器可以拦截它之后的所有同步消息，直到这个拦截器被移除。</li>
<li>取出消息时如果没有合适的消息线程会阻塞</li>
</ol>
<h2 id="Handler机制实现原理（三）Looper的源码分析"><a href="#Handler机制实现原理（三）Looper的源码分析" class="headerlink" title="Handler机制实现原理（三）Looper的源码分析"></a>Handler机制实现原理（三）Looper的源码分析</h2><blockquote>
<p>刚看源码的时候：“这TM写的是啥？那写的又TM是啥？”<br>研究明白了之后：“奥，原来就这点玩意儿啊，太简单了。”</p>
</blockquote>
<p>Looper的职责很单一，就是单纯的从MessageQueue中取出消息分发给消息对应的宿主Handler，因此它的代码不多（300行左右）。</p>
<p>Looper是线程独立的且每个线程只能存在一个Looper。</p>
<p>Looper会根据自己的存活情况来创建和退出属于它自己的MessageQueue。</p>
<h3 id="创建与退出Looper"><a href="#创建与退出Looper" class="headerlink" title="创建与退出Looper"></a>创建与退出Looper</h3><p>上面的结论中提到了Looper是线程独立的且每个线程只能存在一个Looper。所以构造Looper实例的方法类似于单例模式。隐藏构造方法,对外提供了两个指定的获取实例方法<code>prepare()</code>和<code>prepareMainLooper()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用主线程（UI线程）Looper实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker线程Looper实例，用ThreadLocal保存的对象都是线程独立的</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Looper&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与当前Looper对应的消息队列</span></span><br><span class="line"><span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前Looper所以的线程</span></span><br><span class="line"><span class="keyword">final</span> Thread mThread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对外公开初始化方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在普通线程中初始化Looper调用此方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化一个可以退出的Looper</span></span><br><span class="line">    prepare(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对外公开初始化方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在应用主线程（UI线程）中初始化Looper调用此方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepareMainLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为是主线程，初始化一个不允许退出的Looper</span></span><br><span class="line">    prepare(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="comment">// 如果sMainLooper不等于空说明已经创建过主线程Looper了，不应该重复创建</span></span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内部私有初始化方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> quitAllowed 是否允许退出Looper</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    <span class="comment">// 每个线程只能有一个Looper</span></span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存实例</span></span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有构造方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> quitAllowed 是否允许退出Looper</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化MessageQueue</span></span><br><span class="line">    mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);</span><br><span class="line">    <span class="comment">// 得到当前线程实例</span></span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正创建Looper实例的构造方法中其实很简单，就是创建了对应的MessageQueue实例，然后得到当前线程，值得注意的是MessageQueue和线程实例都是被<code>final</code>关键字修饰的，只能被赋值一次。</p>
<p>对外公开初始化方法<code>prepareMainLooper()</code>是为应用主线程（UI线程）准备的，应用刚被创建就会调用该方法，所以我们不该再去调用它。</p>
<p>开发者可以通过调用对外公开初始化方法<code>prepare()</code>对自己的worker线程创建Looper，但是要注意只能初始化一次。</p>
<p>调用<code>Looper.prepare()</code>方法初始化完成后，可以调用<code>myLooper()</code>和<code>myQueue()</code>方法得到当前线程对应的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> Looper <span class="title function_">myLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@NonNull</span> MessageQueue <span class="title function_">myQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> myLooper().mQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>退出Looper</strong></p>
<p>退出Looper有安全与不安全两种退出方法，其实对应的就是MessageQueue的安全与不安全方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mQueue.<span class="built_in">quit</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mQueue.<span class="built_in">quit</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么安全退出，什么是不安全退出，在MessageQueue源码中分析过。</p>
<h3 id="运行Looper处理消息"><a href="#运行Looper处理消息" class="headerlink" title="运行Looper处理消息"></a>运行Looper处理消息</h3><p>调用<code>Looper.prepare()</code>方法初始化完成Looper后就可以让Looper去工作了，只需要调用<code>Looper.loop()</code>方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 得到当前线程下的Looper</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还没初始化过抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 得到当前线程下与Looper对应的消息队列</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> me.mQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到当前线程的唯一标识（uid+pid），作用是下面每次循环都判断一下线程有没有被切换</span></span><br><span class="line">    <span class="comment">// 不知道为什么要调用两次该方法</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ident</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入死循环不断取出消息</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从队列中取出一个消息，这可能会阻塞线程</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> queue.next(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果消息是空的，说明队列已经退出了，直接结束循环，结束方法</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印日志</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Printer</span> <span class="variable">logging</span> <span class="operator">=</span> me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                    msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 性能分析相关的东西</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">traceTag</span> <span class="operator">=</span> me.mTraceTag;</span><br><span class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//尝试将消息分发给宿主（Handler）</span></span><br><span class="line">            <span class="comment">//dispatchMessage为宿主Handler的接收消息方法</span></span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             <span class="comment">// 性能分析相关的东西</span></span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印日志</span></span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到当前线程的唯一标识</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">newIdent</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果本次循环所在的线程与最开始不一样，打印日志记录</span></span><br><span class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">&quot;Thread identity changed from 0x&quot;</span></span><br><span class="line">                    + Long.toHexString(ident) + <span class="string">&quot; to 0x&quot;</span></span><br><span class="line">                    + Long.toHexString(newIdent) + <span class="string">&quot; while dispatching to &quot;</span></span><br><span class="line">                    + msg.target.getClass().getName() + <span class="string">&quot; &quot;</span></span><br><span class="line">                    + msg.callback + <span class="string">&quot; what=&quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//消息分发完毕，回收消息到缓存池</span></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Looper的功能很简单，核心方法<code>Looper.loop()</code>就是不断的从消息队列中取出消息分发给对应的宿主Handler，它与对应MessageQueue息息相关，一起创建，一起退出。</p>
<p>Looper更想强调的是线程的独立性与唯一性，利用<code>ThreadLocal</code>保证每个线程只有一个Looper实例的存在。利用静态构造实例方法保证不能重复创建Looper。</p>
<p><code>Looper.prepareMainLooper()</code>是比较特殊的方法，它是给UI线程准备，理论上开发者在任何情况下都不应该调用它。</p>
<h2 id="Handler机制实现原理（四）handler的源码分析"><a href="#Handler机制实现原理（四）handler的源码分析" class="headerlink" title="Handler机制实现原理（四）handler的源码分析"></a>Handler机制实现原理（四）handler的源码分析</h2><p>Handler本身可在多线程之间调用，不管它在哪个线程发送消息，都会回到它被初始化的哪个线程中接收到消息。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>Handler有<strong>7个</strong>构造方法，分别对应不同的参数来初始化不同的Handler属性，但是真正完成初始化操作的只有两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否需要查找潜在的漏洞</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">FIND_POTENTIAL_LEAKS</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将Callback接口作为构造方法参数，可以用作接收消息的回调</span></span><br><span class="line"><span class="comment"> * 这样就可以省去自己重写Handler自身的handleMessage方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg 接收到的消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否需要进一步处理，即调用Handler自身的handleMessage方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Looper mLooper;</span><br><span class="line"><span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line"><span class="keyword">final</span> Callback mCallback;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送的消息是否为异步的，默认是false</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> mAsynchronous;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span> 隐藏的构造方法，外部不可见</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(Callback callback, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否存在内存泄漏的可能</span></span><br><span class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Handler</span>&gt; klass = getClass();</span><br><span class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到当前线程的Looper</span></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果Looper还没初始化抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到当前线程的MessageQueue</span></span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(Looper looper, Callback callback, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码的得知，构造方法初始化的工作就是给<code>mLooper</code>,<code>mQueue</code>,<code>mCallback</code>和<code>mAsynchronous</code>这几个关键的属性赋值.<code>mLooper</code>和<code>mQueue</code>自然就是当前线程下的Looper和MessageQueue了，如果传递了Looper参数就直接赋值，如果没传递就调用<code>Looper.myLooper();</code>得到当前线程的Looper。</p>
<p><code>mCallback</code>是Handler内部定义的一个简单接口，其目的是为了<strong>替代传统的接收消息方法</strong>。当然使用<code>mCallback</code>的同时并不会影响正常的Handler消息分发。此处解释从后面接收消息时的逻辑就可以看到。</p>
<p><code>mAsynchronous</code>的意思是<strong>该Handler发送的消息是否是异步的</strong>，从前面Message源码的文章中我们知道Message中有一个设置消息是否为异步消息的方法，MessageQueue对异步消息的处理也与同步消息不同。此处如果设置了<code>mAsynchronous</code>为<code>true</code>，那么这个Handler发送的所有消息就都是异步消息。</p>
<p>在有两个参数的构造方法中我们会发现有一段检查是否存在内存泄漏的代码，为什么会这样呢？在分析完发送消息和接收消息后再说这个。</p>
<p>当然，除了上面两个构造方法外还有其它几个构造方法，但均是调用上面两个方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span>()</span> &#123;</span><br><span class="line">     <span class="keyword">this</span>(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Handler</span>(<span class="params">Callback callback</span>)</span> &#123;</span><br><span class="line">     <span class="keyword">this</span>(callback, <span class="literal">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Handler</span>(<span class="params">Looper looper</span>)</span> &#123;</span><br><span class="line">     <span class="keyword">this</span>(looper, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Handler</span>(<span class="params">Looper looper, Callback callback</span>)</span> &#123;</span><br><span class="line">     <span class="keyword">this</span>(looper, callback, <span class="literal">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @hide 隐藏的构造方法，外部不可见</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Handler</span>(<span class="params">boolean <span class="keyword">async</span></span>)</span> &#123;</span><br><span class="line">     <span class="keyword">this</span>(<span class="literal">null</span>, <span class="keyword">async</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>使用Handler发送消息时我们知道它分为两类：</p>
<ul>
<li><code>postXXX()</code>方法切换回原线程。</li>
<li><code>sendMessageXXX()</code>方法发送消息到原线程。</li>
</ul>
<p>其实这两种方法本质都是发送一个Message对象到原线程，只不过<code>PostXXX()</code>方法是发送了一个只有<code>Runnable callback</code>属性的Message对象。</p>
<p>先来看一下<code>sendMessageXXX()</code>类的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送一条普通消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessage</span><span class="params">(Message msg)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送一条空消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendEmptyMessage</span><span class="params">(<span class="type">int</span> what)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendEmptyMessageDelayed(what, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送一条空的延时消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendEmptyMessageDelayed</span><span class="params">(<span class="type">int</span> what, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">    msg.what = what;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送一条空的定时消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendEmptyMessageAtTime</span><span class="params">(<span class="type">int</span> what, <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">    msg.what = what;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送一个普通的延时消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessageDelayed</span><span class="params">(Message msg, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送一个普通的定时消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMessageAtTime</span><span class="params">(Message msg, <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    <span class="comment">//得到消息队列</span></span><br><span class="line">    <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> mQueue;</span><br><span class="line">    <span class="comment">// 如果消息队列是空的记录日志然后结束方法</span></span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                <span class="built_in">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行消息入队操作</span></span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中发现，不管调用何种发送消息的方法，最后真正调用的都是<code>sendMessageAtTime()</code>方法。而真正发送的核心方法也就是入队方法是Handler的<code>enqueueMessage()</code>方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> boolean <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="type">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将消息的宿主设置为当前Handler自身</span></span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果Handler被设置成了异步就把消息也设置成异步的</span></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.<span class="built_in">setAsynchronous</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行消息队列的入队操作</span></span><br><span class="line">    <span class="keyword">return</span> queue.<span class="built_in">enqueueMessage</span>(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里终于明白了为啥Looper和MessageQueue一直在使用Message的<code>target</code>属性而我们却从来没有给它赋值过，是Handler在发送消息前自己赋值上去的。</p>
<p>看完了发送消息类的方法在看看切换线程类的方法干了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title function_">getPostMessage</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title function_">getPostMessage</span><span class="params">(Runnable r, Object token)</span> &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">    m.obj = token;</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">post</span><span class="params">(Runnable r)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">postAtTime</span><span class="params">(Runnable r, <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(getPostMessage(r), uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">postAtTime</span><span class="params">(Runnable r, Object token, <span class="type">long</span> uptimeMillis)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(getPostMessage(r, token), uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">postDelayed</span><span class="params">(Runnable r, <span class="type">long</span> delayMillis)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">postAtFrontOfQueue</span><span class="params">(Runnable r)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtFrontOfQueue(getPostMessage(r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上本节开头讲的一样，<code>postXXX()</code>类方法就是构造了一个只有<code>Runnable callback</code>的Message对象，然后走正常发送消息的方法。唯一有一个特例就是<code>postAtFrontOfQueue()</code>方法，它调用了<code>sendMessageAtFrontOfQueue()</code>方法是之前发送消息没有用到过的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> boolean <span class="title">sendMessageAtFrontOfQueue</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == null) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> <span class="built_in">RuntimeException</span>(</span><br><span class="line">            <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.<span class="built_in">w</span>(<span class="string">&quot;Looper&quot;</span>, e.<span class="built_in">getMessage</span>(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">enqueueMessage</span>(queue, msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来这个方法特殊的地方就是在入队的时候时间参数为0，我们在MessageQueue源码知道如果入队消息的时间参数为0那么这个消息会被直接放在队列头。所以，<code>postAtFrontOfQueue()</code>方法就是直接在消息队列头部插入了一个消息。</p>
<h3 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h3><p>在Looper 的源码中我们知道每当从MessageQueue中取出一个消息时就会调用这个消息的宿主<code>target</code>中分发消息的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Looper分发消息</span></span><br><span class="line">msg.target.<span class="built_in">dispatchMessage</span>(msg);</span><br></pre></td></tr></table></figure>

<p>而这个宿主<code>target</code>也就是我们的Handler，所有Handler接收消息就是在这个<code>dispatchMessage()</code>方法中了：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span>(<span class="params">Message msg</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果Message的callback不为空，说明它是一个通过postXXX()方法发送的消息</span></span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 直接运行这个callback</span></span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果mCallback 不为空说明Handler设置了Callback接口</span></span><br><span class="line">        <span class="comment">// 先执行接口处理消息的方法</span></span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果callback接口处理完消息返回true说明它将消息拦截</span></span><br><span class="line">            <span class="comment">// 不再执行Handler自身的处理消息方法，直接结束方法</span></span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用Handler自身处理消息的方法</span></span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span>(<span class="params">Message message</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 运行callback，也就是这个Runnable接口</span></span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handler自身处理消息的方法，开发者需要重新该方法来实现接收消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span>(<span class="params">Message msg</span>)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可见，如果是单纯的<code>PostXXX()</code>方法发送的消息，Handler接收到了之后直接运行Message对象的Runnable接口，不会将它当做一个消息进行处理。</p>
<p>而我们的<code>mCallback</code>接口是完全可以替代Handler自身接收消息的方法，因为其高优先处理等级，它甚至可以选择拦截掉Handler自身的接收消息方法。</p>
<h3 id="内存泄漏的可能"><a href="#内存泄漏的可能" class="headerlink" title="内存泄漏的可能"></a>内存泄漏的可能</h3><p>我们在使用Handler的时候写法一般如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于重写了<code>handleMessage()</code>方法相当于生成了一个匿名内部类，也就相当于如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyHandler</span> ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可是你有没有想过内部类凭什么能够调用外部类的属性和方法呢？答案就是内部类隐式的持有着外部类的引用，编译器在创建内部类时把外部类的引用传入了其中，只不过是你看不到而已。</p>
<p>既然Handler作为内部类持有着外部类（多数情况为Activity）的引用，而Handler对应的一般都是耗时操作。当我们在子线程执行一项耗时操作时，用户退出程序，Activity需要被销毁，而Handler还在持有Activity的引用导致无法回收，就会引发内存泄漏。</p>
<p><strong>解决方法分为两步</strong></p>
<ol>
<li>生成内部类时把内部类声明为静态的。</li>
<li>使用弱引用来持有外部类引用。</li>
</ol>
<p>静态内部类不会持有外部类的引用，且弱引用不会阻止JVM回收对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;</span><br><span class="line"></span><br><span class="line">    WeakReference&lt;Activity&gt; mActivity ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyHandler</span><span class="params">(Activity activity)</span>&#123;</span><br><span class="line">        mActivity = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Activity&gt;(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="type">Activity</span> <span class="variable">activity</span> <span class="operator">=</span> mActivity.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (activity == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，在文章刚开始初始化方法中检查漏洞的代码其实就是检查这个内存泄漏的可能性：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查是否存在内存泄漏的可能</span></span><br><span class="line"><span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;? <span class="keyword">extends</span> Handler&gt; klass = getClass();</span><br><span class="line">    <span class="comment">// 是否为匿名类，内部类以及是否为静态类</span></span><br><span class="line">    <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">            (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class="line">            klass.getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大功告成，完美！</p>
<h2 id="Handler机制实现原理（五）总结"><a href="#Handler机制实现原理（五）总结" class="headerlink" title="Handler机制实现原理（五）总结"></a>Handler机制实现原理（五）总结</h2><h3 id="Message缓存池"><a href="#Message缓存池" class="headerlink" title="Message缓存池"></a>Message缓存池</h3><p>Android 的工程师们充分利用了Java的高级语言特性，即类中持有着一个类自身的属性作为经典数据结构中的链表<code>next</code>指针，以静态属性属于类本身的特性实现了链表的表头。这种模式给我了很大的启发，让我这种渣渣每逢想起都会惊讶“还有这种操作？”。</p>
<p><strong>为什么要有缓存池</strong></p>
<p>了解完Handler整体机制后我猜测，Message功能十分单一且状态很少，它只是一个具体发送消息的载体，但是使用数量十分庞大，回收用过的Message不仅可以有效的减少重复消耗系统资源且回收它的成本很低，所以何乐而不为呢？</p>
<p><strong>谁负责回收Message</strong></p>
<p>我们使用Message时候知道调用<code>Message.obtain();</code>方法可以从缓存池中取出一个Message，有存才能有取，我们什么时候回收它呢？从源码中发现，Looper在分发Message给宿主Handler之后，确定了Message已经完成了它的使命直接就会将它回收。所以我们完全不用担心这个，我们发送的每个消息最后都会被回收。</p>
<h3 id="真正的阻塞发生在MessageQueue"><a href="#真正的阻塞发生在MessageQueue" class="headerlink" title="真正的阻塞发生在MessageQueue"></a>真正的阻塞发生在MessageQueue</h3><p>MessageQueue维持的消息队列也是靠跟Message缓存池同样的原理生成的，每次消息出队时如果没有合适的待取出消息就会阻塞线程等待有合适的消息。</p>
<p>非常奇怪的是，MessageQueue线程的方式不是传统使用java实现的，而是通过JNI调用native层的C++代码实现的，C++代码中也实现了一套Looper+MessageQueue+Handler，阻塞线程的方式是调用Linux的监听文件描述符ePoll实现的。</p>
<p>我的猜测是因为Java代码需要经过JVM的帮助才能跟系统接触，这一过程会消耗性能，而C++代码则直接可以绕过这一个环节。所以，使用C++代码实现线程阻塞可能是性能上的需求。</p>
<h3 id="为什么推荐使用Handler实现线程间通信"><a href="#为什么推荐使用Handler实现线程间通信" class="headerlink" title="为什么推荐使用Handler实现线程间通信"></a>为什么推荐使用Handler实现线程间通信</h3><p>在没有真正了解Handler的时候以为Google的工程师们在Handler上使用了什么了不起的技术呢，所以才推荐开发者们使用Handler来实现线程间通信。</p>
<p>其实呢？Android是事件型驱动的系统，刚创建一个应用程序的主线程里就会被创建一个Looper来不断接受各种事件，所以说如果我们打开一个程序什么都不操作，这个程序就有可能是阻塞状态的，因为他没有任何事件需要去处理。反之，我们在自己的UI线程里执行一项耗时操作，主线程Looper一直在处理这个任务而无法分身处理其它的事件这时候就有可能ANR了。</p>
<p>所以，不是Handler的技术多牛逼，是主线程用了Handler来通信，你是用别的方法通信有可能会影响主线程Looper的正常工作。</p>
<h1 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h1><h2 id="Binder原理（一）学习Binder前必须要了解的知识点"><a href="#Binder原理（一）学习Binder前必须要了解的知识点" class="headerlink" title="Binder原理（一）学习Binder前必须要了解的知识点"></a>Binder原理（一）学习Binder前必须要了解的知识点</h2><p>Binder原理是掌握系统底层原理的基石，也是进阶高级工程师的必备知识点，这篇文章不会过多介绍Binder原理，而是讲解学习Binder前需要的掌握的知识点。</p>
<h3 id="Linux和Android的IPC机制种类"><a href="#Linux和Android的IPC机制种类" class="headerlink" title="Linux和Android的IPC机制种类"></a>Linux和Android的IPC机制种类</h3><p>IPC全名为inter-Process Communication，含义为进程间通信，是指两个进程之间进行数据交换的过程。在Android和Linux中都有各自的IPC机制，这里分别来介绍下。</p>
<h4 id="Linux中的IPC机制种类"><a href="#Linux中的IPC机制种类" class="headerlink" title="Linux中的IPC机制种类"></a>Linux中的IPC机制种类</h4><p>Linux中提供了很多进程间通信机制，主要有管道（pipe）、信号（sinal）、信号量（semophore）、消息队列（Message）、共享内存（Share Memory)、套接字（Socket）等。</p>
<p><strong>管道</strong><br>管道是Linux由Unix那里继承过来的进程间的通信机制，它是Unix早期的一个重要通信机制。管道的主要思想是，在内存中创建一个共享文件，从而使通信双方利用这个共享文件来传递信息。这个共享文件比较特殊，它不属于文件系统并且只存在于内存中。另外还有一点，管道采用的是半双工通信方式的，数据只能在一个方向上流动。<br>简单的模型如下所示。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMC8yNC8xNmRmOTZhOWE3YzEwMTM5?x-oss-process=image/format,png" alt="nbXJ2T.png"></p>
<p><strong>信号</strong><br>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，进程不必通过任何操作来等待信号的到达。信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件。信号不适用于信息交换，比较适用于进程中断控制。<br><strong>信号量</strong><br>信号量是一个计数器，用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。主要作为进程间以及同一进程内不同线程之间的同步手段。<br><strong>消息队列</strong><br>消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识，并且允许一个或多个进程向它写入与读取消息。信息会复制两次，因此对于频繁或者信息量大的通信不宜使用消息队列。</p>
<p><strong>共享内存</strong><br>多个进程可以直接读写的一块内存空间，是针对其他通信机制运行效率较低而设计的。<br>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大的提高效率。</p>
<p><strong>套接字</strong><br>套接字是更为基础的进程间通信机制，与其他方式不同的是，套接字可用于不同机器之间的进程间通信。</p>
<h4 id="Android中的IPC机制"><a href="#Android中的IPC机制" class="headerlink" title="Android中的IPC机制"></a>Android中的IPC机制</h4><p>Android系统是基于Linux内核的，在Linux内核基础上，又拓展出了一些IPC机制。Android系统除了支持套接字，还支持序列化、Messenger、AIDL、Bundle、文件共享、ContentProvider、Binder等。Binder会在后面介绍，先来了解前面的IPC机制。<br><strong>序列化</strong><br>序列化指的是Serializable&#x2F;Parcelable，Serializable是Java提供的一个序列化接口，是一个空接口，为对象提供标准的序列化和反序列化操作。Parcelable接口是Android中的序列化方式，更适合在Android平台上使用，用起来比较麻烦，效率很高。<br><strong>Messenger</strong><br>Messenger在Android应用开发中的使用频率不高，可以在不同进程中传递Message对象，在Message中加入我们想要传的数据就可以在进程间的进行数据传递了。Messenger是一种轻量级的IPC方案并对AIDL进行了封装。</p>
<p><strong>AIDL</strong><br>AIDL全名为Android interface definition Language，即Android接口定义语言。Messenger是以串行的方式来处理客户端发来的信息，如果有大量的消息发到服务端，服务端仍然一个一个的处理再响应客户端显然是不合适的。另外还有一点，Messenger用来进程间进行数据传递但是却不能满足跨进程的方法调用，这个时候就需要使用AIDL了。</p>
<p><strong>Bundle</strong><br>Bundle实现了Parcelable接口，所以它可以方便的在不同的进程间传输。Acitivity、Service、Receiver都是在Intent中通过Bundle来进行数据传递。</p>
<p><strong>文件共享</strong><br>两个进程通过读写同一个文件来进行数据共享，共享的文件可以是文本、XML、JOSN。文件共享适用于对数据同步要求不高的进程间通信。</p>
<p><strong>ContentProvider</strong><br>ContentProvider为存储和获取数据了提供统一的接口，它可以在不同的应用程序之间共享数据，本身就是适合进程间通信的。ContentProvider底层实现也是Binder，但是使用起来比AIDL要容易许多。系统中很多操作都采用了ContentProvider，例如通讯录，音视频等，这些操作本身就是跨进程进行通信。</p>
<h3 id="Linux和Binder的IPC通信原理"><a href="#Linux和Binder的IPC通信原理" class="headerlink" title="Linux和Binder的IPC通信原理"></a>Linux和Binder的IPC通信原理</h3><p>在讲到Linux的进程通信原理之前，我们需要先了解Liunx中的几个概念。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMC8yNC8xNmRmOTZhOTkzODU1MzY2?x-oss-process=image/format,png" alt="njr0qU.png"></p>
<p><strong>内核空间和用户空间</strong><br>当我们接触到Liunx时，免不了听到两个词，User space（用户空间）和 Kernel space（内核空间），那么它们的含义是什么呢？<br>为了保护用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间和内核空间。Linux 操作系统将最高的1GB字节供内核使用，称为内核空间，较低的3GB 字节供各进程使用，称为用户空间。</p>
<p>内核空间是Linux内核的运行空间，用户空间是用户程序的运行空间。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不会受到影响。内核空间的数据是可以进程间共享的，而用户空间则不可以。比如在上图进程A的用户空间是不能和进程B的用户空间共享的。</p>
<p><strong>进程隔离</strong><br>进程隔离指的是，一个进程不能直接操作或者访问另一个进程。也就是进程A不可以直接访问进程B的数据。</p>
<p><strong>系统调用</strong><br>用户空间需要访问内核空间，就需要借助系统调用来实现。系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性。</p>
<p>进程A和进程B的用户空间可以通过如下系统函数和内核空间进行交互。</p>
<ul>
<li>copy_from_user：将用户空间的数据拷贝到内核空间。</li>
<li>copy_to_user：将内核空间的数据拷贝到用户空间。</li>
</ul>
<p><strong>内存映射</strong><br>由于应用程序不能直接操作设备硬件地址，所以操作系统提供了一种机制：内存映射，把设备地址映射到进程虚拟内存区。<br>举个例子，如果用户空间需要读取磁盘的文件，如果不采用内存映射，那么就需要在内核空间建立一个页缓存，页缓存去拷贝磁盘上的文件，然后用户空间拷贝页缓存的文件，这就需要两次拷贝。<br>采用内存映射，如下图所示。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMC8yNC8xNmRmOTZhOTZjOWFjOGY5?x-oss-process=image/format,png" alt="nzlnaV.png"><br>由于新建了虚拟内存区域，那么磁盘文件和虚拟内存区域就可以直接映射，少了一次拷贝。</p>
<p>内存映射全名为Memory Map，在Linux中通过系统调用函数mmap来实现内存映射。将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间，反之亦然。内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。</p>
<h4 id="Linux的IPC通信原理"><a href="#Linux的IPC通信原理" class="headerlink" title="Linux的IPC通信原理"></a>Linux的IPC通信原理</h4><p>了解Liunx中的几个概念后，就可以学习Linux的IPC通信原理了，如下图所示。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMC8yNC8xNmRmOTZhOTkzMDVhNTZm?x-oss-process=image/format,png" alt="nzaypq.png"><br>内核程序在内核空间分配内存并开辟一块内核缓存区，发送进程通过copy_from_user函数将数据拷贝到到内核空间的缓冲区中。同样的，接收进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 copy_to_user() 函数将数据从内核缓存区拷贝到接收进程。这样数据发送进程和数据接收进程完成了一次数据传输，也就是一次进程间通信。</p>
<p>Linux的IPC通信原理有两个问题：</p>
<ol>
<li>一次数据传递需要经历：用户空间 –&gt; 内核缓存区 –&gt; 用户空间，需要2次数据拷贝，这样效率不高。</li>
<li>接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用API接收消息头来获取消息体的大小，浪费了空间或者时间。</li>
</ol>
<h4 id="Binder的通信原理"><a href="#Binder的通信原理" class="headerlink" title="Binder的通信原理"></a>Binder的通信原理</h4><p>Binder是基于开源的OpenBinder实现的，OpenBinder最早并不是由Google公司开发的，而是Be Inc公司开发的，接着由Palm, Inc.公司负责开发。后来OpenBinder的作者Dianne Hackborn加入了Google公司，并负责Android平台的开发工作，顺便把这项技术也带进了Android。</p>
<p>Binder是基于内存映射来实现的，在前面我们知道内存映射通常是用在有物理介质的文件系统上的，Binder没有物理介质，它使用内存映射是为了跨进程传递数据。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMC8yNC8xNmRmOTZhOTc5NTU4NjEy?x-oss-process=image/format,png" alt="nzNJUA.png"></p>
<p>Binder通信的步骤如下所示。<br>1.Binder驱动在内核空间创建一个数据接收缓存区。<br>2.在内核空间开辟一块内核缓存区，建立内核缓存区和数据接收缓存区之间的映射关系，以及数据接收缓存区和接收进程用户空间地址的映射关系。<br>3.发送方进程通过copy_from_user()函数将数据拷贝 到内核中的内核缓存区，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。</p>
<p>整个过程只使用了1次拷贝，不会因为不知道数据的大小而浪费空间或者时间，效率更高。</p>
<h3 id="为什么要使用Binder"><a href="#为什么要使用Binder" class="headerlink" title="为什么要使用Binder"></a>为什么要使用Binder</h3><p>Android是基于Linux内核的 ，Linux提供了很多IPC机制，而Android却自己设计了Binder来进行通信，主要是因为以下几点。<br><strong>性能方面</strong><br>性能方面主要影响的因素是拷贝次数，管道、消息队列、Socket的拷贝次书都是两次，性能不是很好，共享内存不需要拷贝，性能最好，Binder的拷贝次书为1次，性能仅次于内存拷贝。<br><strong>稳定性方面</strong><br>Binder是基于C&#x2F;S架构的，这个架构通常采用两层结构，在技术上已经很成熟了，稳定性是没有问题的。共享内存没有分层，难以控制，并发同步访问临界资源时，可能还会产生死锁。从稳定性的角度讲，Binder是优于共享内存的。<br><strong>安全方面</strong><br>Android是一个开源的系统，并且拥有开放性的平台，市场上应用来源很广，因此安全性对于Android 平台而言极其重要。<br>传统的IPC接收方无法获得对方可靠的进程用户ID&#x2F;进程ID（UID&#x2F;PID），无法鉴别对方身份。Android 为每个安装好的APP分配了自己的UID，通过进程的UID来鉴别进程身份。另外，Android系统中的Server端会判断UID&#x2F;PID是否满足访问权限，而对外只暴露Client端，加强了系统的安全性。<br><strong>语言方面</strong><br>Linux是基于C语言，C语言是面向过程的，Android应用层和Java Framework是基于Java语言，Java语言是面向对象的。Binder本身符合面向对象的思想，因此作为Android的通信机制更合适不过。</p>
<p>从这四方面来看，Linux提供的大部分IPC机制根本无法和Binder相比较，而共享内存只在性能方面优于Binder，其他方面都劣于Binder，这些就是为什么Android要使用Binder来进行进程间通信，当然系统中并不是所有的进程通信都是采用了Binder，而是根据场景选择最合适的，比如Zygote进程与AMS通信使用的是Socket，Kill Process采用的是信号。</p>
<h3 id="为什么要学习Binder"><a href="#为什么要学习Binder" class="headerlink" title="为什么要学习Binder?"></a>为什么要学习Binder?</h3><p>Binder机制在Android中的地位举足轻重，我们需要掌握的很多原理都和Binder有关：</p>
<ol>
<li>系统中的各个进程是如何通信的？</li>
<li>Android系统启动过程</li>
<li>AMS、PMS的原理</li>
<li>四大组件的原理，比如Activity是如何启动的？</li>
<li>插件化原理</li>
<li>系统服务的Client端和Server端是如何通信的？（比如MediaPlayer和MeidaPlayerService)</li>
</ol>
<p>上面只是列了一小部分，简单来说说，比如系统在启动时，SystemServer进程启动后会创建Binder线程池，目的是通过Binder，使得在SystemServer进程中的服务可以和其他进程进行通信了。再比如我们常说的AMS、PMS都是基于Binder来实现的，拿PMS来说，PMS运行在SystemServer进程，如果它想要和DefaultContainerService通信（是用于检查和复制可移动文件的系统服务），就需要通过Binder，因为DefaultContainerService运行在com.android.defcontainer进程。<br>还有一个比较常见的C&#x2F;S架构间通信的问题，Client端的MediaPlayer和Server端的MeidaPlayerService不是运行在一个进程中的，同样需要Binder来实现通信。</p>
<p>可以说Binder机制是掌握系统底层原理的基石。根据Android系统的分层，Binder机制主要分为以下几个部分。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMC8yNC8xNmRmOTZhOTgwOTk0NjVj?x-oss-process=image/format,png" alt="n5i5PP.png"></p>
<p>上图并没有给出Binder机制的具体的细节，而是先给出了一个概念，根据系统的Android系统的分层，我将Binder机制分为了Java Binder、Native Binder、Kernel Binder，实际上Binder的内容非常多，完全可以写一本来介绍，但是对于应用开发来说，并不需要掌握那么多的知识点，因此本系列主要会讲解Java Binder和Native Binder。</p>
<h2 id="Binder原理（二）ServiceManager中的Binder机制"><a href="#Binder原理（二）ServiceManager中的Binder机制" class="headerlink" title="Binder原理（二）ServiceManager中的Binder机制"></a>Binder原理（二）ServiceManager中的Binder机制</h2><p>在上一部分中，我们了解了学习Binder前必须要了解的知识点，其中有一点就是Binder机制的三个部分：Java Binder、Native Binder、Kernel Binder，其中Java Binder和Native Binder都是应用开发需要掌握的。Java Binder是需要借助Native Binder来工作的，因此需要先了解Native Binder，Native Binder架构的原型就是基于Binder通信的C&#x2F;S架构，因此我们先从它开始入手。源码是基于Android 9.0。</p>
<h3 id="基于Binder通信的C-S架构"><a href="#基于Binder通信的C-S架构" class="headerlink" title="基于Binder通信的C&#x2F;S架构"></a>基于Binder通信的C&#x2F;S架构</h3><p>在Android系统中，Binder进程间的通信的使用是很普遍的，在Android进阶三部曲第一部的最后一章，我讲解了MediaPlayer框架，这个框架基于C&#x2F;S架构，并采用Binder来进行进程间通信，如下图所示。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDE5LzA5LzI1L3VaZ1RnSi5wbmc?x-oss-process=image/format,png" alt="uZgTgJ.png"></p>
<p>从图中可以看出，除了常规C&#x2F;S架构的Client端和Server端，还包括了ServiceManager，它用于管理系统中的服务。<br>首先Server进程会注册一些Service到ServiceManager中，Client要使用某个Service，则需要先到ServiceManager查询Service的相关信息，然后根据Service的相关信息与Service所在的Server进程建立通信通路，这样Client就可以使用Service了。</p>
<h3 id="MediaServer的main函数"><a href="#MediaServer的main函数" class="headerlink" title="MediaServer的main函数"></a>MediaServer的main函数</h3><p>Client、Server、ServiceManager三者的交互都是基于Binder通信的，那么任意两者的交互都可以说明Binder的通信的原理，可以说Native Binder的原理的核心就是ServiceManager的原理，为了更好的了解ServiceManager，这里拿MediaPlayer框架来举例，它也是学习多媒体时必须要掌握的知识点。</p>
<p>MediaPlayer框架的简单框架图如下所示。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDE5LzA5LzI3L3VNZWdNai5wbmc?x-oss-process=image/format,png" alt="uMegMj.png"><br>可以看到，MediaPlayer和MediaPlayerService是通过Binder来进行通信的，MediaPlayer是Client端，MediaPlayerService是Server端，MediaPlayerService是系统多媒体服务的一种，系统多媒体服务是由一个叫做MediaServer的服务进程提供的，它是一个可执行程序，在Android系统启动时，MediaServer也被启动，它的入口函数如下所示。<br><strong>frameworks&#x2F;av&#x2F;media&#x2F;mediaserver&#x2F;main_mediaserver.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc __unused, <span class="type">char</span> **argv __unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGPIPE, SIG_IGN);</span><br><span class="line">    <span class="comment">//获取ProcessState实例</span></span><br><span class="line">    <span class="function">sp&lt;ProcessState&gt; <span class="title">proc</span><span class="params">(ProcessState::self())</span></span>;<span class="comment">//1</span></span><br><span class="line">    <span class="function">sp&lt;IServiceManager&gt; <span class="title">sm</span><span class="params">(defaultServiceManager())</span></span>;<span class="comment">//2</span></span><br><span class="line">    <span class="built_in">ALOGI</span>(<span class="string">&quot;ServiceManager: %p&quot;</span>, sm.<span class="built_in">get</span>());</span><br><span class="line">    <span class="built_in">InitializeIcuOrDie</span>();</span><br><span class="line">    <span class="comment">//注册MediaPlayerService</span></span><br><span class="line">    MediaPlayerService::<span class="built_in">instantiate</span>();<span class="comment">//3</span></span><br><span class="line">    ResourceManagerService::<span class="built_in">instantiate</span>();</span><br><span class="line">    <span class="built_in">registerExtensions</span>();</span><br><span class="line">    <span class="comment">//启动Binder线程池</span></span><br><span class="line">    ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">startThreadPool</span>();</span><br><span class="line">    <span class="comment">//当前线程加入到线程池</span></span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">joinThreadPool</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处用于获取ProcessState实例，在这一过程中会打开&#x2F;dev&#x2F;binder设备，并使用mmap为Binder驱动分配一个虚拟地址空间用来接收数据。<br>注释2处用来得到一个IServiceManager，通过这个IServiceManager，其他进程就可以和当前的ServiceManager进行交互，这里就用到了Binder通信。<br>注释3处用来注册MediaPlayerService。<br>除了注释3处的知识点在下一篇文章进行介绍，注释1和注释2处的内容，本篇文章会分别来进行介绍，先看ProcessState实例。</p>
<h3 id="每个进程唯一的ProcessState"><a href="#每个进程唯一的ProcessState" class="headerlink" title="每个进程唯一的ProcessState"></a>每个进程唯一的ProcessState</h3><p>ProcessState从名称就可以看出来，用于代表进程的状态，先来查看上一小节的ProcessState的self函数。<br><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;ProcessState.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;ProcessState&gt; <span class="title">ProcessState::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);</span><br><span class="line">    <span class="keyword">if</span> (gProcess != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> gProcess;</span><br><span class="line">    &#125;</span><br><span class="line">    gProcess = <span class="keyword">new</span> <span class="built_in">ProcessState</span>(<span class="string">&quot;/dev/binder&quot;</span>);<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">return</span> gProcess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里采用了单例模式，确保每个进程只有一个ProcessState实例。注释1处用于创建一个ProcessState实例，参数为&#x2F;dev&#x2F;binder。接着来查看ProcessState的构造函数，代码如下所示。<br><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;ProcessState.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::<span class="built_in">ProcessState</span>(<span class="type">const</span> <span class="type">char</span> *driver)</span><br><span class="line">    : <span class="built_in">mDriverName</span>(<span class="built_in">String8</span>(driver))</span><br><span class="line">    , <span class="built_in">mDriverFD</span>(<span class="built_in">open_driver</span>(driver))<span class="comment">//1</span></span><br><span class="line">    , <span class="built_in">mVMStart</span>(MAP_FAILED)</span><br><span class="line">    , <span class="built_in">mThreadCountLock</span>(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , <span class="built_in">mThreadCountDecrement</span>(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , <span class="built_in">mExecutingThreadsCount</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">mMaxThreads</span>(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , <span class="built_in">mStarvationStartTimeMs</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">mManagesContexts</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">mBinderContextCheckFunc</span>(<span class="literal">NULL</span>)</span><br><span class="line">    , <span class="built_in">mBinderContextUserData</span>(<span class="literal">NULL</span>)</span><br><span class="line">    , <span class="built_in">mThreadPoolStarted</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">mThreadPoolSeq</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mVMStart = <span class="built_in">mmap</span>(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);<span class="comment">//2</span></span><br><span class="line">        <span class="keyword">if</span> (mVMStart == MAP_FAILED) &#123;</span><br><span class="line">            <span class="comment">// *sigh*</span></span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Using %s failed: unable to mmap transaction memory.\n&quot;</span>, mDriverName.<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="built_in">close</span>(mDriverFD);</span><br><span class="line">            mDriverFD = <span class="number">-1</span>;</span><br><span class="line">            mDriverName.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mDriverFD &lt; <span class="number">0</span>, <span class="string">&quot;Binder driver could not be opened.  Terminating.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProcessState的构造函数中调用了很多函数，需要注意的是注释1处，它用来打开&#x2F;dev&#x2F;binder设备。<br>注释2处的mmap函数，它会在内核虚拟地址空间中申请一块与用户虚拟内存相同大小的内存，然后再申请物理内存，将同一块物理内存分别映射到内核虚拟地址空间和用户虚拟内存空间，实现了内核虚拟地址空间和用户虚拟内存空间的数据同步操作，也就是内存映射。<br>mmap函数用于对Binder设备进行内存映射，除了它还有open、ioctl函数，来看看它们做了什么。<br>注释1处的open_driver函数的代码如下所示。<br><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;ProcessState.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">open_driver</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(driver, O_RDWR | O_CLOEXEC);<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">        result = <span class="built_in">ioctl</span>(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);<span class="comment">//2</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Binder ioctl to set max threads failed: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Opening &#x27;%s&#x27; failed: %s\n&quot;</span>, driver, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处用于打开&#x2F;dev&#x2F;binder设备并返回文件操作符fd，这样就可以操作内核的Binder驱动了。注释2处的ioctl函数的作用就是和Binder设备进行参数的传递，这里的ioctl函数用于设定binder支持的最大线程数为15（maxThreads的值为15）。最终open_driver函数返回文件操作符fd。</p>
<p>ProcessState就分析倒这里，总的来说它做了以下几个重要的事：<br>1.打开&#x2F;dev&#x2F;binder设备并设定Binder最大的支持线程数。<br>2.通过mmap为binder分配一块虚拟地址空间，达到内存映射的目的。</p>
<h3 id="ServiceManager中的Binder机制"><a href="#ServiceManager中的Binder机制" class="headerlink" title="ServiceManager中的Binder机制"></a>ServiceManager中的Binder机制</h3><p>回到第一小节的MediaServer的入口函数，在注释2处调用了defaultServiceManager函数。<br><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IServiceManager.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IServiceManager&gt; <span class="title">defaultServiceManager</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (gDefaultServiceManager != <span class="literal">NULL</span>) <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class="line">        <span class="keyword">while</span> (gDefaultServiceManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            gDefaultServiceManager = <span class="built_in">interface_cast</span>&lt;IServiceManager&gt;(</span><br><span class="line">                ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">getContextObject</span>(<span class="literal">NULL</span>));<span class="comment">//1</span></span><br><span class="line">            <span class="keyword">if</span> (gDefaultServiceManager == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从IServiceManager所在的文件路径就可以知道，ServiceManager中不仅仅使用了Binder通信，它自身也是属于Binder体系的。defaultServiceManager中同样使用了单例，注释1处的interface_cast函数生成了gDefaultServiceManager，其内部调用了ProcessState的getContextObject函数，代码如下所示。<br><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;ProcessState.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ProcessState::getContextObject</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*caller*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getStrongProxyForHandle</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ProcessState::getStrongProxyForHandle</span><span class="params">(<span class="type">int32_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    handle_entry* e = <span class="built_in">lookupHandleLocked</span>(handle);<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">NULL</span> || !e-&gt;refs-&gt;<span class="built_in">attemptIncWeak</span>(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handle == <span class="number">0</span>) &#123;</span><br><span class="line">                Parcel data;</span><br><span class="line">                <span class="type">status_t</span> status = IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">transact</span>(</span><br><span class="line">                        <span class="number">0</span>, IBinder::PING_TRANSACTION, data, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (status == DEAD_OBJECT)</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            b = BpBinder::<span class="built_in">create</span>(handle);<span class="comment">//2</span></span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;<span class="built_in">getWeakRefs</span>();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;<span class="built_in">decWeak</span>(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getContextObject函数中直接调用了getStrongProxyForHandle函数，注意它的参数的值为0，那么handle的值就为0，handle是一个资源标识。注释1处查询这个资源标识对应的资源（handle_entry）是否存在，如果不存在就会在注释2处新建BpBinder，并在注释3处赋值给 handle_entry的binder。最终返回的result的值为BpBinder。</p>
<h4 id="BpBinder和BBinder"><a href="#BpBinder和BBinder" class="headerlink" title="BpBinder和BBinder"></a>BpBinder和BBinder</h4><p>说到BpBinder，不得不提到BBinder，它们是Binder通信的“双子星”，都继承了IBinder。BpBinder是Client端与Server交互的代理类，而BBinder则代表了Server端。BpBinder和BBinder是一一对应的，BpBinder会通过handle来找到对应的BBinder。<br>我们知道在ServiceManager中创建了BpBinder，通过handle(值为0)可以找到对应的BBinder。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDE5LzEwLzA1L3VzSWVYUS5wbmc?x-oss-process=image/format,png" alt="usIeXQ.png"></p>
<p>分析完了ProcessState的getContextObject函数，回到interface_cast函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gDefaultServiceManager = <span class="built_in">interface_cast</span>&lt;IServiceManager&gt;(</span><br><span class="line">               ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">getContextObject</span>(<span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure>

<p>interface_cast具体实现如下所示。<br><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;include&#x2F;binder&#x2F;IInterface.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> sp&lt;INTERFACE&gt; <span class="title">interface_cast</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INTERFACE::<span class="built_in">asInterface</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前的场景中，INTERFACE的值为IServiceManager，那么替换后代码如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> sp&lt;IServiceManager&gt; <span class="title">interface_cast</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; obj)</span></span>&#123;    <span class="keyword">return</span> IServiceManager::<span class="built_in">asInterface</span>(obj);&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着来分析IServiceManager。</p>
<h4 id="解密IServiceManager"><a href="#解密IServiceManager" class="headerlink" title="解密IServiceManager"></a>解密IServiceManager</h4><p>BpBinder和BBinder负责Binder的通信，而IServiceManager用于处理ServiceManager的业务，IServiceManager是C++代码，因此它的定义在IServiceManager.h中。<br><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;include&#x2F;binder&#x2F;IServiceManager.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IServiceManager</span> : <span class="keyword">public</span> IInterface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DECLARE_META_INTERFACE</span>(ServiceManager)<span class="comment">//1</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//一些操作Service的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt;         <span class="title">getService</span><span class="params">( <span class="type">const</span> String16&amp; name)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt;         <span class="title">checkService</span><span class="params">( <span class="type">const</span> String16&amp; name)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">addService</span><span class="params">(<span class="type">const</span> String16&amp; name, <span class="type">const</span> sp&lt;IBinder&gt;&amp; service,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">bool</span> allowIsolated = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">int</span> dumpsysFlags = DUMP_FLAG_PRIORITY_DEFAULT)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector&lt;String16&gt; <span class="title">listServices</span><span class="params">(<span class="type">int</span> dumpsysFlags = DUMP_FLAG_PRIORITY_ALL)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        GET_SERVICE_TRANSACTION = IBinder::FIRST_CALL_TRANSACTION,</span><br><span class="line">        CHECK_SERVICE_TRANSACTION,</span><br><span class="line">        ADD_SERVICE_TRANSACTION,</span><br><span class="line">        LIST_SERVICES_TRANSACTION,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到IServiceManager继承了IInterface，其内部定义了一些常量和一些操作Service的函数，在注释1处调用了DECLARE_META_INTERFACE宏，它的定义在IInterface.h中。<br><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;include&#x2F;binder&#x2F;IInterface.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_META_INTERFACE(INTERFACE)                               \</span></span><br><span class="line"><span class="meta">    static const ::android::String16 descriptor;                        \</span></span><br><span class="line"><span class="meta">    static ::android::sp<span class="string">&lt;I##INTERFACE&gt;</span> asInterface(                     \</span></span><br><span class="line"><span class="meta">            const ::android::sp<span class="string">&lt;::android::IBinder&gt;</span>&amp; obj);              \</span></span><br><span class="line"><span class="meta">    virtual const ::android::String16&amp; getInterfaceDescriptor() const;  \</span></span><br><span class="line"><span class="meta">    I##INTERFACE();                                                     \</span></span><br><span class="line"><span class="meta">    virtual ~I##INTERFACE();   </span></span><br></pre></td></tr></table></figure>

<p>其中INTERFACE的值为ServiceManager，那么经过替换后的代码如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> ::android::String16 descriptor;       </span><br><span class="line"><span class="comment">//定义asInterface函数</span></span><br><span class="line"><span class="type">static</span> ::<span class="function">android::sp&lt;IServiceManager&gt; <span class="title">asInterface</span><span class="params">(                    </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ::android::sp&lt;::android::IBinder&gt;&amp; obj)</span></span>;            </span><br><span class="line"><span class="keyword">virtual</span> <span class="type">const</span> ::<span class="function">android::String16&amp; <span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="type">const</span></span>;  </span><br><span class="line"><span class="comment">//定义IServiceManager构造函数</span></span><br><span class="line"><span class="built_in">IServiceManager</span>();          </span><br><span class="line"><span class="comment">//定义IServiceManager析构函数</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">IServiceManager</span>();   </span><br></pre></td></tr></table></figure>

<p>从DECLARE_META_INTERFACE宏的名称和上面的代码中，可以发现它主要声明了一些函数和一个变量。那么这些函数和变量的实现在哪呢？答案还是在IInterface.h中，叫做IMPLEMENT_META_INTERFACE宏，代码如下所示&#x2F;<br><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;include&#x2F;binder&#x2F;IInterface.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \</span></span><br><span class="line"><span class="meta">    const ::android::String16 I##INTERFACE::descriptor(NAME);           \</span></span><br><span class="line"><span class="meta">    const ::android::String16&amp;                                          \</span></span><br><span class="line"><span class="meta">            I##INTERFACE::getInterfaceDescriptor() const &#123;              \</span></span><br><span class="line"><span class="meta">        return I##INTERFACE::descriptor;                                \</span></span><br><span class="line"><span class="meta">    &#125;                                                                   \</span></span><br><span class="line"><span class="meta">    ::android::sp<span class="string">&lt;I##INTERFACE&gt;</span> I##INTERFACE::asInterface(              \</span></span><br><span class="line"><span class="meta">            const ::android::sp<span class="string">&lt;::android::IBinder&gt;</span>&amp; obj)               \</span></span><br><span class="line"><span class="meta">    &#123;                                                                   \</span></span><br><span class="line"><span class="meta">        ::android::sp<span class="string">&lt;I##INTERFACE&gt;</span> intr;                               \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (obj != NULL) &#123;                                              \</span></span><br><span class="line"><span class="meta">            intr = static_cast<span class="string">&lt;I##INTERFACE*&gt;</span>(                          \</span></span><br><span class="line"><span class="meta">                obj-&gt;queryLocalInterface(                               \</span></span><br><span class="line"><span class="meta">                        I##INTERFACE::descriptor).get());               \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (intr == NULL) &#123;                                         \</span></span><br><span class="line"><span class="meta">                intr = new Bp##INTERFACE(obj);                          \</span></span><br><span class="line"><span class="meta">            &#125;                                                           \</span></span><br><span class="line"><span class="meta">        &#125;                                                               \</span></span><br><span class="line"><span class="meta">        return intr;                                                    \</span></span><br><span class="line"><span class="meta">    &#125;                                                                   \</span></span><br><span class="line"><span class="meta">    I##INTERFACE::I##INTERFACE() &#123; &#125;                                    \</span></span><br><span class="line"><span class="meta">    I##INTERFACE::~I##INTERFACE() &#123; &#125;                                   \</span></span><br></pre></td></tr></table></figure>

<p>DECLARE_META_INTERFACE宏和IMPLEMENT_META_INTERFACE宏是配合使用的，很多系统服务都使用了它们，IServiceManager使用IMPLEMENT_META_INTERFACE宏只有一行代码，如下所示。<br><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IServiceManager.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">IMPLEMENT_META_INTERFACE</span>(ServiceManager, <span class="string">&quot;android.os.IServiceManager&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>IMPLEMENT_META_INTERFACE宏的INTERFACE值为ServiceManager，NAME值为”android.os.IServiceManager”，进行替换后的代码如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> ::<span class="function">android::String16 <span class="title">IServiceManager::descriptor</span><span class="params">(<span class="string">&quot;android.os.IServiceManager&quot;</span>)</span></span>;          </span><br><span class="line"><span class="type">const</span> ::<span class="function">android::String16&amp;                                          </span></span><br><span class="line"><span class="function">        <span class="title">IServiceManager::getInterfaceDescriptor</span><span class="params">()</span> <span class="type">const</span> </span>&#123;              </span><br><span class="line">    <span class="keyword">return</span> IServiceManager::descriptor;                                </span><br><span class="line">&#125; </span><br><span class="line"> <span class="comment">//实现了asInterface函数</span></span><br><span class="line">::<span class="function">android::sp&lt;IServiceManager&gt; <span class="title">IServiceManager::asInterface</span><span class="params">(              </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ::android::sp&lt;::android::IBinder&gt;&amp; obj)</span>               </span></span><br><span class="line"><span class="function"></span>&#123;                                                                   </span><br><span class="line">    ::android::sp&lt;IServiceManager&gt; intr;                               </span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;                                              </span><br><span class="line">        intr = <span class="built_in">static_cast</span>&lt;IServiceManager&gt;(                          </span><br><span class="line">            obj-&gt;<span class="built_in">queryLocalInterface</span>(                               </span><br><span class="line">                    IServiceManager::descriptor).<span class="built_in">get</span>());               </span><br><span class="line">        <span class="keyword">if</span> (intr == <span class="literal">NULL</span>) &#123;                                         </span><br><span class="line">            intr = <span class="keyword">new</span> <span class="built_in">BpServiceManager</span>(obj);<span class="comment">//1                        </span></span><br><span class="line">        &#125;                                                           </span><br><span class="line">    &#125;                                                               </span><br><span class="line">    <span class="keyword">return</span> intr;                                                    </span><br><span class="line">&#125;                                                                   </span><br><span class="line">IServiceManager::<span class="built_in">IServiceManager</span>() &#123; &#125;                                    </span><br><span class="line">IServiceManager::~<span class="built_in">IServiceManager</span>() &#123; &#125;                                   </span><br></pre></td></tr></table></figure>

<p>关键的点就在于注释1处，新建了一个BpServiceManager，传入的参数obj的值为BpBinder。看到这里，我们也就明白了，asInterface函数就是用BpBinder为参数创建了BpServiceManager，从而推断出interface_cast函数创建了BpServiceManager，再往上推断，IServiceManager的defaultServiceManager函数返回的就是BpServiceManager。<br>BpServiceManager有什么作用呢，先从BpServiceManager的构造函数看起。<br><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IServiceManager.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BpServiceManager</span> : <span class="keyword">public</span> BpInterface&lt;IServiceManager&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BpServiceManager</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; impl)</span></span></span><br><span class="line"><span class="function">        : BpInterface&lt;IServiceManager&gt;(impl)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>impl的值其实就是BpBinder，BpServiceManager的构造函数调用了基类BpInterface的构造函数。<br><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;include&#x2F;binder&#x2F;IInterface.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BpInterface</span> : <span class="keyword">public</span> INTERFACE, <span class="keyword">public</span> BpRefBase</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BpInterface继承了BpRefBase，BpRefBase的实现如下所示。<br><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;Binder.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BpRefBase::<span class="built_in">BpRefBase</span>(<span class="type">const</span> sp&lt;IBinder&gt;&amp; o)</span><br><span class="line">    : <span class="built_in">mRemote</span>(o.<span class="built_in">get</span>()), <span class="built_in">mRefs</span>(<span class="literal">NULL</span>), <span class="built_in">mState</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">extendObjectLifetime</span>(OBJECT_LIFETIME_WEAK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRemote) &#123;</span><br><span class="line">        mRemote-&gt;<span class="built_in">incStrong</span>(<span class="keyword">this</span>);           </span><br><span class="line">        mRefs = mRemote-&gt;<span class="built_in">createWeak</span>(<span class="keyword">this</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mRemote是一个IBinder* 指针，它最终的指向为BpBinder，也就是说BpServiceManager的mRemote指向了BpBinder。那么BpServiceManager的作用也就知道了，就是它实现了IServiceManager，并且通过BpBinder来实现通信。</p>
<h4 id="IServiceManager家族"><a href="#IServiceManager家族" class="headerlink" title="IServiceManager家族"></a>IServiceManager家族</h4><p>可能上面讲的会让你有些头晕，这是因为对各个类的关系不大明确，通过下图也许你就会豁然开朗。<br><img src="https://s2.ax1x.com/2019/10/08/ufWhRI.png" alt="ufWhRI.png"></p>
<p>1.BpBinder和BBinder都和通信有关，它们都继承自IBinder。<br>2.BpServiceManager派生自IServiceManager，它们都和业务有关。<br>3.BpRefBase包含了mRemote，通过不断的派生，BpServiceManager也同样包含mRemote，它指向了BpBinder，通过BpBinder来实现通信。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本篇我们学到了Binder通信的C&#x2F;S架构，也知道了Native Binder的原理的核心其实就是ServiceManager的原理，为了讲解ServiceManager的原理，我们需要一个框架来举例，那就是MediaPlayer框架。在讲解MediaServer的入口函数时，我们遇到了三个问题，其中前两个问题相关的知识点ProcessState和IServiceManager都讲解到了，下一篇文章会讲解第三个问题，MediaPlayerService是如何注册的。</p>
<h2 id="Binder原理（三）系统服务的注册过程"><a href="#Binder原理（三）系统服务的注册过程" class="headerlink" title="Binder原理（三）系统服务的注册过程"></a>Binder原理（三）系统服务的注册过程</h2><p>在上一部分中，我们学习了ServiceManager中的Binder机制，有一个问题由于篇幅问题没有讲完，那就是MediaPlayerService是如何注册的。通过了解MediaPlayerService是如何注册的，可以得知系统服务的注册过程。</p>
<h3 id="从调用链角度说明MediaPlayerService是如何注册的"><a href="#从调用链角度说明MediaPlayerService是如何注册的" class="headerlink" title="从调用链角度说明MediaPlayerService是如何注册的"></a>从调用链角度说明MediaPlayerService是如何注册的</h3><p>我们先来看MediaServer的入口函数，代码如下所示。<br><strong>frameworks&#x2F;av&#x2F;media&#x2F;mediaserver&#x2F;main_mediaserver.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc __unused, <span class="type">char</span> **argv __unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGPIPE, SIG_IGN);</span><br><span class="line">    <span class="comment">//获取ProcessState实例</span></span><br><span class="line">    <span class="function">sp&lt;ProcessState&gt; <span class="title">proc</span><span class="params">(ProcessState::self())</span></span>;</span><br><span class="line">    <span class="function">sp&lt;IServiceManager&gt; <span class="title">sm</span><span class="params">(defaultServiceManager())</span></span>;</span><br><span class="line">    <span class="built_in">ALOGI</span>(<span class="string">&quot;ServiceManager: %p&quot;</span>, sm.<span class="built_in">get</span>());</span><br><span class="line">    <span class="built_in">InitializeIcuOrDie</span>();</span><br><span class="line">    <span class="comment">//注册MediaPlayerService</span></span><br><span class="line">    MediaPlayerService::<span class="built_in">instantiate</span>();<span class="comment">//1</span></span><br><span class="line">    ResourceManagerService::<span class="built_in">instantiate</span>();</span><br><span class="line">    <span class="built_in">registerExtensions</span>();</span><br><span class="line">    <span class="comment">//启动Binder线程池</span></span><br><span class="line">    ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">startThreadPool</span>();</span><br><span class="line">    <span class="comment">//当前线程加入到线程池</span></span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">joinThreadPool</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中的很多内容都在上一篇文章介绍过了，接着分析注释1处的代码。</p>
<p><strong>frameworks&#x2F;av&#x2F;media&#x2F;libmediaplayerservice&#x2F;MediaPlayerService.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MediaPlayerService::instantiate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">defaultServiceManager</span>()-&gt;<span class="built_in">addService</span>(</span><br><span class="line">            <span class="built_in">String16</span>(<span class="string">&quot;media.player&quot;</span>), <span class="keyword">new</span> MediaPlayerService，());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>defaultServiceManager返回的是BpServiceManager，不清楚的看[Android Binder原理（二）ServiceManager中的Binder机制][1]这篇文章。参数是一个字符串和MediaPlayerService，看起来像是Key&#x2F;Value的形式来完成注册，接着看addService函数。</p>
<p><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IServiceManager.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">addService</span><span class="params">(<span class="type">const</span> String16&amp; name, <span class="type">const</span> sp&lt;IBinder&gt;&amp; service,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">bool</span> allowIsolated, <span class="type">int</span> dumpsysPriority)</span> </span>&#123;</span><br><span class="line">       Parcel data, reply;<span class="comment">//数据包</span></span><br><span class="line">       data.<span class="built_in">writeInterfaceToken</span>(IServiceManager::<span class="built_in">getInterfaceDescriptor</span>());</span><br><span class="line">       data.<span class="built_in">writeString16</span>(name); <span class="comment">//name值为&quot;media.player&quot;</span></span><br><span class="line">       data.<span class="built_in">writeStrongBinder</span>(service); <span class="comment">//service值为MediaPlayerService</span></span><br><span class="line">       data.<span class="built_in">writeInt32</span>(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">       data.<span class="built_in">writeInt32</span>(dumpsysPriority);</span><br><span class="line">       <span class="type">status_t</span> err = <span class="built_in">remote</span>()-&gt;<span class="built_in">transact</span>(ADD_SERVICE_TRANSACTION, data, &amp;reply);<span class="comment">//1</span></span><br><span class="line">       <span class="keyword">return</span> err == NO_ERROR ? reply.<span class="built_in">readExceptionCode</span>() : err;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>data是一个数据包，后面会不断的将数据写入到data中， 注释1处的remote()指的是mRemote，也就是BpBinder。addService函数的作用就是将请求数据打包成data，然后传给BpBinder的transact函数，代码如下所示。<br><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;BpBinder.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, Parcel* reply, <span class="type">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="type">status_t</span> status = IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">transact</span>(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BpBinder将逻辑处理交给IPCThreadState，先来看IPCThreadState::self()干了什么？<br><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IPCThreadState* <span class="title">IPCThreadState::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//首次进来gHaveTLS的值为false</span></span><br><span class="line">    <span class="keyword">if</span> (gHaveTLS) &#123;</span><br><span class="line">restart:</span><br><span class="line">        <span class="type">const</span> <span class="type">pthread_key_t</span> k = gTLS;<span class="comment">//1</span></span><br><span class="line">        IPCThreadState* st = (IPCThreadState*)<span class="built_in">pthread_getspecific</span>(k);<span class="comment">//2</span></span><br><span class="line">        <span class="keyword">if</span> (st) <span class="keyword">return</span> st;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPCThreadState;<span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">goto</span> restart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处的TLS的全称为Thread local storage，指的是线程本地存储空间，在每个线程中都有TLS，并且线程间不共享。注释2处用于获取TLS中的内容并赋值给IPCThreadState*指针。注释3处会新建一个IPCThreadState，这里可以得知IPCThreadState::self()实际上是为了创建IPCThreadState，它的构造函数如下所示。<br><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IPCThreadState::<span class="built_in">IPCThreadState</span>()</span><br><span class="line">    : <span class="built_in">mProcess</span>(ProcessState::<span class="built_in">self</span>()),</span><br><span class="line">      <span class="built_in">mStrictModePolicy</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mLastTransactionBinderFlags</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pthread_setspecific</span>(gTLS, <span class="keyword">this</span>);<span class="comment">//1</span></span><br><span class="line">    <span class="built_in">clearCaller</span>();</span><br><span class="line">    mIn.<span class="built_in">setDataCapacity</span>(<span class="number">256</span>);</span><br><span class="line">    mOut.<span class="built_in">setDataCapacity</span>(<span class="number">256</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处的pthread_setspecific函数用于设置TLS，将IPCThreadState::self()获得的TLS和自身传进去。IPCThreadState中还包含mIn、一个mOut，其中mIn用来接收来自Binder驱动的数据，mOut用来存储发往Binder驱动的数据，它们默认大小都为256字节。<br>知道了IPCThreadState的构造函数，再回来查看IPCThreadState的transact函数。<br><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="type">int32_t</span> handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Parcel* reply, <span class="type">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">status_t</span> err;</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line">    ...</span><br><span class="line">    err = <span class="built_in">writeTransactionData</span>(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;<span class="built_in">setError</span>(err);</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">       ...</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(reply);<span class="comment">//2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">       ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//不需要等待reply的分支</span></span><br><span class="line">        err = <span class="built_in">waitForResponse</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用BpBinder的transact函数实际上就是调用IPCThreadState的transact函数。注释1处的writeTransactionData函数用于传输数据，其中第一个参数BC_TRANSACTION代表向Binder驱动发送命令协议，向Binder设备发送的命令协议都以BC_开头，而Binder驱动返回的命令协议以BR_开头。这个命令协议我们先记住，后面会再次提到他。</p>
<p>现在分别来分析注释1的writeTransactionData函数和注释2处的waitForResponse函数。</p>
<h4 id="writeTransactionData函数分析"><a href="#writeTransactionData函数分析" class="headerlink" title="writeTransactionData函数分析"></a>writeTransactionData函数分析</h4><p><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::writeTransactionData</span><span class="params">(<span class="type">int32_t</span> cmd, <span class="type">uint32_t</span> binderFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int32_t</span> handle, <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, <span class="type">status_t</span>* statusBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    binder_transaction_data tr;<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; </span><br><span class="line">    tr.target.handle = handle;<span class="comment">//2 </span></span><br><span class="line">    tr.code = code;  <span class="comment">//code=ADD_SERVICE_TRANSACTION</span></span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">status_t</span> err = data.<span class="built_in">errorCheck</span>();<span class="comment">//3</span></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.<span class="built_in">ipcDataSize</span>();</span><br><span class="line">        tr.data.ptr.buffer = data.<span class="built_in">ipcData</span>();</span><br><span class="line">        tr.offsets_size = data.<span class="built_in">ipcObjectsCount</span>()*<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.<span class="built_in">ipcObjects</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        tr.flags |= TF_STATUS_CODE;</span><br><span class="line">        *statusBuffer = err;</span><br><span class="line">        tr.data_size = <span class="built_in">sizeof</span>(<span class="type">status_t</span>);</span><br><span class="line">        tr.data.ptr.buffer = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(statusBuffer);</span><br><span class="line">        tr.offsets_size = <span class="number">0</span>;</span><br><span class="line">        tr.data.ptr.offsets = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOut.<span class="built_in">writeInt32</span>(cmd);  <span class="comment">//cmd=BC_TRANSACTION</span></span><br><span class="line">    mOut.<span class="built_in">write</span>(&amp;tr, <span class="built_in">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处的binder_transaction_data结构体(tr结构体）是向Binder驱动通信的数据结构，注释2处将handle传递给target的handle，用于标识目标，这里的handle的值为0，代表了ServiceManager。<br>注释3处对数据data进行错误检查，如果没有错误就将数据赋值给对应的tr结构体。最后会将BC_TRANSACTION和tr结构体写入到mOut中。<br>上面代码调用链的时序图如下所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11474088-0e4cec13a8f7c169.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h4 id="waitForResponse函数分析"><a href="#waitForResponse函数分析" class="headerlink" title="waitForResponse函数分析"></a>waitForResponse函数分析</h4><p>接着回过头来查看waitForResponse函数做了什么，waitForResponse函数中的case语句很多，这里截取部分代码。<br><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="type">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> cmd;</span><br><span class="line">    <span class="type">int32_t</span> err;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=<span class="built_in">talkWithDriver</span>()) &lt; NO_ERROR) <span class="keyword">break</span>;<span class="comment">//1</span></span><br><span class="line">        err = mIn.<span class="built_in">errorCheck</span>();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.<span class="built_in">dataAvail</span>() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        cmd = (<span class="type">uint32_t</span>)mIn.<span class="built_in">readInt32</span>();</span><br><span class="line">        <span class="built_in">IF_LOG_COMMANDS</span>() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">&quot;Processing waitForResponse Command: &quot;</span></span><br><span class="line">                &lt;&lt; <span class="built_in">getReturnString</span>(cmd) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BR_DEAD_REPLY:</span><br><span class="line">            err = DEAD_OBJECT;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line">       ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">//处理各种命令协议</span></span><br><span class="line">            err = <span class="built_in">executeCommand</span>(cmd);</span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">finish:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处的talkWithDriver函数的内部通过ioctl与Binder驱动进行通信，代码如下所示。<br><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="type">bool</span> doReceive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//和Binder驱动通信的结构体</span></span><br><span class="line">    binder_write_read bwr; <span class="comment">//1</span></span><br><span class="line">    <span class="comment">//mIn是否有可读的数据，接收的数据存储在mIn</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> needRead = mIn.<span class="built_in">dataPosition</span>() &gt;= mIn.<span class="built_in">dataSize</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> outAvail = (!doReceive || needRead) ? mOut.<span class="built_in">dataSize</span>() : <span class="number">0</span>;</span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="type">uintptr_t</span>)mOut.<span class="built_in">data</span>();<span class="comment">//2</span></span><br><span class="line">    <span class="comment">//这时doReceive的值为true</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.<span class="built_in">dataCapacity</span>();</span><br><span class="line">        bwr.read_buffer = (<span class="type">uintptr_t</span>)mIn.<span class="built_in">data</span>();<span class="comment">//3</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    <span class="type">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">IF_LOG_COMMANDS</span>() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">&quot;About to read/write, write size = &quot;</span> &lt;&lt; mOut.<span class="built_in">dataSize</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__ANDROID__)</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)<span class="comment">//4</span></span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        err = INVALID_OPERATION;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     ...</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处的 binder_write_read是和Binder驱动通信的结构体，在注释2和3处将mOut、mIn赋值给binder_write_read的相应字段，最终通过注释4处的ioctl函数和Binder驱动进行通信，这一部分涉及到Kernel Binder的内容<br>了，就不再详细介绍了，只需要知道在Kernel Binder中会记录服务名和handle，用于后续的服务查询。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>从调用链的角度来看，MediaPlayerService是如何注册的貌似并不复杂，因为这里只是简单的介绍了一个调用链分支，可以简单的总结为以下几个步骤：</p>
<ol>
<li>addService函数将数据打包发送给BpBinder来进行处理。</li>
<li>BpBinder新建一个IPCThreadState对象，并将通信的任务交给IPCThreadState。</li>
<li>IPCThreadState的writeTransactionData函数用于将命令协议和数据写入到mOut中。</li>
<li>IPCThreadState的waitForResponse函数主要做了两件事，一件事是通过ioctl函数操作mOut和mIn来与Binder驱动进行数据交互，另一件事是处理各种命令协议。</li>
</ol>
<h3 id="从进程角度说明MediaPlayerService是如何注册的"><a href="#从进程角度说明MediaPlayerService是如何注册的" class="headerlink" title="从进程角度说明MediaPlayerService是如何注册的"></a>从进程角度说明MediaPlayerService是如何注册的</h3><p>实际上MediaPlayerService的注册还涉及到了进程，如下图所示。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xOS8xNmU4MTFjYmUxMzFiMTdi?x-oss-process=image/format,png" alt="Ka0Dx0.png"></p>
<p>从图中看出是以C&#x2F;S架构为基础，addService是在MediaPlayerService进行的，它是Client端，用于请求添加系统服务。而Server端则是指的是ServiceManager，用于完成系统服务的添加。<br>Client端和Server端分别运行在两个进程中，通过向Binder来进行通信。更详细点描述，就是两端通过向Binder驱动发送命令协议来完成系统服务的添加。这其中命令协议非常多，过程也比较复杂，这里对命令协议进行了简化，只涉及到了四个命令协议，其中<br>BC_TRANSACTION和BR_TRANSACTION过程是一个完整的事务，BC_REPLY和BR_REPLY是一个完整的事务。<br>Client端和Server端向Binder驱动发送命令协议以BC开头，而Binder驱动向Client端和Server端返回的命令协议以BR_开头。</p>
<p>步骤如下所示：<br>1.Client端向Binder驱动发送BC_TRANSACTION命令。<br>2.Binder驱动接收到请求后生成BR_TRANSACTION命令，唤醒Server端的线程后将BR_TRANSACTION命令发送给ServiceManager。<br>3.Server端中的服务注册完成后，生成BC_REPLY命令发送给Binder驱动。<br>4.Binder驱动生成BR_REPLY命令，唤醒Client端的线程后将BR_REPLY命令发送个Client端。</p>
<p>通过这些协议命令来驱动并完成系统服务的注册。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>本文分别从调用链角度和进程角度来讲解MediaPlayerService是如何注册的，间接的得出了服务是如何注册的<br>。这两个角度都比较复杂，因此这里分别对这两个角度做了简化，作为应用开发，我们不需要注重太多的过程和细节，只需要了解大概的步骤即可。</p>
<h2 id="Binder原理（四）ServiceManager的启动过程"><a href="#Binder原理（四）ServiceManager的启动过程" class="headerlink" title="Binder原理（四）ServiceManager的启动过程"></a>Binder原理（四）ServiceManager的启动过程</h2><p>在上一部分中，我们以MediaPlayerService为例，讲解了系统服务是如何注册的（addService），既然有注册就势必要有获取，但是在了解获取服务前，我们最好先了解ServiceManager的启动过程，这样更有助于理解系统服务的注册和获取的过程。</p>
<p>另外还有一点需要说明的是，要想了解ServiceManager的启动过程，需要查看Kernel Binder部分的源码，这部分代码在内核源码中，AOSP源码是不包括内核源码的</p>
<h3 id="ServiceManager的入口函数"><a href="#ServiceManager的入口函数" class="headerlink" title="ServiceManager的入口函数"></a>ServiceManager的入口函数</h3><p>ServiceManager是init进程负责启动的，具体是在解析init.rc配置文件时启动的，init进程是在系统启动时启动的，因此ServiceManager亦是如此。</p>
<p>rc文件内部由Android初始化语言编写（Android Init Language）编写的脚本，它主要包含五种类型语句：Action、Commands、Services、Options和Import。<br>在Android 7.0中对init.rc文件进行了拆分，每个服务一个rc文件。ServiceManager的启动脚本在servicemanager.rc中：<br>frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;servicemanager.rc</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">service servicemanager /system/bin/servicemanager</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">core</span> animation</span><br><span class="line">    user system  <span class="comment">//1</span></span><br><span class="line">    group system readproc</span><br><span class="line">    critical <span class="comment">//2</span></span><br><span class="line">    onrestart restart healthd  </span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart surfaceflinger</span><br><span class="line">    onrestart restart inputflinger</span><br><span class="line">    onrestart restart drm</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart keystore</span><br><span class="line">    onrestart restart gatekeeperd</span><br><span class="line">    writepid /dev/cpuset/system-background/tasks</span><br><span class="line">    shutdown critical</span><br></pre></td></tr></table></figure>

<p>service用于通知init进程创建名为servicemanager的进程，这个servicemanager进程执行程序的路径为&#x2F;system&#x2F;bin&#x2F;servicemanager。<br>注释1的关键字user说明servicemanager是以用户system的身份运行的，注释2处的critical说明servicemanager是系统中的关键服务，关键服务是不会退出的，如果退出了，系统就会重启，当系统重启时就会启动用onrestart关键字修饰的进程，比如zygote、media、surfaceflinger等等。</p>
<p>servicemanager的入口函数在service_manager.c中:<br><strong>frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;service_manager.c</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">binder_state</span> *bs;<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">selinux_callback</span> cb;</span><br><span class="line">    <span class="type">char</span> *driver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        driver = argv[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        driver = <span class="string">&quot;/dev/binder&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs = <span class="built_in">binder_open</span>(driver, <span class="number">128</span>*<span class="number">1024</span>);<span class="comment">//2</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">binder_become_context_manager</span>(bs)) &#123;<span class="comment">//3</span></span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;cannot become context manager (%s)\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getcon</span>(&amp;service_manager_context) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;SELinux: Failed to acquire service_manager context. Aborting.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">binder_loop</span>(bs, svcmgr_handler);<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处的binder_state结构体用来存储binder的三个信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_state</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">//binder设备的文件描述符</span></span><br><span class="line">    <span class="type">void</span> *mapped; <span class="comment">//binder设备文件映射到进程的地址空间</span></span><br><span class="line">    <span class="type">size_t</span> mapsize; <span class="comment">//内存映射后，系统分配的地址空间的大小，默认为128KB</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>main函数主要做了三件事：<br>1.注释2处调用binder_open函数用于打开binder设备文件，并申请128k字节大小的内存空间。<br>2.注释3处调用binder_become_context_manager函数，将servicemanager注册成为Binder机制的上下文管理者。<br>3.注释4处调用binder_loop函数，循环等待和处理client端发来的请求。</p>
<p>现在对这三件事分别进行讲解。</p>
<h4 id="打开binder设备"><a href="#打开binder设备" class="headerlink" title="打开binder设备"></a>打开binder设备</h4><p>binder_open函数用于打开binder设备文件，并且将它映射到进程的地址空间，如下所示。</p>
<p><strong>frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;binder.c</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_state</span> *<span class="built_in">binder_open</span>(<span class="type">const</span> <span class="type">char</span>* driver, <span class="type">size_t</span> mapsize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">binder_state</span> *bs;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">binder_version</span> vers;</span><br><span class="line"></span><br><span class="line">    bs = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(*bs));</span><br><span class="line">    <span class="keyword">if</span> (!bs) &#123;</span><br><span class="line">        errno = ENOMEM;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs-&gt;fd = <span class="built_in">open</span>(driver, O_RDWR | O_CLOEXEC);<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">if</span> (bs-&gt;fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;binder: cannot open %s (%s)\n&quot;</span>,</span><br><span class="line">                driver, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">goto</span> fail_open;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取Binder的version</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">ioctl</span>(bs-&gt;fd, BINDER_VERSION, &amp;vers) == <span class="number">-1</span>) ||</span><br><span class="line">        (vers.protocol_version != BINDER_CURRENT_PROTOCOL_VERSION)) &#123;<span class="comment">//2</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,</span><br><span class="line">                <span class="string">&quot;binder: kernel driver version (%d) differs from user space version (%d)\n&quot;</span>,</span><br><span class="line">                vers.protocol_version, BINDER_CURRENT_PROTOCOL_VERSION);</span><br><span class="line">        <span class="keyword">goto</span> fail_open;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs-&gt;mapsize = mapsize;</span><br><span class="line">    bs-&gt;mapped = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, <span class="number">0</span>);<span class="comment">//3</span></span><br><span class="line">    <span class="keyword">if</span> (bs-&gt;mapped == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;binder: cannot map device (%s)\n&quot;</span>,</span><br><span class="line">                <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">goto</span> fail_map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bs;</span><br><span class="line"></span><br><span class="line">fail_map:</span><br><span class="line">    <span class="built_in">close</span>(bs-&gt;fd);</span><br><span class="line">fail_open:</span><br><span class="line">    <span class="built_in">free</span>(bs);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处用于打开binder设备文件，后面会进行分析。<br>注释2处的ioctl函数用于获取Binder的版本，如果获取不到或者内核空间和用户空间的binder不是同一个版本就会直接goto到fail_open标签，释放binder的内存空间。<br>注释3处调用mmap函数进行内存映射，通俗来讲就是将binder设备文件映射到进程的地址空间，地址空间的大小为mapsize，也就是128K。映射完毕后会将地址空间的起始地址和大小保存在binder_state结构体中的mapped和mapsize变量中。</p>
<p>这里着重说一下open函数，它会调用Kernel Binder部分的binder_open函数，这部分源码位于内核源码中，这里展示的代码版本为goldfish3.4。</p>
<p><strong>用户态和内核态</strong><br>临时插入一个知识点:用户态和内核态<br>Intel的X86架构的CPU提供了0到3四个特权级，数字越小，权限越高，Linux操作系统中主要采用了0和3两个特权级，分别对应的就是内核态与用户态。用户态的特权级别低，因此进程在用户态下不经过系统调用是无法主动访问到内核空间中的数据的，这样用户无法随意的进入所有进程共享的内核空间，起到了保护的作用。下面来介绍下什么是用户态和内核态。<br>当一个进程在执行用户自己的代码时处于用户态，比如open函数，它运行在用户空间，当前的进程处于用户态。<br>当一个进程因为系统调用进入内核代码中执行时就处于内核态，比如open函数通过系统调用（__open()函数），查找到了open函数在Kernel Binder对应的函数为binder_open，这时binder_open运行在内核空间，当前的进程由用户态切换到内核态。</p>
<p><strong>kernel&#x2F;goldfish&#x2F;drivers&#x2F;staging&#x2F;android&#x2F;binder.c</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">binder_open</span><span class="params">(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//代表Binder进程</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">binder_proc</span> *proc;<span class="comment">//1</span></span><br><span class="line">	<span class="built_in">binder_debug</span>(BINDER_DEBUG_OPEN_CLOSE, <span class="string">&quot;binder_open: %d:%d\n&quot;</span>,</span><br><span class="line">		     current-&gt;group_leader-&gt;pid, current-&gt;pid);</span><br><span class="line">    <span class="comment">//分配内存空间</span></span><br><span class="line">	proc = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(*proc), GFP_KERNEL);<span class="comment">//2</span></span><br><span class="line">	<span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="built_in">get_task_struct</span>(current);</span><br><span class="line">	proc-&gt;tsk = current;</span><br><span class="line">	<span class="built_in">INIT_LIST_HEAD</span>(&amp;proc-&gt;todo);</span><br><span class="line">	<span class="built_in">init_waitqueue_head</span>(&amp;proc-&gt;wait);</span><br><span class="line">	proc-&gt;default_priority = <span class="built_in">task_nice</span>(current);</span><br><span class="line">    <span class="comment">//binder同步锁</span></span><br><span class="line">	<span class="built_in">binder_lock</span>(__func__);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">binder_stats_created</span>(BINDER_STAT_PROC);</span><br><span class="line">	<span class="built_in">hlist_add_head</span>(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">	proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">	<span class="built_in">INIT_LIST_HEAD</span>(&amp;proc-&gt;delivered_death);</span><br><span class="line">	filp-&gt;private_data = proc;<span class="comment">//3</span></span><br><span class="line">    <span class="comment">//binder同步锁释放</span></span><br><span class="line">	<span class="built_in">binder_unlock</span>(__func__);</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处的binder_proc结构体代表binder进程，用于管理binder的各种信息。注释2处用于为binder_proc分配内存空间。注释3处将binder_proc赋值给file指针的private_data变量，后面的1.2小节会再次提到这个private_data变量。</p>
<h4 id="注册成为Binder机制的上下文管理者"><a href="#注册成为Binder机制的上下文管理者" class="headerlink" title="注册成为Binder机制的上下文管理者"></a>注册成为Binder机制的上下文管理者</h4><p>binder_become_context_manager函数用于将servicemanager注册成为Binder机制的上下文管理者，这个管理者在整个系统只有一个，代码如下所示。<br><strong>frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;binder.c</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binder_become_context_manager</span><span class="params">(<span class="keyword">struct</span> binder_state *bs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ioctl</span>(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ioctl函数会调用Binder驱动的binder_ioctl函数，binder_ioctl函数代码比较多，这里截取BINDER_SET_CONTEXT_MGR的处理部分，代码如下所示。<br><strong>kernel&#x2F;goldfish&#x2F;drivers&#x2F;staging&#x2F;android&#x2F;binder.c</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">long</span> <span class="title">binder_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">binder_proc</span> *proc = filp-&gt;private_data; <span class="comment">//1</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">binder_thread</span> *thread;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">	<span class="type">void</span> __user *ubuf = (<span class="type">void</span> __user *)arg;</span><br><span class="line">	<span class="built_in">trace_binder_ioctl</span>(cmd, arg);</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">wait_event_interruptible</span>(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err_unlocked;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">binder_lock</span>(__func__);</span><br><span class="line">	thread = <span class="built_in">binder_get_thread</span>(proc);<span class="comment">//2</span></span><br><span class="line">	<span class="keyword">if</span> (thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">case</span> BINDER_SET_CONTEXT_MGR:</span><br><span class="line">		<span class="keyword">if</span> (binder_context_mgr_node != <span class="literal">NULL</span>) &#123;<span class="comment">//3</span></span><br><span class="line">			<span class="built_in">printk</span>(KERN_ERR <span class="string">&quot;binder: BINDER_SET_CONTEXT_MGR already set\n&quot;</span>);</span><br><span class="line">			ret = -EBUSY;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		ret = <span class="built_in">security_binder_set_context_mgr</span>(proc-&gt;tsk);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		<span class="keyword">if</span> (binder_context_mgr_uid != <span class="number">-1</span>) &#123;<span class="comment">//4</span></span><br><span class="line">			<span class="keyword">if</span> (binder_context_mgr_uid != current-&gt;cred-&gt;euid) &#123;<span class="comment">//5</span></span><br><span class="line">				<span class="built_in">printk</span>(KERN_ERR <span class="string">&quot;binder: BINDER_SET_&quot;</span></span><br><span class="line">				       <span class="string">&quot;CONTEXT_MGR bad uid %d != %d\n&quot;</span>,</span><br><span class="line">				       current-&gt;cred-&gt;euid,</span><br><span class="line">				       binder_context_mgr_uid);</span><br><span class="line">				ret = -EPERM;</span><br><span class="line">				<span class="keyword">goto</span> err;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			binder_context_mgr_uid = current-&gt;cred-&gt;euid;<span class="comment">//6</span></span><br><span class="line">		binder_context_mgr_node = <span class="built_in">binder_new_node</span>(proc, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//7</span></span><br><span class="line">		<span class="keyword">if</span> (binder_context_mgr_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			ret = -ENOMEM;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		binder_context_mgr_node-&gt;local_weak_refs++;</span><br><span class="line">		binder_context_mgr_node-&gt;local_strong_refs++;</span><br><span class="line">		binder_context_mgr_node-&gt;has_strong_ref = <span class="number">1</span>;</span><br><span class="line">		binder_context_mgr_node-&gt;has_weak_ref = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"> ...</span><br><span class="line">err_unlocked:</span><br><span class="line">	<span class="built_in">trace_binder_ioctl_done</span>(ret);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处将file指针中的private_data变量赋值给binder_proc，这个private_data变量在binder_open函数中讲过，是一个binder_proc结构体。注释2处的binder_get_thread函数用于获取binder_thread，binder_thread结构体指的是binder线程，binder_get_thread函数内部会从传入的参数binder_proc中查找binder_thread，如果查询到直接返回，如果查询不到会创建一个新的binder_thread并返回。<br>注释3处的全局变量binder_context_mgr_node代表的是Binder机制的上下文管理者对应的一个Binder对象，如果它不为NULL，说明此前自身已经被注册为Binder的上下文管理者了，Binder的上下文管理者是不能重复注册的，因此会goto到err标签。<br>注释4处的全局变量binder_context_mgr_uid代表注册了Binder机制上下文管理者的进程的有效用户ID，如果它的值不为-1，说明此前已经有进程注册Binder的上下文管理者了，因此在注释5处判断当前进程的有效用户ID是否等于binder_context_mgr_uid，不等于就goto到err标签。<br>如果不满足注释4的条件，说明此前没有进程注册Binder机制的上下文管理者，就会在注释6处将当前进程的有效用户ID赋值给全局变量binder_context_mgr_uid，另外还会在注释7处调用binder_new_node函数创建一个Binder对象并赋值给全局变量binder_context_mgr_node。</p>
<h4 id="循环等待和处理client端发来的请求"><a href="#循环等待和处理client端发来的请求" class="headerlink" title="循环等待和处理client端发来的请求"></a>循环等待和处理client端发来的请求</h4><p>servicemanager成功注册成为Binder机制的上下文管理者后，servicemanager就是Binder机制的“总管”了，它需要在系统运行期间处理client端的请求，由于client端的请求不确定何时发送，因此需要通过无限循环来实现，实现这一需求的函数就是binder_loop。<br><strong>frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;binder.c</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">binder_loop</span><span class="params">(<span class="keyword">struct</span> binder_state *bs, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">binder_write_read</span> bwr;</span><br><span class="line">    <span class="type">uint32_t</span> readbuf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    bwr.write_size = <span class="number">0</span>;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER;</span><br><span class="line">    <span class="built_in">binder_write</span>(bs, readbuf, <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>));<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bwr.read_size = <span class="built_in">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = (<span class="type">uintptr_t</span>) readbuf;</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">ioctl</span>(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;binder_loop: ioctl failed (%s)\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">binder_parse</span>(bs, <span class="number">0</span>, (<span class="type">uintptr_t</span>) readbuf, bwr.read_consumed, func);<span class="comment">//3</span></span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;binder_loop: unexpected reply?!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;binder_loop: io error %d %s\n&quot;</span>, res, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处将BC_ENTER_LOOPER指令通过binder_write函数写入到Binder驱动中，这样当前线程（ServiceManager的主线程）就成为了一个Binder线程，这样就可以处理进程间的请求了。<br>在无限循环中不断的调用注释2处的ioctl函数，它不断的使用BINDER_WRITE_READ指令查询Binder驱动中是否有新的请求，如果有就交给注释3处的binder_parse函数处理。如果没有，当前线程就会在Binder驱动中睡眠，等待新的进程间请求。</p>
<p>由于binder_write函数的调用链中涉及到了内核空间和用户空间的交互，因此这里着重讲解下。</p>
<p><strong>frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;binder.c</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binder_write</span><span class="params">(<span class="keyword">struct</span> binder_state *bs, <span class="type">void</span> *data, <span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">binder_write_read</span> bwr;<span class="comment">//1</span></span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    bwr.write_size = len;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = (<span class="type">uintptr_t</span>) data;<span class="comment">//2</span></span><br><span class="line">    bwr.read_size = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    res = <span class="built_in">ioctl</span>(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);<span class="comment">//3</span></span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;binder_write: ioctl failed (%s)\n&quot;</span>,</span><br><span class="line">                <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处定义binder_write_read结构体，接下来的代码对bwr进行赋值，其中需要注意的是，注释2处的data的值为BC_ENTER_LOOPER。注释3处的ioctl函数将会bwr中的数据发送给binder驱动，我们已经知道了ioctl函数在Kernel Binder中对应的函数为binder_ioctl，此前分析过这个函数，这里截取BINDER_WRITE_READ命令处理部分。</p>
<p><strong>kernel&#x2F;goldfish&#x2F;drivers&#x2F;staging&#x2F;android&#x2F;binder.c</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">long</span> <span class="title">binder_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    ...</span><br><span class="line">    <span class="type">void</span> __user *ubuf = (<span class="type">void</span> __user *)arg;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> BINDER_WRITE_READ: &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">binder_write_read</span> bwr;</span><br><span class="line">		<span class="keyword">if</span> (size != <span class="built_in">sizeof</span>(<span class="keyword">struct</span> binder_write_read)) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">copy_from_user</span>(&amp;bwr, ubuf, <span class="built_in">sizeof</span>(bwr))) &#123;<span class="comment">//1</span></span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">binder_debug</span>(BINDER_DEBUG_READ_WRITE,</span><br><span class="line">			     <span class="string">&quot;binder: %d:%d write %ld at %08lx, read %ld at %08lx\n&quot;</span>,</span><br><span class="line">			     proc-&gt;pid, thread-&gt;pid, bwr.write_size, bwr.write_buffer,</span><br><span class="line">			     bwr.read_size, bwr.read_buffer);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;<span class="comment">//2</span></span><br><span class="line">			ret = <span class="built_in">binder_thread_write</span>(proc, thread, (<span class="type">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);<span class="comment">//3</span></span><br><span class="line">			<span class="built_in">trace_binder_write_done</span>(ret);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="built_in">sizeof</span>(bwr)))</span><br><span class="line">					ret = -EFAULT;</span><br><span class="line">				<span class="keyword">goto</span> err;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    ...</span><br><span class="line">		<span class="built_in">binder_debug</span>(BINDER_DEBUG_READ_WRITE,</span><br><span class="line">			     <span class="string">&quot;binder: %d:%d wrote %ld of %ld, read return %ld of %ld\n&quot;</span>,</span><br><span class="line">			     proc-&gt;pid, thread-&gt;pid, bwr.write_consumed, bwr.write_size,</span><br><span class="line">			     bwr.read_consumed, bwr.read_size);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="built_in">sizeof</span>(bwr))) &#123;<span class="comment">//4</span></span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">   ...</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处的copy_from_user函数，在本系列的第一篇**[Android Binder原理（一）学习Binder前必须要了解的知识点](# Android Binder原理（一）学习Binder前必须要了解的知识点)**提过。在这里，它用于将把用户空间数据ubuf拷贝出来保存到内核数据bwr（binder_write_read结构体）中。<br>注释2处，bwr的输入缓存区有数据时，会调用注释3处的binder_thread_write函数来处理BC_ENTER_LOOPER协议，其内部会将目标线程的状态设置为BINDER_LOOPER_STATE_ENTERED，这样目标线程就是一个Binder线程。<br>注释4处通过copy_to_user函数将内核空间数据bwr拷贝到用户空间。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>ServiceManager的启动过程实际上就是分析ServiceManager的入口函数，在入口函数中主要做了三件事，本篇深入到内核源码来对这三件逐一进行分析，由于涉及的函数比较多，这篇文章只介绍了我们需要掌握的，剩余大家可以自行阅读源码，比如binder_thread_write、copy_to_user函数。</p>
<h2 id="Binder原理（五）系统服务的获取过程"><a href="#Binder原理（五）系统服务的获取过程" class="headerlink" title="Binder原理（五）系统服务的获取过程"></a>Binder原理（五）系统服务的获取过程</h2><p>在本系列的此前文章中，以MediaPlayerService为例，讲解了系统服务是如何注册的（addService），既然有注册那肯定也要有获取，本篇文章仍旧以MediaPlayerService为例，来讲解系统服务的获取过程（getService）。文章会分为两个部分进行讲解，分别是客户端MediaPlayerService请求获取服务和服务端ServiceManager处理请求，先来学习第一部分。</p>
<h3 id="客户端MediaPlayerService请求获取服务"><a href="#客户端MediaPlayerService请求获取服务" class="headerlink" title="客户端MediaPlayerService请求获取服务"></a>客户端MediaPlayerService请求获取服务</h3><p>要想获取MediaPlayerService，需要先调用getMediaPlayerService函数，如下所示。<br>frameworks&#x2F;av&#x2F;media&#x2F;libmedia&#x2F;IMediaDeathNotifier.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">IMediaDeathNotifier::<span class="built_in">getMediaPlayerService</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;getMediaPlayerService&quot;</span>);</span><br><span class="line">    Mutex::Autolock _l(sServiceLock);</span><br><span class="line">    <span class="keyword">if</span> (sMediaPlayerService == <span class="number">0</span>) &#123;</span><br><span class="line">        sp&lt;IServiceManager&gt; sm = <span class="built_in">defaultServiceManager</span>();<span class="comment">//1</span></span><br><span class="line">        sp&lt;IBinder&gt; binder;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            binder = sm-&gt;<span class="built_in">getService</span>(<span class="built_in">String16</span>(<span class="string">&quot;media.player&quot;</span>));<span class="comment">//2</span></span><br><span class="line">            <span class="keyword">if</span> (binder != <span class="number">0</span>) &#123;<span class="comment">//3</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;Media player service not published, waiting...&quot;</span>);</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">500000</span>); <span class="comment">//4</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sDeathNotifier == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sDeathNotifier = <span class="keyword">new</span> <span class="built_in">DeathNotifier</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        binder-&gt;<span class="built_in">linkToDeath</span>(sDeathNotifier);</span><br><span class="line">        sMediaPlayerService = <span class="built_in">interface_cast</span>&lt;IMediaPlayerService&gt;(binder);<span class="comment">//5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ALOGE_IF</span>(sMediaPlayerService == <span class="number">0</span>, <span class="string">&quot;no media player service!?&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> sMediaPlayerService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处的defaultServiceManager返回的是BpServiceManager，注释2处获取名为”media.player”的系统服务（MediaPlayerService），返回的值为BpBinder。由于这个时候MediaPlayerService可能还没有向ServiceManager注册，那么就不能满足注释3的条件，在注释4处休眠0.5s后继续调用getService函数，直到获取服务对应的为止。<br>注释5处的interface_cast函数用于将BpBinder转换成BpMediaPlayerService，其原理就是通过BpBinder的handle来找到对应的服务，即BpMediaPlayerService。</p>
<p>注释2处的获取服务是本文的重点，BpServiceManager的getService函数如下所示。<br><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IServiceManager.cpp::BpServiceManager</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt; <span class="title">getService</span><span class="params">(<span class="type">const</span> String16&amp; name)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">       <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (<span class="built_in">uptimeMillis</span>() &lt; timeout) &#123;</span><br><span class="line">           n++;</span><br><span class="line">           <span class="keyword">if</span> (isVendorService) &#123;</span><br><span class="line">               <span class="built_in">ALOGI</span>(<span class="string">&quot;Waiting for vendor service %s...&quot;</span>, <span class="built_in">String8</span>(name).<span class="built_in">string</span>());</span><br><span class="line">               <span class="function">CallStack <span class="title">stack</span><span class="params">(LOG_TAG)</span></span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n%<span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="built_in">ALOGI</span>(<span class="string">&quot;Waiting for service %s...&quot;</span>, <span class="built_in">String8</span>(name).<span class="built_in">string</span>());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="built_in">usleep</span>(<span class="number">1000</span>*sleepTime);</span><br><span class="line"></span><br><span class="line">           sp&lt;IBinder&gt; svc = <span class="built_in">checkService</span>(name);<span class="comment">//1</span></span><br><span class="line">           <span class="keyword">if</span> (svc != <span class="literal">NULL</span>) <span class="keyword">return</span> svc;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">ALOGW</span>(<span class="string">&quot;Service %s didn&#x27;t start. Returning NULL&quot;</span>, <span class="built_in">String8</span>(name).<span class="built_in">string</span>());</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>getService函数中主要做的事就是循环的查询服务是否存在，如果不存在就继续查询，查询服务用到了注释1处的checkService函数，代码如下所示。<br><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IServiceManager.cpp::BpServiceManager</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt; <span class="title">checkService</span><span class="params">( <span class="type">const</span> String16&amp; name)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel data, reply;<span class="comment">//1</span></span><br><span class="line">    data.<span class="built_in">writeInterfaceToken</span>(IServiceManager::<span class="built_in">getInterfaceDescriptor</span>());</span><br><span class="line">    data.<span class="built_in">writeString16</span>(name);<span class="comment">//2</span></span><br><span class="line">    <span class="built_in">remote</span>()-&gt;<span class="built_in">transact</span>(CHECK_SERVICE_TRANSACTION, data, &amp;reply);<span class="comment">//3</span></span><br><span class="line">    <span class="keyword">return</span> reply.<span class="built_in">readStrongBinder</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处的data，看过上一篇文章的同学应该很熟悉，它出现在BpServiceManager的addService函数中，data是一个数据包，后面会不断的将数据写入到data中。注释2处将字符串”media.player”写入到data中。<br>注释3处的remote()指的是mRemote，也就是BpBinder，BpBinder的transact函数如下所示。</p>
<p><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;BpBinder.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, Parcel* reply, <span class="type">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="type">status_t</span> status = IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">transact</span>(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BpBinder将逻辑处理交给IPCThreadState，后面的调用链在&#x3D;<a target="_blank" rel="noopener" href="http://liuwangshu.cn/framework/binder/3-addservice.html">Android Binder原理（三）系统服务的注册过程</a>中讲过，这里再次简单的过一遍，IPCThreadState::self()会创建创建IPCThreadState，IPCThreadState的transact函数如下所示。<br><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="type">int32_t</span> handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Parcel* reply, <span class="type">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">status_t</span> err;</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line">    ...</span><br><span class="line">    err = <span class="built_in">writeTransactionData</span>(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;<span class="built_in">setError</span>(err);</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">       ...</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(reply);<span class="comment">//2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">       ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//不需要等待reply的分支</span></span><br><span class="line">        err = <span class="built_in">waitForResponse</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用BpBinder的transact函数实际上就是调用IPCThreadState的transact函数。注释1处的writeTransactionData函数用于传输数据，其中第一个参数BC_TRANSACTION代表向Binder驱动发送命令协议。<br>注释1处的writeTransactionData用于准备发送的数据，其内部会将BC_TRANSACTION和binder_transaction_data结构体写入到mOut中。<br>接着查看waitForResponse函数做了什么，代码如下所示。<br><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="type">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> cmd;</span><br><span class="line">    <span class="type">int32_t</span> err;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=<span class="built_in">talkWithDriver</span>()) &lt; NO_ERROR) <span class="keyword">break</span>;<span class="comment">//1</span></span><br><span class="line">        err = mIn.<span class="built_in">errorCheck</span>();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.<span class="built_in">dataAvail</span>() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        cmd = (<span class="type">uint32_t</span>)mIn.<span class="built_in">readInt32</span>();</span><br><span class="line">        <span class="built_in">IF_LOG_COMMANDS</span>() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">&quot;Processing waitForResponse Command: &quot;</span></span><br><span class="line">                &lt;&lt; <span class="built_in">getReturnString</span>(cmd) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">//处理各种命令协议</span></span><br><span class="line">            err = <span class="built_in">executeCommand</span>(cmd);</span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">finish:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处的talkWithDriver函数的内部通过ioctl与Binder驱动进行通信，代码如下所示。<br><strong>frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="type">bool</span> doReceive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//和Binder驱动通信的结构体</span></span><br><span class="line">    binder_write_read bwr; <span class="comment">//1</span></span><br><span class="line">    <span class="comment">//mIn是否有可读的数据，接收的数据存储在mIn</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> needRead = mIn.<span class="built_in">dataPosition</span>() &gt;= mIn.<span class="built_in">dataSize</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> outAvail = (!doReceive || needRead) ? mOut.<span class="built_in">dataSize</span>() : <span class="number">0</span>;</span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="type">uintptr_t</span>)mOut.<span class="built_in">data</span>();<span class="comment">//2</span></span><br><span class="line">    <span class="comment">//这时doReceive的值为true</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.<span class="built_in">dataCapacity</span>();</span><br><span class="line">        bwr.read_buffer = (<span class="type">uintptr_t</span>)mIn.<span class="built_in">data</span>();<span class="comment">//3</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    <span class="type">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">IF_LOG_COMMANDS</span>() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">&quot;About to read/write, write size = &quot;</span> &lt;&lt; mOut.<span class="built_in">dataSize</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__ANDROID__)</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)<span class="comment">//4</span></span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        err = INVALID_OPERATION;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     ...</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处的 binder_write_read是和Binder驱动通信的结构体，在注释2和3处将mOut、mIn赋值给binder_write_read的相应字段，最终通过注释4处的ioctl函数和Binder驱动进行通信。这一过程的时序图如下所示。<br><a target="_blank" rel="noopener" href="https://imgchr.com/i/MUr7w9"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8yNy8xNmVhYjNiMjRiZTViZmU5?x-oss-process=image/format,png" alt="MUr7w9.md.png"></a></p>
<p>这时我们需要再次查看[Android Binder原理（三）系统服务的注册过程](#Android Binder原理（三）系统服务的注册过程)这篇第2小节给出的图。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8yNy8xNmVhYjNiMjRiYmExZDRh?x-oss-process=image/format,png" alt="Ka0Dx0.png"></p>
<p>从这张简化的流程图可以看出，我们当前分析的是客户端进程的流程，当MediaPlayerService向Binder驱动发送BC_TRANSACTION命令后，Binder驱动会向ServiceManager发送BR_TRANSACTION命令，接下来我们来查看服务端ServiceManager是如何处理获取服务这一请求的。</p>
<h3 id="服务端ServiceManager处理请求"><a href="#服务端ServiceManager处理请求" class="headerlink" title="服务端ServiceManager处理请求"></a>服务端ServiceManager处理请求</h3><p>说到服务端ServiceManager处理请求，不得不说到ServiceManager的启动过程，具体的请看[Android Binder原理（四）ServiceManager的启动过程](#Android Binder原理（四）ServiceManager的启动过程) 这篇。<br>这里简单回顾servicemanager的入口函数，如下所示。</p>
<p><strong>frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;service_manager.c</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ...</span><br><span class="line">    bs = <span class="built_in">binder_open</span>(driver, <span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">binder_become_context_manager</span>(bs)) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;cannot become context manager (%s)\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getcon</span>(&amp;service_manager_context) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;SELinux: Failed to acquire service_manager context. Aborting.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">binder_loop</span>(bs, svcmgr_handler);<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main函数主要做了三件事，其中最后一件事就是调用binder_loop函数，这里需要注意，它的第二个参数为svcmgr_handler，后面会再次提到svcmgr_handler。<br>binder_loop函数如下所示。<br><strong>frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;binder.c</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">binder_loop</span><span class="params">(<span class="keyword">struct</span> binder_state *bs, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bwr.read_size = <span class="built_in">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = (<span class="type">uintptr_t</span>) readbuf;</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">ioctl</span>(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;binder_loop: ioctl failed (%s)\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">binder_parse</span>(bs, <span class="number">0</span>, (<span class="type">uintptr_t</span>) readbuf, bwr.read_consumed, func);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;binder_loop: unexpected reply?!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;binder_loop: io error %d %s\n&quot;</span>, res, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在无限循环中不断的调用ioctl函数，它不断的使用BINDER_WRITE_READ指令查询Binder驱动中是否有新的请求，如果有就交给binder_parse函数处理。如果没有，当前线程就会在Binder驱动中睡眠，等待新的进程间通信请求。<br>binder_parse函数如下所示。<br><strong>frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;binder.c</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binder_parse</span><span class="params">(<span class="keyword">struct</span> binder_state *bs, <span class="keyword">struct</span> binder_io *bio,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">uintptr_t</span> ptr, <span class="type">size_t</span> size, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uintptr_t</span> end = ptr + (<span class="type">uintptr_t</span>) size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ptr &lt; end) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> cmd = *(<span class="type">uint32_t</span> *) ptr;</span><br><span class="line">        ptr += <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRACE</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;%s:\n&quot;</span>, <span class="built_in">cmd_name</span>(cmd));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION: &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">binder_transaction_data</span> *txn = (<span class="keyword">struct</span> binder_transaction_data *) ptr;</span><br><span class="line">            <span class="keyword">if</span> ((end - ptr) &lt; <span class="built_in">sizeof</span>(*txn)) &#123;</span><br><span class="line">                <span class="built_in">ALOGE</span>(<span class="string">&quot;parse: txn too small!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">binder_dump_txn</span>(txn);</span><br><span class="line">            <span class="keyword">if</span> (func) &#123;</span><br><span class="line">                <span class="type">unsigned</span> rdata[<span class="number">256</span>/<span class="number">4</span>];</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">binder_io</span> msg;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">binder_io</span> reply;</span><br><span class="line">                <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">bio_init</span>(&amp;reply, rdata, <span class="built_in">sizeof</span>(rdata), <span class="number">4</span>);</span><br><span class="line">                <span class="built_in">bio_init_from_txn</span>(&amp;msg, txn);</span><br><span class="line">                res = <span class="built_in">func</span>(bs, txn, &amp;msg, &amp;reply);<span class="comment">//1</span></span><br><span class="line">                <span class="keyword">if</span> (txn-&gt;flags &amp; TF_ONE_WAY) &#123;</span><br><span class="line">                    <span class="built_in">binder_free_buffer</span>(bs, txn-&gt;data.ptr.buffer);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">binder_send_reply</span>(bs, &amp;reply, txn-&gt;data.ptr.buffer, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="built_in">sizeof</span>(*txn);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里截取了BR_TRANSACTION命令的处理部分，注释1出的func通过一路传递指向的是svcmgr_handler，svcmgr_handler函数如下所示。<br><strong>frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;service_manager.c</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">svcmgr_handler</span><span class="params">(<span class="keyword">struct</span> binder_state *bs,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">struct</span> binder_transaction_data *txn,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">struct</span> binder_io *msg,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">struct</span> binder_io *reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span>(txn-&gt;code) &#123;</span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_GET_SERVICE:</span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_CHECK_SERVICE:</span><br><span class="line">        s = <span class="built_in">bio_get_string16</span>(msg, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        handle = <span class="built_in">do_find_service</span>(s, len, txn-&gt;sender_euid, txn-&gt;sender_pid);</span><br><span class="line">        <span class="keyword">if</span> (!handle)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">bio_put_ref</span>(reply, handle);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;unknown code %d\n&quot;</span>, txn-&gt;code);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bio_put_uint32</span>(reply, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当要获取服务时，会调用do_find_service函数，代码如下所示。<br><strong>frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;service_manager.c</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">do_find_service</span><span class="params">(<span class="type">const</span> <span class="type">uint16_t</span> *s, <span class="type">size_t</span> len, <span class="type">uid_t</span> uid, <span class="type">pid_t</span> spid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">svcinfo</span> *si = <span class="built_in">find_svc</span>(s, len);<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!si || !si-&gt;handle) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!si-&gt;allow_isolated) &#123;</span><br><span class="line">        <span class="type">uid_t</span> appid = uid % AID_USER;</span><br><span class="line">        <span class="keyword">if</span> (appid &gt;= AID_ISOLATED_START &amp;&amp; appid &lt;= AID_ISOLATED_END) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">svc_can_find</span>(s, len, spid, uid)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> si-&gt;handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处的find_svc函数用于查询服务，返回的svcinfo是一个结构体，其内部包含了服务的handle值，最终会返回服务的handle值。接着来看find_svc函数：<br><strong>frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;service_manager.c</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">svcinfo</span> *<span class="built_in">find_svc</span>(<span class="type">const</span> <span class="type">uint16_t</span> *s16, <span class="type">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">svcinfo</span> *si;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (si = svclist; si; si = si-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((len == si-&gt;len) &amp;&amp;</span><br><span class="line">            !<span class="built_in">memcmp</span>(s16, si-&gt;name, len * <span class="built_in">sizeof</span>(<span class="type">uint16_t</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> si;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>系统服务的注册流程中，在Kernel Binder中会调用do_add_service函数，其内部会将包含服务名和handle值的svcinfo保存到svclist列表中。同样的，在获取服务的流程中，find_svc函数中会遍历svclist列表，根据服务名查找对应服务是否已经注册，如果已经注册就会返回对应的svcinfo，如果没有注册就返回NULL。</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>这篇将系统服务的获取过程分为两个部分，代码涉及到了Native Binder和Kernel Binder。在下一篇文章中会继续学习Java Binder相关的内容。</p>
<h2 id="Binder原理（六）Java-Binder的初始化"><a href="#Binder原理（六）Java-Binder的初始化" class="headerlink" title="Binder原理（六）Java Binder的初始化"></a>Binder原理（六）Java Binder的初始化</h2><p>在[Android Binder原理（一）学习Binder前必须要了解的知识点](#Android Binder原理（一）学习Binder前必须要了解的知识点)这篇中，我根据Android系统的分层，将Binder机制分为了三层：</p>
<ol>
<li>Java Binder (对应Framework层的Binder)</li>
<li>Native Binder(对应Native层的Binder)</li>
<li>Kernel Binder(对应Kernel层的Binder)</li>
</ol>
<p>在此前，我一直都在介绍Native Binder和Kernel Binder的内容，它们的架构简单总结为下图。</p>
<p><a target="_blank" rel="noopener" href="https://s2.ax1x.com/2019/11/19/MgRMbF.png"><img src="https://s2.ax1x.com/2019/11/19/MgRMbF.png" alt="MgRMbF.png"></a></p>
<p>在[Android Binder原理（二）ServiceManager中的Binder机制](#Android Binder原理（二）ServiceManager中的Binder机制)这篇中，我讲过BpBinder是Client端与Server交互的代理类，而BBinder则代表了Server端，那么上图就可以改为：<br><a target="_blank" rel="noopener" href="https://s2.ax1x.com/2019/11/19/MgWuRI.png"><img src="https://s2.ax1x.com/2019/11/19/MgWuRI.png" alt="MgWuRI.png"></a><br>从上图可以看到，Native Binder实际是基于C&#x2F;S架构，Bpinder是Client端，BBinder是Server端，在[Android Binder原理（四）ServiceManager的启动过程](#Android Binder原理（四）ServiceManager的启动过程)这篇中，我们得知Native Binder通过ioctl函数和Binder驱动进行数据交互。<br>Java Binder是需要借助Native Binder来进行工作的，因此Java Binder在设计上也是一个C&#x2F;S架构，可以说Java Binder是Native Binder的一个镜像，所以在学习Java Binder前，最好先要学习此前文章讲解的Native Binder的内容。本篇文章先来讲解Java Binder是如何初始化的，即Java Binder的JNI注册。</p>
<h3 id="Java-Binder的JNI注册"><a href="#Java-Binder的JNI注册" class="headerlink" title="Java Binder的JNI注册"></a>Java Binder的JNI注册</h3><p>Java Binder要想和Native Binder进行通信，需要通过JNI，JNI的注册是在Zygote进程启动过程中注册的，代码如下所示。<br><strong>frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;AndroidRuntime.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* className, <span class="type">const</span> Vector&lt;String8&gt;&amp; options, <span class="type">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.<span class="built_in">Init</span>(<span class="literal">NULL</span>);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">startVm</span>(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;<span class="comment">//1</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">onVmCreated</span>(env);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">startReg</span>(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Unable to register all android natives\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处用于启动Java虚拟机，注释2处startReg函数用于完成虚拟机的JNI注册，关于AndroidRuntime的start函数的具体分析见[Android系统启动流程（二）解析Zygote进程启动过程](# Android系统启动流程（二）解析Zygote进程启动过程)这篇。<br>startReg函数如下所示。<br><strong>frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;AndroidRuntime.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*static*/</span> <span class="function"><span class="type">int</span> <span class="title">AndroidRuntime::startReg</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_NAME</span>(<span class="string">&quot;RegisterAndroidNatives&quot;</span>);</span><br><span class="line">    <span class="built_in">androidSetCreateThreadFunc</span>((android_create_thread_fn) javaCreateThreadEtc);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;--- registering native functions ---\n&quot;</span>);</span><br><span class="line">    env-&gt;<span class="built_in">PushLocalFrame</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">register_jni_procs</span>(gRegJNI, <span class="built_in">NELEM</span>(gRegJNI), env) &lt; <span class="number">0</span>) &#123;<span class="comment">//1</span></span><br><span class="line">        env-&gt;<span class="built_in">PopLocalFrame</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;<span class="built_in">PopLocalFrame</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处的register_jni_procs函数的作用就是循环调用gRegJNI数组的成员所对应的方法，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">register_jni_procs</span><span class="params">(<span class="type">const</span> RegJNIRec array[], <span class="type">size_t</span> count, JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i].<span class="built_in">mProc</span>(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">            <span class="built_in">ALOGD</span>(<span class="string">&quot;----------!!! %s failed to load\n&quot;</span>, array[i].mName);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gRegJNI数组中有100多个成员变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> RegJNIRec gRegJNI[] = &#123;</span><br><span class="line">    <span class="built_in">REG_JNI</span>(register_com_android_internal_os_RuntimeInit),</span><br><span class="line">    <span class="built_in">REG_JNI</span>(register_com_android_internal_os_ZygoteInit_nativeZygoteInit),</span><br><span class="line">    <span class="built_in">REG_JNI</span>(register_android_os_SystemClock),</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">REG_JNI</span>(register_android_os_Binder),<span class="comment">//1</span></span><br><span class="line">   ...</span><br><span class="line">&#125;;    </span><br></pre></td></tr></table></figure>

<p>其中REG_JNI是一个宏定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REG_JNI(name)      &#123; name &#125;</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RegJNIRec</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> (*mProc)(JNIEnv*);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实际上就是调用参数名所对应的函数。负责Java Binder和Native Binder通信的函数为注释1处的register_android_os_Binder，代码如下所示。<br><strong>frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_util_Binder.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">register_android_os_Binder</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//注册Binder类</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">int_register_android_os_Binder</span>(env) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//注册BinderInternal类        </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">int_register_android_os_BinderInternal</span>(env) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//注册BinderProxy类          </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">int_register_android_os_BinderProxy</span>(env) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>register_android_os_Binder函数做了三件事，分别是:<br>1.注册Binder类<br>2.注册BinderInternal类<br>3.注册BinderProxy类</p>
<p>它们是Java Binder关联类的一小部分，它们的关系如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://s2.ax1x.com/2019/11/22/MTmhzd.png"><img src="https://s2.ax1x.com/2019/11/22/MTmhzd.png" alt="MTmhzd.png"></a></p>
<ul>
<li>IBinder接口中定义了很多整型的变量，其中定义一个叫做<code>FLAG_ONEWAY</code>的整形变量。客户端发起调用时，客户端一般会阻塞，直到服务端返回结果。设置<code>FLAG_ONEWAY</code>后，客户端只需要把请求发送到服务端就可以立即返回，而不需要等待服务端的结果，这是一种非阻塞方式。</li>
<li>Binder和BinderProxy实现了IBinder接口，Binder是服务端的代表，而BinderProxy是客户端的代表。</li>
<li>BinderInternal只是在Binder框架中被使用，其内部类GcWatcher用于处理和Binder的垃圾回收。</li>
<li>Parcel是一个数据包装器，它可以在进程间进行传递，Parcel既可以传递基本数据类型也可以传递Binder对象，Binder通信就是通过Parcel来进行客户端与服务端数据交互。Parcel的实现既有Java部分，也有Native部分，具体实现在Native部分中。</li>
</ul>
<p>下面分别对Binder、BinderInternal这两个类的注册进行分析。</p>
<h4 id="Binder类的注册"><a href="#Binder类的注册" class="headerlink" title="Binder类的注册"></a>Binder类的注册</h4><p>调用int_register_android_os_Binder函数来完成Binder类的注册，代码如下所示。<br><strong>frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_util_Binder.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> JNINativeMethod gBinderMethods[] = &#123;</span><br><span class="line">     <span class="comment">/* name, signature, funcPtr */</span></span><br><span class="line">    &#123; <span class="string">&quot;getCallingPid&quot;</span>, <span class="string">&quot;()I&quot;</span>, (<span class="type">void</span>*)android_os_Binder_getCallingPid &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;getCallingUid&quot;</span>, <span class="string">&quot;()I&quot;</span>, (<span class="type">void</span>*)android_os_Binder_getCallingUid &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;clearCallingIdentity&quot;</span>, <span class="string">&quot;()J&quot;</span>, (<span class="type">void</span>*)android_os_Binder_clearCallingIdentity &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;restoreCallingIdentity&quot;</span>, <span class="string">&quot;(J)V&quot;</span>, (<span class="type">void</span>*)android_os_Binder_restoreCallingIdentity &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;setThreadStrictModePolicy&quot;</span>, <span class="string">&quot;(I)V&quot;</span>, (<span class="type">void</span>*)android_os_Binder_setThreadStrictModePolicy &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;getThreadStrictModePolicy&quot;</span>, <span class="string">&quot;()I&quot;</span>, (<span class="type">void</span>*)android_os_Binder_getThreadStrictModePolicy &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;flushPendingCommands&quot;</span>, <span class="string">&quot;()V&quot;</span>, (<span class="type">void</span>*)android_os_Binder_flushPendingCommands &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;getNativeBBinderHolder&quot;</span>, <span class="string">&quot;()J&quot;</span>, (<span class="type">void</span>*)android_os_Binder_getNativeBBinderHolder &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;getNativeFinalizer&quot;</span>, <span class="string">&quot;()J&quot;</span>, (<span class="type">void</span>*)android_os_Binder_getNativeFinalizer &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;blockUntilThreadAvailable&quot;</span>, <span class="string">&quot;()V&quot;</span>, (<span class="type">void</span>*)android_os_Binder_blockUntilThreadAvailable &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> kBinderPathName = <span class="string">&quot;android/os/Binder&quot;</span>;<span class="comment">//1</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">int_register_android_os_Binder</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    jclass clazz = <span class="built_in">FindClassOrDie</span>(env, kBinderPathName);<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    gBinderOffsets.mClass = <span class="built_in">MakeGlobalRefOrDie</span>(env, clazz);<span class="comment">//3</span></span><br><span class="line">    gBinderOffsets.mExecTransact = <span class="built_in">GetMethodIDOrDie</span>(env, clazz, <span class="string">&quot;execTransact&quot;</span>, <span class="string">&quot;(IJJI)Z&quot;</span>);<span class="comment">//4</span></span><br><span class="line">    gBinderOffsets.mObject = <span class="built_in">GetFieldIDOrDie</span>(env, clazz, <span class="string">&quot;mObject&quot;</span>, <span class="string">&quot;J&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RegisterMethodsOrDie</span>(</span><br><span class="line">        env, kBinderPathName,</span><br><span class="line">        gBinderMethods, <span class="built_in">NELEM</span>(gBinderMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处的kBinderPathName的值为”android&#x2F;os&#x2F;Binder”，这是Binder在Java Binder中的全路径名。<br>注释2处根据这个路径名获取Binder的Class对象，并赋值给jclass类型的变量clazz，clazz是Java层Binder在JNI层的代表。<br>注释3处通过MakeGlobalRefOrDie函数将本地引用clazz转变为全局引用并赋值给gBinderOffsets.mClass。<br>注释4处用于找到Java层的Binder的成员方法execTransact并赋值给gBinderOffsets.mExecTransact。<br>注释5处用于找到Java层的Binder的成员变量mObject并赋值给gBinderOffsets.mObject。<br>最后一行通过RegisterMethodsOrDie函数注册gBinderMethods中定义的函数，其中gBinderMethods是JNINativeMethod类型的数组，里面存储的是Binder的Native方法（Java层）与JNI层函数的对应关系。</p>
<p>gBinderMethods的定义如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">bindernative_offsets_t</span></span><br><span class="line">&#123;</span><br><span class="line">    jclass mClass;</span><br><span class="line">    jmethodID mExecTransact;</span><br><span class="line">    jfieldID mObject;</span><br><span class="line"></span><br><span class="line">&#125; gBinderOffsets;</span><br></pre></td></tr></table></figure>

<p>使用gBinderMethods来保存变量和方法有两个原因：<br>1.为了效率考虑，如果每次调用相关的方法时都需要查询方法和变量，显然效率比较低。<br>2.这些成员变量和方法都是本地引用，在int int_register_android_os_Binder函数返回时，这些本地引用会被自动释放，因此用gBinderOffsets来保存，以便于后续使用。</p>
<p>对于JNI不大熟悉的同学可以看<a target="_blank" rel="noopener" href="http://liuwangshu.cn/framework/jni/2-signature-jnienv">Android深入理解JNI（二）类型转换、方法签名和JNIEnv</a>这篇文章。</p>
<h4 id="BinderInternal类的注册"><a href="#BinderInternal类的注册" class="headerlink" title="BinderInternal类的注册"></a>BinderInternal类的注册</h4><p>调用int_register_android_os_BinderInternal函数来完成BinderInternal类的注册，代码如下所示。<br><strong>frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_util_Binder.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> kBinderInternalPathName = <span class="string">&quot;com/android/internal/os/BinderInternal&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">int_register_android_os_BinderInternal</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    jclass clazz = <span class="built_in">FindClassOrDie</span>(env, kBinderInternalPathName);</span><br><span class="line"></span><br><span class="line">    gBinderInternalOffsets.mClass = <span class="built_in">MakeGlobalRefOrDie</span>(env, clazz);</span><br><span class="line">    gBinderInternalOffsets.mForceGc = <span class="built_in">GetStaticMethodIDOrDie</span>(env, clazz, <span class="string">&quot;forceBinderGc&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    gBinderInternalOffsets.mProxyLimitCallback = <span class="built_in">GetStaticMethodIDOrDie</span>(env, clazz, <span class="string">&quot;binderProxyLimitCallbackFromNative&quot;</span>, <span class="string">&quot;(I)V&quot;</span>);</span><br><span class="line"></span><br><span class="line">    jclass SparseIntArrayClass = <span class="built_in">FindClassOrDie</span>(env, <span class="string">&quot;android/util/SparseIntArray&quot;</span>);</span><br><span class="line">    gSparseIntArrayOffsets.classObject = <span class="built_in">MakeGlobalRefOrDie</span>(env, SparseIntArrayClass);</span><br><span class="line">    gSparseIntArrayOffsets.constructor = <span class="built_in">GetMethodIDOrDie</span>(env, gSparseIntArrayOffsets.classObject,</span><br><span class="line">                                                           <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    gSparseIntArrayOffsets.put = <span class="built_in">GetMethodIDOrDie</span>(env, gSparseIntArrayOffsets.classObject, <span class="string">&quot;put&quot;</span>,</span><br><span class="line">                                                   <span class="string">&quot;(II)V&quot;</span>);</span><br><span class="line"></span><br><span class="line">    BpBinder::<span class="built_in">setLimitCallback</span>(android_os_BinderInternal_proxyLimitcallback);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RegisterMethodsOrDie</span>(</span><br><span class="line">        env, kBinderInternalPathName,</span><br><span class="line">        gBinderInternalMethods, <span class="built_in">NELEM</span>(gBinderInternalMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和int_register_android_os_Binder函数的实现类似，主要做了三件事：<br>1.获取BinderInternal在JNI层的代表clazz。<br>2.将BinderInternal类中有用的成员变量和方法存储到gBinderInternalOffsets中。<br>3.注册BinderInternal类的Native方法对应的JNI函数。</p>
<p>还有一个BinderProxy类的注册，它和Binder、BinderInternal的注册过程差不多，这里就不再赘述了，有兴趣的读者可以自行去看源码。</p>
<h2 id="Binder原理（七）Java-Binder中系统服务的注册过程"><a href="#Binder原理（七）Java-Binder中系统服务的注册过程" class="headerlink" title="Binder原理（七）Java Binder中系统服务的注册过程"></a>Binder原理（七）Java Binder中系统服务的注册过程</h2><p>在[Android Binder原理（三）系统服务的注册过程](#Android Binder原理（三）系统服务的注册过程)这篇文章中，我介绍的是Native Binder中的系统服务的注册过程，这一过程的核心是ServiceManager，而在Java Binder中，也有一个ServiceManager，只不过这个ServiceManager是Java文件。<br>既然要将系统服务注册到ServiceManager，那么需要选择一个系统服务为例，这里以常见的AMS为例。</p>
<h3 id="将AMS注册到ServiceManager"><a href="#将AMS注册到ServiceManager" class="headerlink" title="将AMS注册到ServiceManager"></a>将AMS注册到ServiceManager</h3><p>在AMS的setSystemProcess方法中，会调用ServiceManager的addService方法，如下所示。<br><strong>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;am&#x2F;ActivityManagerService.java</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">setSystemProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ServiceManager.<span class="built_in">addService</span>(Context.ACTIVITY_SERVICE, <span class="keyword">this</span>, <span class="comment">/* allowIsolated= */</span> <span class="literal">true</span>,</span><br><span class="line">                DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PRIORITY_NORMAL | DUMP_FLAG_PROTO);<span class="comment">//1</span></span><br><span class="line">       ....</span><br><span class="line">    &#125; <span class="built_in">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RuntimeException</span>(</span><br><span class="line">                <span class="string">&quot;Unable to find android system package&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处的<code>Context.ACTIVITY_SERVICE</code>的值为”activity”，作用就是将AMS注册到ServiceManager中。接着来看<br>ServiceManager的addService方法。<br><strong>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;ServiceManager.java</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service, boolean allowIsolated,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> dumpPriority)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">getIServiceManager</span>().<span class="built_in">addService</span>(name, service, allowIsolated, dumpPriority);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Log.<span class="built_in">e</span>(TAG, <span class="string">&quot;error in addService&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要分析getIServiceManager方法返回的是什么，代码如下所示。<br><strong>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;ServiceManager.java</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">static</span> IServiceManager <span class="title">getIServiceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (sServiceManager != null) &#123;</span><br><span class="line">         <span class="keyword">return</span> sServiceManager;</span><br><span class="line">     &#125;</span><br><span class="line">     sServiceManager = ServiceManagerNative</span><br><span class="line">             .<span class="built_in">asInterface</span>(Binder.<span class="built_in">allowBlocking</span>(BinderInternal.<span class="built_in">getContextObject</span>()));</span><br><span class="line">     <span class="keyword">return</span> sServiceManager;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>讲到这里，已经积累了几个点需要分析，分别是：</p>
<ul>
<li>BinderInternal.getContextObject()</li>
<li>ServiceManagerNative.asInterface()</li>
<li>getIServiceManager().addService()</li>
</ul>
<p>现在我们来各个击破它们。</p>
<h4 id="BinderInternal-getContextObject"><a href="#BinderInternal-getContextObject" class="headerlink" title="BinderInternal.getContextObject()"></a>BinderInternal.getContextObject()</h4><p>Binder.allowBlocking的作用是将BinderProxy的sWarnOnBlocking值置为false。主要来分析BinderInternal.getContextObject()做了什么，这个方法是一个Native方法，找到它对应的函数：<br><strong>frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_util_Binder.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> JNINativeMethod gBinderInternalMethods[] = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;getContextObject&quot;</span>, <span class="string">&quot;()Landroid/os/IBinder;&quot;</span>, (<span class="type">void</span>*)android_os_BinderInternal_getContextObject &#125;,</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对应的函数为android_os_BinderInternal_getContextObject：<br><strong>frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_util_Binder.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jobject <span class="title">android_os_BinderInternal_getContextObject</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; b = ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">getContextObject</span>(<span class="literal">NULL</span>);<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">javaObjectForIBinder</span>(env, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProcessState::self()的作用是创建ProcessState，注释1处最终返回的是BpBinder，不理解的可以查看[Android Binder原理（二）ServiceManager中的Binder机制](#Android Binder原理（二）ServiceManager中的Binder机制)这篇文章。</p>
<p>BpBinder是Native Binder中的Client端，这说明Java层的ServiceManager需要Native层的BpBinder，但是这个BpBinder在Java层是无法直接使用，那么就需要传入javaObjectForIBinder函数来做处理，其内部会创建一个BinderProxy对象，这样我们得知 BinderInternal.getContextObject()最终得到的是BinderProxy。<br>在[Android Binder原理（六）Java Binder的初始化](#Android Binder原理（六）Java Binder的初始化)这篇文章我们讲过，BinderProxy是Java Binder的客户端的代表。<br>需要注意的一点是，这个传入的BpBinder会保存到BinderProxy的成员变量mObject中，后续会再次提到这个点。</p>
<h4 id="ServiceManagerNative-asInterface"><a href="#ServiceManagerNative-asInterface" class="headerlink" title="ServiceManagerNative.asInterface()"></a>ServiceManagerNative.asInterface()</h4><p>说到asInterface方法，在Native Binder中也有一个asInterface函数。在[Android Binder原理（二）ServiceManager中的Binder机制](#Android Binder原理（二）ServiceManager中的Binder机制)这篇文章中讲过IServiceManager的asInterface函数，它的作用是用BpBinder做为参数创建BpServiceManager。那么在Java Binder中的asInterface方法的作用又是什么？<br><strong>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;ServiceManagerNative.java</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">public</span> IServiceManager <span class="title">asInterface</span><span class="params">(IBinder obj)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (obj == null) &#123;</span><br><span class="line">         <span class="keyword">return</span> null;</span><br><span class="line">     &#125;</span><br><span class="line">     IServiceManager in =</span><br><span class="line">         (IServiceManager)obj.<span class="built_in">queryLocalInterface</span>(descriptor);</span><br><span class="line">     <span class="keyword">if</span> (in != null) &#123;</span><br><span class="line">         <span class="keyword">return</span> in;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ServiceManagerProxy</span>(obj);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>根据1.1小节，我们得知obj的值为BinderProxy，那么asInterface方法的作用就是用BinderProxy作为参数创建ServiceManagerProxy。<br>BinderProxy和BpBinder分别在Jave Binder和Native Binder作为客户端的代表，BpServiceManager通过BpBinder来实现通信，同样的，ServiceManagerProxy也会将业务的请求交给BinderProxy来处理。<br>分析到这里，那么：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sServiceManager = ServiceManagerNative</span><br><span class="line">        .<span class="built_in">asInterface</span>(Binder.<span class="built_in">allowBlocking</span>(BinderInternal.<span class="built_in">getContextObject</span>()));</span><br></pre></td></tr></table></figure>

<p>可以理解为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    sServiceManager = <span class="keyword">new</span> ServiceManagerProxy（BinderProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getIServiceManager-addService"><a href="#getIServiceManager-addService" class="headerlink" title="getIServiceManager().addService()"></a>getIServiceManager().addService()</h4><p>根据1.2节的讲解，getIServiceManager()返回的是ServiceManagerProxy，ServiceManagerProxy是ServiceManagerNative的内部类，它实现了IServiceManager接口。</p>
<p>来查看ServiceManagerProxy的addService方法，<br><strong>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;ServiceManagerNative.java::ServiceManagerProxy</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service, boolean allowIsolated, <span class="type">int</span> dumpPriority)</span></span></span><br><span class="line"><span class="function">        throws RemoteException </span>&#123;</span><br><span class="line">    Parcel data = Parcel.<span class="built_in">obtain</span>();</span><br><span class="line">    Parcel reply = Parcel.<span class="built_in">obtain</span>();</span><br><span class="line">    data.<span class="built_in">writeInterfaceToken</span>(IServiceManager.descriptor);</span><br><span class="line">    data.<span class="built_in">writeString</span>(name);</span><br><span class="line">    data.<span class="built_in">writeStrongBinder</span>(service);<span class="comment">//1</span></span><br><span class="line">    data.<span class="built_in">writeInt</span>(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    data.<span class="built_in">writeInt</span>(dumpPriority);</span><br><span class="line">    mRemote.<span class="built_in">transact</span>(ADD_SERVICE_TRANSACTION, data, reply, <span class="number">0</span>);<span class="comment">//2</span></span><br><span class="line">    reply.<span class="built_in">recycle</span>();</span><br><span class="line">    data.<span class="built_in">recycle</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处的data.writeStrongBinder很关键，后续会进行分析。这里又看到了Parcel，它是一个数据包装器，将请求数据写入到Parcel类型的对象data中，通过注释1处的mRemote.transact发送出去，mRemote实际上是BinderProxy，BinderProxy.transact是native函数，实现的函数如下所示。<br><strong>frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_util_Binder.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="params"><span class="function">        jint code, jobject dataObj, jobject replyObj, jint flags)</span> <span class="comment">// throws RemoteException</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dataObj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">jniThrowNullPointerException</span>(env, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    Parcel* data = <span class="built_in">parcelForJavaObject</span>(env, dataObj);<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    Parcel* reply = <span class="built_in">parcelForJavaObject</span>(env, replyObj);<span class="comment">//2</span></span><br><span class="line">    <span class="keyword">if</span> (reply == <span class="literal">NULL</span> &amp;&amp; replyObj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    IBinder* target = <span class="built_in">getBPNativeData</span>(env, obj)-&gt;mObject.<span class="built_in">get</span>();<span class="comment">//3</span></span><br><span class="line">    <span class="keyword">if</span> (target == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">jniThrowException</span>(env, <span class="string">&quot;java/lang/IllegalStateException&quot;</span>, <span class="string">&quot;Binder has been finalized!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">    <span class="type">status_t</span> err = target-&gt;<span class="built_in">transact</span>(code, *data, reply, flags);<span class="comment">//4</span></span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1和注释2处，将Java层的Parcel对象转化成为Native层的Parcel对象。在1.1小节中，我们得知BpBinder会保存到BinderProxy的成员变量mObject中，因此在注释3处，从BinderProxy的成员变量mObject中获取BpBinder。最终会在注释4处调用BpBinder的transact函数，向Binder驱动发送数据，可以看出Java Binder是需要Native Binder支持的，最终的目的就是向Binder驱动发送和接收数据。</p>
<h3 id="引出JavaBBinder"><a href="#引出JavaBBinder" class="headerlink" title="引出JavaBBinder"></a>引出JavaBBinder</h3><p>接着回过头来分析1.3小节遗留下来的data.writeStrongBinder(service)，代码如下所示。<br><strong>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;Parcel.java</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">void</span> <span class="title">writeStrongBinder</span><span class="params">(IBinder ll)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">nativeWriteStrongBinder</span>(mNativePtr, val);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>nativeWriteStrongBinder是Native方法，实现的函数为android_os_Parcel_writeStrongBinder：<br><strong>frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_os_Parcel.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">android_os_Parcel_writeStrongBinder</span><span class="params">(JNIEnv* env, jclass clazz, jlong nativePtr, jobject object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel* parcel = <span class="built_in">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    <span class="keyword">if</span> (parcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">status_t</span> err = parcel-&gt;<span class="built_in">writeStrongBinder</span>(<span class="built_in">ibinderForJavaObject</span>(env, object));<span class="comment">//1</span></span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            <span class="built_in">signalExceptionForError</span>(env, clazz, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着查看注释1处ibinderForJavaObject函数：<br><strong>frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_util_Binder.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ibinderForJavaObject</span><span class="params">(JNIEnv* env, jobject obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">IsInstanceOf</span>(obj, gBinderOffsets.mClass)) &#123;<span class="comment">//1</span></span><br><span class="line">        JavaBBinderHolder* jbh = (JavaBBinderHolder*)</span><br><span class="line">            env-&gt;<span class="built_in">GetLongField</span>(obj, gBinderOffsets.mObject);</span><br><span class="line">        <span class="keyword">return</span> jbh-&gt;<span class="built_in">get</span>(env, obj);<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">IsInstanceOf</span>(obj, gBinderProxyOffsets.mClass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getBPNativeData</span>(env, obj)-&gt;mObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGW</span>(<span class="string">&quot;ibinderForJavaObject: %p is not a Binder object&quot;</span>, obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释2处，如果obj是Java层的BinderProxy类，则返回BpBinder。<br>注释1处，如果obj是Java层的Binder类，那么先获取JavaBBinderHolder对象，然后在注释2处调用JavaBBinderHolder的get函数，代码如下所示。<br><strong>frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_util_Binder.cpp::JavaBBinderHolder</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JavaBBinderHolder</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">sp&lt;JavaBBinder&gt; <span class="title">get</span><span class="params">(JNIEnv* env, jobject obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        sp&lt;JavaBBinder&gt; b = mBinder.<span class="built_in">promote</span>();<span class="comment">//1</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//obj是一个Java层Binder对象</span></span><br><span class="line">            b = <span class="keyword">new</span> <span class="built_in">JavaBBinder</span>(env, obj);<span class="comment">//2</span></span><br><span class="line">            mBinder = b;</span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;Creating JavaBinder %p (refs %p) for Object %p, weakCount=%&quot;</span> PRId32 <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                 b.<span class="built_in">get</span>(), b-&gt;<span class="built_in">getWeakRefs</span>(), obj, b-&gt;<span class="built_in">getWeakRefs</span>()-&gt;<span class="built_in">getWeakCount</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">sp&lt;JavaBBinder&gt; <span class="title">getExisting</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        <span class="keyword">return</span> mBinder.<span class="built_in">promote</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex           mLock;</span><br><span class="line">    wp&lt;JavaBBinder&gt; mBinder;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>成员变量mBinder是<code>wp&lt;JavaBBinder&gt;</code>类型的弱引用，在注释1处得到<code>sp&lt;JavaBBinder&gt;</code>类型的强引用b，在注释2处创建JavaBBinder并赋值给b。那么，JavaBBinderHolder的get函数返回的是JavaBBinder。</p>
<p>data.writeStrongBinder(service)在本文中等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.writeStrongBinder(new JavaBBinder(env，Binder))。</span><br></pre></td></tr></table></figure>

<p>讲到这里可以得知ServiceManager.addService()传入的并不是AMS本身，而是JavaBBinder。</p>
<h3 id="解析JavaBBinder"><a href="#解析JavaBBinder" class="headerlink" title="解析JavaBBinder"></a>解析JavaBBinder</h3><p>接着来分析JavaBBinder，查看它的构造函数：<br><strong>frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_util_Binder.cpp::JavaBBinderHolder::JavaBBinder</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JavaBBinder</span> : <span class="keyword">public</span> BBinder</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">JavaBBinder</span>(JNIEnv* env, jobject <span class="comment">/* Java Binder */</span> c)</span><br><span class="line">        : <span class="built_in">mVM</span>(<span class="built_in">jnienv_to_javavm</span>(env)), <span class="built_in">mObject</span>(env-&gt;<span class="built_in">NewGlobalRef</span>(object))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;Creating JavaBBinder %p\n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">        gNumLocalRefsCreated.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">        <span class="built_in">gcIfManyNewRefs</span>(env);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以发现JavaBBinder继承了BBinder，那么JavaBBinder的作用是什么呢？当Binder驱动得到客户端的请求，紧接着会将响应发送给JavaBBinder，这时会调用JavaBBinder的onTransact函数，代码如下所示。<br><strong>frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_util_Binder.cpp::JavaBBinderHolder::JavaBBinder</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">onTransact</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, Parcel* reply, <span class="type">uint32_t</span> flags = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">   </span>&#123;                            </span><br><span class="line">       JNIEnv* env = <span class="built_in">javavm_to_jnienv</span>(mVM);</span><br><span class="line">       <span class="built_in">ALOGV</span>(<span class="string">&quot;onTransact() on %p calling object %p in env %p vm %p\n&quot;</span>, <span class="keyword">this</span>, mObject, env, mVM);</span><br><span class="line">       IPCThreadState* thread_state = IPCThreadState::<span class="built_in">self</span>();</span><br><span class="line">       <span class="type">const</span> <span class="type">int32_t</span> strict_policy_before = thread_state-&gt;<span class="built_in">getStrictModePolicy</span>();</span><br><span class="line">       jboolean res = env-&gt;<span class="built_in">CallBooleanMethod</span>(mObject, gBinderOffsets.mExecTransact,</span><br><span class="line">           code, <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(&amp;data), <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(reply), flags);<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">return</span> res != JNI_FALSE ? NO_ERROR : UNKNOWN_TRANSACTION;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在注释1处会调用Java层Binder的execTransact函数：<br><strong>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;Binder.java</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> boolean <span class="title">execTransact</span><span class="params">(<span class="type">int</span> code, <span class="type">long</span> dataObj, <span class="type">long</span> replyObj,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">int</span> flags)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (tracingEnabled) &#123;</span><br><span class="line">                Trace.<span class="built_in">traceBegin</span>(Trace.TRACE_TAG_ALWAYS, <span class="built_in">getClass</span>().<span class="built_in">getName</span>() + <span class="string">&quot;:&quot;</span> + code);</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">onTransact</span>(code, data, reply, flags);<span class="comment">//1</span></span><br><span class="line">        &#125; <span class="built_in">catch</span> (RemoteException|RuntimeException e) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">       ...</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>关键点是注释1处的onTransact函数，AMS实现了onTransact函数，从而完成业务实现。<br>从这里可有看出，JavaBBinder并没有实现什么业务，当它接收到请求时，会调用Binder类的execTransact函数，execTransact函数内部又调用了onTransact函数，系统服务会重写onTransact函数来实现自身的业务功能。</p>
<h3 id="Java-Binder架构"><a href="#Java-Binder架构" class="headerlink" title="Java Binder架构"></a>Java Binder架构</h3><p>Binder架构如下图所示。<br><a target="_blank" rel="noopener" href="https://s2.ax1x.com/2019/12/02/Qud4yt.png"><img src="https://s2.ax1x.com/2019/12/02/Qud4yt.png" alt="Qud4yt.png"></a></p>
<p>Native Binder的部分在此前的文章已经讲过，这里主要来说说Java Binder部分，从图中可以看到：<br>1.Binder是服务端的代表，JavaBBinder继承BBinder，JavaBBinder通过mObject变量指向Binder。<br>2.BinderProxy是客户端的代表，ServiceManager的addService等方法会交由ServiceManagerProxy处理。<br>3.ServiceManagerProxy的成员变量mRemote指向BinderProxy对象，所以ServiceManagerProxy的addService等方法会交由BinderProxy来处理。<br>4.BinderProxy的成员变量mObject指向BpBinder对象，因此BinderProxy可以通过BpBinder和Binder驱动发送数据。</p>
<h1 id="Zygote"><a href="#Zygote" class="headerlink" title="Zygote"></a>Zygote</h1><h2 id="Zygote-一-：Android系统的启动过程及Zygote的启动过程"><a href="#Zygote-一-：Android系统的启动过程及Zygote的启动过程" class="headerlink" title="Zygote(一)：Android系统的启动过程及Zygote的启动过程"></a>Zygote(一)：Android系统的启动过程及Zygote的启动过程</h2><h3 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a>init进程</h3><p>作为Android开发者和Android使用者，相信每个人都接触过多种Android设备，不管是哪种品牌、哪种类型的Android设置，在使用之前都要完成开机操作，对于普通用户来说开机只是一个操作过程，但对于开发者有没有想过Android是如何开机的？是如何从断电状态启动到可操作交互的？开发者都听过init进程、孵化器进程已经开发中使用的各种服务，那么它们又是如何启动如何工作的呢？带着这些问题进入本篇文章的主题Androdi系统的启动过程；</p>
<ul>
<li>Android系统的启动过程总结</li>
</ul>
<ol>
<li>启动电源：按下电源后，程序从固定地方开始加载引导程序到RAM中</li>
<li>引导程序BootLoader：Android系统开始执行引导程序，并同时拉起并运行系统的OS</li>
<li>Linux内核启动：当内核启动完成后，首先寻找init.rc配置文件并启动init进程</li>
<li>init进程启动：在init进程中完成属性服务的初始、Zygote进程的启动</li>
</ol>
<p>由上面的程序启动过程知道，程序在执行完引导程序并启动内核后，首先会查找init文件，在init文件中首先执行main（）方法</p>
<ul>
<li>init.main（）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">property_init();<span class="comment">//1</span></span><br><span class="line">......</span><br><span class="line">sigchld_handler_init();<span class="comment">//2</span></span><br><span class="line">......</span><br><span class="line">start_property_service();</span><br><span class="line">......</span><br><span class="line">LoadBootScripts(am, sm);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">LoadBootScripts</span><span class="params">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> &#123;</span><br><span class="line">    <span class="type">Parser</span> <span class="variable">parser</span> <span class="operator">=</span> CreateParser(action_manager, service_list);</span><br><span class="line">    parser.ParseConfig(<span class="string">&quot;/init.rc&quot;</span>); <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main（）函数中主要执行一下操作：</p>
<ol>
<li>初始化和启动属性服务</li>
<li>设置进程信号处理</li>
<li>解析init.rc配置文件</li>
</ol>
<h4 id="属性服务初始化与启动"><a href="#属性服务初始化与启动" class="headerlink" title="属性服务初始化与启动"></a>属性服务初始化与启动</h4><ul>
<li>属性服务的初始化</li>
</ul>
<ol>
<li>创建非阻塞的Socket</li>
<li>调用listen函数对对属性进行监听</li>
<li>当有数据更新时，init进程会调用handle_property_set_fd函数进行处理</li>
</ol>
<ul>
<li>处理客户端请求</li>
</ul>
<ol>
<li>服务属性接收到客户端请求时调用handle_property_set_fd（）处理数据</li>
<li>根据属性分类处理：普通属性、控制属性</li>
</ol>
<h4 id="设置进程信号处理"><a href="#设置进程信号处理" class="headerlink" title="设置进程信号处理"></a>设置进程信号处理</h4><ul>
<li>僵尸进程：父进程通过Fork创建子进程，当子进程终止之后，如果父进程不知道此时子进程已结束，此时系统中会仍然保存着进程的信息，那么子进程就会成为僵尸进程</li>
</ul>
<ol>
<li>僵尸进程危害：系统资源有限，僵尸进程会占用系统资源，当资源耗尽时系统将无法创建新的进程</li>
</ol>
<p>由僵尸进程的定义知道，出现僵尸进程的原因就是父进程与子进程之间通信中断，signal_handler_init函数就是在父进程中监听子进程的状态，在子进程暂停或终止时会发送SIGCHLD信号，signal_handler_init会接收和处理信号，当接收到子进程终止时及时的释放资源</p>
<h4 id="解析init配置文件"><a href="#解析init配置文件" class="headerlink" title="解析init配置文件"></a>解析init配置文件</h4><p>配置文件的解析和处理也是init进程中最主要的部分，安卓中将系统的配置文件保存在init.rc文件中，而Android 8.0之后对init.rc文件浸信会拆分，将每个服务以启动脚本的形式单独存在，然后在init.rc中引入所需要的服务脚本，在启动的时候就可以实现所有服务的启动，这里以接下来要分析的Zygote的启动脚本为例，看看系统是如何定义和处理脚本的</p>
<ul>
<li>启动脚本——init.zygote64.rc</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">main</span></span><br><span class="line">    priority -<span class="number">20</span></span><br><span class="line">    user root</span><br><span class="line">    group root readproc reserved_disk</span><br><span class="line">    socket zygote stream <span class="number">660</span> root system</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    onrestart restart wificond</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br></pre></td></tr></table></figure>

<p>启动脚本中参数介绍：</p>
<ol>
<li>zygote：创建的进程名称</li>
<li>&#x2F;system&#x2F;bin&#x2F;app_process64 ：执行的文件路径</li>
<li>class main：表示Zygote的classname为main，后面会根据main查找Zygote服务</li>
<li>onrestart：当服务启动时需要重启的服务</li>
</ol>
<p>上面启动脚本文件的名称为init.zygote64.rc，脚本文件名称表示只支持64系统，不过有的启动过脚本会同时支持32为和64为系统，如init.zygote64_32.rc</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">main</span></span><br><span class="line">      ......</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br><span class="line"></span><br><span class="line">service zygote_secondary /system/bin/app_process32 -Xzygote /system/bin --zygote --socket-name=zygote_secondary --enable-lazy-preload</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">main</span></span><br><span class="line">      .......</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br></pre></td></tr></table></figure>

<p>init.zygote64_32.rc脚本文件中有有两个Zygote服务，一个主模式支持64位的名为zygote进程，另一个辅模式支持32为名为zygote_secondary进程，系统会根据设备的属性决定启动的服务；</p>
<ul>
<li>解析启动脚本</li>
</ul>
<p>init进程中会使用ServerParse对Service的启动脚本进行解析，最终会针对启动脚本中的每个服务创建对应的实例，然后将所有的对象实例缓存在Service裢表中，在启动服务时就会从此列表中查找对应的服务对象；</p>
<h3 id="Zygote进程启动"><a href="#Zygote进程启动" class="headerlink" title="Zygote进程启动"></a>Zygote进程启动</h3><p>在init.rc文件中引入Zygote的启动脚本，所以在解析init.rc配置文件的服务时，就会将Zygote启动脚本中的服务解析保存在Service的裢表中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> /init.$&#123;ro.zygote&#125;.rc</span><br></pre></td></tr></table></figure>

<ul>
<li>init启动Zygote进程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">on nonencrypted</span><br><span class="line">    class_start main</span><br><span class="line">    class_start late_start</span><br></pre></td></tr></table></figure>

<p>在解析服务后，会继续init.rc配置文件中的程序，程序执行class_start main，由前面的服务脚本可知classnam为main代表的时Zygote服务，所以此处代表启动Zygote进程，首先会遍历前面保存解析Service的链表，查找classname为main（）的服务，然后执行Service中的start（）方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Result&lt;Success&gt; Service::Start() &#123;</span><br><span class="line"><span class="type">pid_t</span> <span class="variable">pid</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (namespace_flags_) &#123;</span><br><span class="line">        pid = clone(nullptr, nullptr, namespace_flags_ | SIGCHLD, nullptr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pid = fork(); <span class="comment">//1、</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">//2、</span></span><br><span class="line">    <span class="keyword">if</span> (!ExpandArgsAndExecv(args_)) &#123;</span><br><span class="line">            PLOG(ERROR) &lt;&lt; <span class="string">&quot;cannot execve(&#x27;&quot;</span> &lt;&lt; args_[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;&#x27;)&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> bool <span class="title function_">ExpandArgsAndExecv</span><span class="params">(const std::vector&lt;std::string&gt;&amp; args)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> execv(c_strings[<span class="number">0</span>], c_strings.data()) == <span class="number">0</span>; <span class="comment">//3、</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在statr（）方法中，首先判断进程是否已经运行，对未运行的进程通过fork（）创建子进程，创建成功后调用ExpandArgsAndExecv（）方法，在ExpandArgsAndExecv（）中调用执行execv（）后Service进程就被启动并进入Service的main（）方法，Zygote进程对应的程序路径为app_main.cpp,在app_main.cpp的main（）方法中调用runtime.start()启动进程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* const argv[])</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strcmp(arg, <span class="string">&quot;--zygote&quot;</span>) == <span class="number">0</span>) &#123; <span class="comment">//1</span></span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(arg, <span class="string">&quot;--start-system-server&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(arg, <span class="string">&quot;--application&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            application = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strncmp(arg, <span class="string">&quot;--nice-name=&quot;</span>, <span class="number">12</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            niceName.setTo(arg + <span class="number">12</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strncmp(arg, <span class="string">&quot;--&quot;</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            className.setTo(arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">       runtime.start(<span class="string">&quot;com.android.internal.os.ZygoteInit&quot;</span>, args, zygote);</span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure>

<p>在app_main文件的main（）方法中，首先根据进程的名称判断当前是否为Zyote进程，并赋值zygote为true，然后调用runtime.start（）启动进程，注意这里的参数传入的是ZygoteInit类的全路径，这里先猜测下最后是根据全路径反射执行ZygoteInit方法，接着看runtime，这里的runtime指的是AndroidRuntime</p>
<ul>
<li>AndroidRuntime.start（）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AndroidRuntime::start(const <span class="type">char</span>* className, const Vector&lt;String8&gt;&amp; options, bool zygote)&#123;</span><br><span class="line"> JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.Init(NULL);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123; <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    onVmCreated(env);</span><br><span class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123; <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* slashClassName = toSlashClassName(className != NULL ? className : <span class="string">&quot;&quot;</span>);<span class="comment">//3</span></span><br><span class="line"><span class="type">jclass</span> <span class="variable">startClass</span> <span class="operator">=</span> env-&gt;FindClass(slashClassName);<span class="comment">// 4</span></span><br><span class="line"><span class="type">jmethodID</span> <span class="variable">startMeth</span> <span class="operator">=</span> env-&gt;GetStaticMethodID(startClass, <span class="string">&quot;main&quot;</span>,</span><br><span class="line">            <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>); <span class="comment">// 5</span></span><br><span class="line">   <span class="keyword">if</span> (startMeth == NULL) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;JavaVM unable to find main() in &#x27;%s&#x27;\n&quot;</span>, className);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray); <span class="comment">//6</span></span><br><span class="line">         <span class="keyword">if</span> (env-&gt;ExceptionCheck())</span><br><span class="line">            threadExitUncaughtException(env);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在AndroidRuntime的start()方法中，执行了Zygote进程的主要逻辑：</p>
<ol>
<li>启动Java虚拟机</li>
<li>为Java虚拟机注册JNI方法</li>
<li>通过JNI调用Java层ZygoteInit类中的方法完成进程的启动，此时程序由native进入Java层</li>
</ol>
<ul>
<li>ZygoteInit</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String argv[])</span> &#123;</span><br><span class="line">   <span class="type">ZygoteServer</span> <span class="variable">zygoteServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZygoteServer</span>();<span class="comment">//1</span></span><br><span class="line">   zygoteServer.registerServerSocketFromEnv(socketName);</span><br><span class="line"></span><br><span class="line">   preload(bootTimingsTraceLog);<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">     <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> forkSystemServer(abiList, socketName, zygoteServer);<span class="comment">//3</span></span><br><span class="line">     <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">   caller = zygoteServer.runSelectLoop(abiList); <span class="comment">//4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序进入Java层执行ZygoteInit.main（）方法，在main（）中主要执行：</p>
<ol>
<li>首先创建并注册Service端的Socket，此Socket用于相应AMS请求创建进程</li>
<li>预加载类和资源</li>
<li>调用forkSystemServer（）启动SystemServer进程</li>
<li>执行zygoteServer.runSelectLoop（）循环等待AMS请求创建新的应用进程</li>
</ol>
<p>关于ZygoteServer的注册和循环等待AMS创建进程的部分之后在<a target="_blank" rel="noopener" href="https://blog.csdn.net/Alexwll/article/details/100133553">应用进程的启动过程</a>中介绍，这里先来看看startSystemServer（）启动SystemServer进程部分；</p>
<h4 id="SystemServer启动过程"><a href="#SystemServer启动过程" class="headerlink" title="SystemServer启动过程"></a>SystemServer启动过程</h4><p>SystemServer进程主要用于创建系统服务，如：AMS、WMS、PMS等都由SystemServer启动，由上面知道系统会调用forkSystemServer（）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title function_">forkSystemServer</span><span class="params">(String abiList, String socketName,</span></span><br><span class="line"><span class="params">       ZygoteServer zygoteServer)</span> &#123;</span><br><span class="line">      String args[] = &#123; <span class="comment">//1</span></span><br><span class="line">            <span class="string">&quot;--setuid=1000&quot;</span>,</span><br><span class="line">            <span class="string">&quot;--setgid=1000&quot;</span>,</span><br><span class="line">            <span class="string">&quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,1024,1032,1065,3001,3002,3003,3006,3007,3009,3010&quot;</span>,</span><br><span class="line">            <span class="string">&quot;--capabilities=&quot;</span> + capabilities + <span class="string">&quot;,&quot;</span> + capabilities,</span><br><span class="line">            <span class="string">&quot;--nice-name=system_server&quot;</span>,</span><br><span class="line">            <span class="string">&quot;--runtime-args&quot;</span>,</span><br><span class="line">            <span class="string">&quot;--target-sdk-version=&quot;</span> + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT,</span><br><span class="line">            <span class="string">&quot;com.android.server.SystemServer&quot;</span>,</span><br><span class="line">        &#125;;    </span><br><span class="line">       parsedArgs = <span class="keyword">new</span> <span class="title class_">ZygoteConnection</span>.Arguments(args);  <span class="comment">//2 </span></span><br><span class="line">       pid = Zygote.forkSystemServer(  <span class="comment">//3</span></span><br><span class="line">                    parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                    parsedArgs.gids,</span><br><span class="line">                    parsedArgs.runtimeFlags,</span><br><span class="line">                    <span class="literal">null</span>,</span><br><span class="line">                    parsedArgs.permittedCapabilities,</span><br><span class="line">                    parsedArgs.effectiveCapabilities); </span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> handleSystemServerProcess(parsedArgs);<span class="comment">//4</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在forkSystemServer（）方法中首先将启动参数封装在数组中，然后使用数组创建ZygoteConnection.Arguments对象，最后调用Zygote.forkSystemServer方法fok SystemServer进程，在forkSystemServer（）中调用nativeForkSystemServer（）方法实现进程创建，fork进程成功后调用handleSystemServerProcess（）处理进程中的工作；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title function_">handleSystemServerProcess</span><span class="params">(ZygoteConnection.Arguments parsedArgs)</span> &#123;</span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (systemServerClasspath != <span class="literal">null</span>) &#123;</span><br><span class="line">               cl = createPathClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion);</span><br><span class="line">               Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在handleSystemServerProcess（）中首先创建PathClassLoader对象，然后调用ZygoteInit.zygoteInit（）方法</p>
<ul>
<li>ZygoteInit.zygoteInit</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable <span class="title function_">zygoteInit</span><span class="params">(<span class="type">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span> &#123;</span><br><span class="line">        ZygoteInit.nativeZygoteInit(); <span class="comment">//1、</span></span><br><span class="line">        <span class="keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);<span class="comment">//2、</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在zygoteInit（）中调用nativeZygoteInit（）方法，从名字上看出调用的是native方法，在内部通过JNI方法完成Binder线程池的创建，在方法的最后调用RuntimeInit.applicationInit（）方法传入ClassLoader，applicationInit（）方法相对比较特殊，下面一起看下源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title function_">applicationInit</span><span class="params">(<span class="type">int</span> targetSdkVersion, String[] argv,</span></span><br><span class="line"><span class="params">            ClassLoader classLoader)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Arguments</span> <span class="variable">args</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arguments</span>(argv);</span><br><span class="line">        <span class="keyword">return</span> findStaticMain(args.startClass, args.startArgs, classLoader);<span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title function_">findStaticMain</span><span class="params">(String className, String[] argv,</span></span><br><span class="line"><span class="params">            ClassLoader classLoader)</span> &#123;</span><br><span class="line">        Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cl = Class.forName(className, <span class="literal">true</span>, classLoader);<span class="comment">//2</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                    <span class="string">&quot;Missing class when invoking static main &quot;</span> + className,</span><br><span class="line">                    ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method m;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m = cl.getMethod(<span class="string">&quot;main&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String[].class &#125;);<span class="comment">//3</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                    <span class="string">&quot;Missing static main on &quot;</span> + className, ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                    <span class="string">&quot;Problem getting static main on &quot;</span> + className, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> m.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                    <span class="string">&quot;Main method is not public and static on &quot;</span> + className);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MethodAndArgsCaller</span>(m, argv); <span class="comment">//4</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>applicationInit（）中调用了findStaticMain（）方法，findStaticMain（）并没有直接调用SystemServer.main（）方法，而是通过反射获取SystemServer的Class，然后获取main（）方法，并将main方法和参数封装在MethodAndArgsCaller中，这一点Android P中做了修改，之前的版本中将反射main方法封装在异常中抛出，然后捕捉异常执行，Android P返回了MethodAndArgsCaller对象，MethodAndArgsCaller继承实现Runnable，其实在前面ZygoteInit类中，有一段代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">                <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>整个SystemServer继承的启动是从调用forkSystemServer（）开始的，forkSystemServer返回了Runnable对象，这里的Runnable对象就是上面创建的MethodAndArgsCaller对象，然后调用run（）方法执行MethodAndArgsCaller对象；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MethodAndArgsCaller</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Method mMethod;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String[] mArgs;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MethodAndArgsCaller</span><span class="params">(Method method, String[] args)</span> &#123;</span><br><span class="line">            mMethod = method;</span><br><span class="line">            mArgs = args;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mMethod.invoke(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; mArgs &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在MethodAndArgsCaller中保存了反射获取的Method，这里的Method就是SystemServer.main（）方法，在run方法中调用method.invoke（）执行main方法，反射执行之后程序进入SystemServer.main（）,main中创建SystemServer对象，并执行run（）方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SystemServer</span>().run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>SystemServer.run（）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mSystemServiceManager = <span class="keyword">new</span> <span class="title class_">SystemServiceManager</span>(mSystemContext); <span class="comment">//1</span></span><br><span class="line"><span class="comment">// Start services.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            startBootstrapServices();<span class="comment">//2</span></span><br><span class="line">            startCoreServices();<span class="comment">//3</span></span><br><span class="line">            startOtherServices();<span class="comment">//4</span></span><br><span class="line">            SystemServerInitThreadPool.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; </span><br></pre></td></tr></table></figure>

<p>main（）方法中直接调用SystemServer.run（）方法，在run（）方法中，首先创建系统的SystemServiceManager对象，然后依次调用方法启动引导服务、启动核心服务、启动其他服务</p>
<ul>
<li>启动服务过程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mSystemServiceManager.startService(PowerManagerService.class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> SystemService <span class="title function_">startService</span><span class="params">(String className)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;SystemService&gt; serviceClass;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serviceClass = (Class&lt;SystemService&gt;)Class.forName(className);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> startService(serviceClass);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>系统调用SystemServerManager.startService（）传入对应的服务，在startService（）中根据传入的类名加载类文件，然后执行startService(serviceClass)方法，startService中使用加载的Class获取构造函数并创建对象，然后调用startService(service)；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// startService中</span></span><br><span class="line">Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class);</span><br><span class="line">service = constructor.newInstance(mContext);</span><br><span class="line">startService(service);</span><br><span class="line"><span class="keyword">return</span> service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startService</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> SystemService service)</span> &#123;</span><br><span class="line">        mServices.add(service); <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            service.onStart();<span class="comment">//2</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在startService（）中，先将service注册到mServices中，然后调用service.onStart（）方法启动服务；</p>
<p>Android系统指执行到此后会使用ServiceManager启动一系列的服务，这些都是位置Android系统运行的核心功能，之后有时间会逐个分析，本次Android系统的启动过程及Zygote的启动过程就介绍完毕了！</p>
<h2 id="Zygote（二）：应用进程的启动过程"><a href="#Zygote（二）：应用进程的启动过程" class="headerlink" title="Zygote（二）：应用进程的启动过程"></a>Zygote（二）：应用进程的启动过程</h2><p>程序的启动是从进程启动开始的，换句话说只有程序进程启动后，程序才会加载和执行，在AMS启动程序时首先会判断当前进程是否启动，对未启动的进程会发送请求，Zygote在收到请求后创建新的进程；</p>
<h3 id="Zygote监听客户端请求"><a href="#Zygote监听客户端请求" class="headerlink" title="Zygote监听客户端请求"></a>Zygote监听客户端请求</h3><p>由Zygote(一)—Android系统的启动过程知道，系统的启动会执行到ZygoteInit.main()方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String argv[])</span> &#123;</span><br><span class="line">   <span class="type">ZygoteServer</span> <span class="variable">zygoteServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZygoteServer</span>();<span class="comment">//1</span></span><br><span class="line">   zygoteServer.registerServerSocketFromEnv(socketName);</span><br><span class="line">   caller = zygoteServer.runSelectLoop(abiList); <span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main中创建并注册了服务端的Socket，然后执行runSelectLoop（）循环等待AMS的请求创建进程，前一篇文章中跳过了这个部分，本片文章来分析下系统如何实现Socket通信的</p>
<ul>
<li>registerServerSocketFromEnv（）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">registerServerSocketFromEnv</span><span class="params">(String socketName)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mServerSocket == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> fileDesc;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">fullSocketName</span> <span class="operator">=</span> ANDROID_SOCKET_PREFIX + socketName;<span class="comment">//1</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">env</span> <span class="operator">=</span> System.getenv(fullSocketName);<span class="comment">//2</span></span><br><span class="line">                fileDesc = Integer.parseInt(env);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">FileDescriptor</span> <span class="variable">fd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileDescriptor</span>();<span class="comment">//3</span></span><br><span class="line">                fd.setInt$(fileDesc);</span><br><span class="line">                mServerSocket = <span class="keyword">new</span> <span class="title class_">LocalServerSocket</span>(fd);<span class="comment">//4</span></span><br><span class="line">                mCloseSocketFd = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在registerServerSocketFromEnv中（）出入的参数为进程名称，由上一篇文章知道传入的为ztgote，然后使用ANDROID_SOCKET_PREFIX拼接Socket名称，最终的名称为ANDROID_SOCKET_zygote，然后将fullSocketName转换为环境变量的值，注释3处创建文件描述符，然后根据文件描述符fd创建LocalServerSocket对象；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LocalServerSocket</span><span class="params">(FileDescriptor fd)</span> <span class="keyword">throws</span> IOException</span><br><span class="line">    &#123;</span><br><span class="line">        impl = <span class="keyword">new</span> <span class="title class_">LocalSocketImpl</span>(fd);</span><br><span class="line">        impl.listen(LISTEN_BACKLOG);</span><br><span class="line">        localAddress = impl.getSockAddress();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>LocalService使用select监听文件描述符，当文件描述符上出现新内容时会自动触发中断，然后中断处理函数中再次读取文件描述福符上的数据，从而获取信息；</p>
<ul>
<li>zygoteServer.runSelectLoop（）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">    Runnable <span class="title function_">runSelectLoop</span><span class="params">(String abiList)</span> &#123;</span><br><span class="line">        ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;FileDescriptor&gt;();</span><br><span class="line">        ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ZygoteConnection&gt;();</span><br><span class="line"><span class="number">177</span>        fds.add(mServerSocket.getFileDescriptor());<span class="comment">//1</span></span><br><span class="line"><span class="number">178</span>        peers.add(<span class="literal">null</span>);</span><br><span class="line"><span class="number">179</span></span><br><span class="line"><span class="number">180</span>        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">//2</span></span><br><span class="line"><span class="number">181</span>            StructPollfd[] pollFds = <span class="keyword">new</span> <span class="title class_">StructPollfd</span>[fds.size()];</span><br><span class="line"><span class="number">182</span>            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line"><span class="number">183</span>                pollFds[i] = <span class="keyword">new</span> <span class="title class_">StructPollfd</span>();</span><br><span class="line"><span class="number">184</span>                pollFds[i].fd = fds.get(i);</span><br><span class="line"><span class="number">185</span>                pollFds[i].events = (<span class="type">short</span>) POLLIN;</span><br><span class="line"><span class="number">186</span>            &#125;</span><br><span class="line"><span class="number">187</span>            <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">188</span>                Os.poll(pollFds, -<span class="number">1</span>);</span><br><span class="line"><span class="number">189</span>            &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line"><span class="number">190</span>                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;poll failed&quot;</span>, ex);</span><br><span class="line"><span class="number">191</span>            &#125;</span><br><span class="line"><span class="number">192</span>            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="number">193</span>                <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">194</span>                    <span class="keyword">continue</span>;</span><br><span class="line"><span class="number">195</span>                &#125;</span><br><span class="line"><span class="number">197</span>                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; <span class="comment">// 3</span></span><br><span class="line"><span class="number">198</span>                    <span class="type">ZygoteConnection</span> <span class="variable">newPeer</span> <span class="operator">=</span> acceptCommandPeer(abiList);</span><br><span class="line"><span class="number">199</span>                    peers.add(newPeer);</span><br><span class="line"><span class="number">200</span>                    fds.add(newPeer.getFileDesciptor());</span><br><span class="line"><span class="number">201</span>                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">202</span>                    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">203</span>                        <span class="type">ZygoteConnection</span> <span class="variable">connection</span> <span class="operator">=</span> peers.get(i);</span><br><span class="line"><span class="number">204</span>                        <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> connection.processOneCommand(<span class="built_in">this</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="number">205</span></span><br><span class="line"><span class="number">206</span>                        <span class="keyword">if</span> (mIsForkChild) &#123;</span><br><span class="line"><span class="number">213</span>                            <span class="keyword">return</span> command;</span><br><span class="line"><span class="number">214</span>                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">223</span>                            <span class="keyword">if</span> (connection.isClosedByPeer()) &#123;</span><br><span class="line"><span class="number">224</span>                                connection.closeSocket();</span><br><span class="line"><span class="number">225</span>                                peers.remove(i);</span><br><span class="line"><span class="number">226</span>                                fds.remove(i);</span><br><span class="line"><span class="number">227</span>                            &#125;</span><br><span class="line"><span class="number">228</span>                        &#125;</span><br><span class="line"><span class="number">229</span>                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="number">230</span>                        <span class="keyword">if</span> (!mIsForkChild) &#123;</span><br><span class="line"><span class="number">241</span>                            <span class="type">ZygoteConnection</span> <span class="variable">conn</span> <span class="operator">=</span> peers.remove(i);</span><br><span class="line"><span class="number">242</span>                            conn.closeSocket();</span><br><span class="line"><span class="number">244</span>                            fds.remove(i);</span><br><span class="line"><span class="number">245</span>                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">250</span>                            <span class="keyword">throw</span> e;</span><br><span class="line"><span class="number">251</span>                        &#125;</span><br><span class="line"><span class="number">252</span>                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="number">256</span>                        mIsForkChild = <span class="literal">false</span>;</span><br><span class="line"><span class="number">257</span>                    &#125;</span><br><span class="line"><span class="number">258</span>                &#125;</span><br><span class="line"><span class="number">259</span>            &#125;</span><br><span class="line"><span class="number">260</span>        &#125;</span><br><span class="line"><span class="number">261</span>    &#125;</span><br></pre></td></tr></table></figure>

<p>在runSelectLoop方法中，首先获取注册Socket的文件描述符fd，并将其保存在fds集合中，然后开启循环监听AMS的请求，在注释3处判断i &#x3D;&#x3D;0，若i&#x3D;0表示Socket没有可用的链接需要重连，否则表示接收到AMS的请求信号，调用connection.processOneCommand(this)创建新的进程，创建完成后清除对应的peers集合和fds集合；</p>
<h3 id="AMS发送创建进程请求"><a href="#AMS发送创建进程请求" class="headerlink" title="AMS发送创建进程请求"></a>AMS发送创建进程请求</h3><p>AMS会检查目标程序进程，如果进程未启动则调用startProcessLocked（）方法启动进程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="variable">uid</span> <span class="operator">=</span> app.uid; <span class="comment">//1</span></span><br><span class="line">   ......</span><br><span class="line"><span class="keyword">if</span> (ArrayUtils.isEmpty(permGids)) &#123; <span class="comment">//2</span></span><br><span class="line">           gids = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            gids = <span class="keyword">new</span> <span class="title class_">int</span>[permGids.length + <span class="number">3</span>];</span><br><span class="line">            System.arraycopy(permGids, <span class="number">0</span>, gids, <span class="number">3</span>, permGids.length);</span><br><span class="line">        &#125;</span><br><span class="line">          gids[<span class="number">0</span>] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));</span><br><span class="line">          gids[<span class="number">1</span>] = UserHandle.getCacheAppGid(UserHandle.getAppId(uid));</span><br><span class="line">          gids[<span class="number">2</span>] = UserHandle.getUserGid(UserHandle.getUserId(uid));</span><br><span class="line">.....</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">entryPoint</span> <span class="operator">=</span> <span class="string">&quot;android.app.ActivityThread&quot;</span>; <span class="comment">//3</span></span><br><span class="line"><span class="keyword">return</span> startProcessLocked(hostingType, hostingNameStr, entryPoint, app, uid, gids,runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith,startTime); <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<p>startProcessLocked执行一下逻辑：</p>
<ol>
<li>获取当前程序的uid</li>
<li>对用户组gids创建并赋值</li>
<li>entryPoint赋值为ActivityThread的路径，ActivityThread就是进程启动时要初始化的类</li>
<li>调用startProcessLocked（）启动进程</li>
</ol>
<p>在startProcessLocked（）中又调用startProcess()，startProcess（）中调用Process.start()方法，start中调用ZygoteProcess.startViaZygote()启动进程，</p>
<ul>
<li>ZygoteProcess.startViaZygote()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Process.ProcessStartResult <span class="title function_">startViaZygote</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span><br><span class="line"><span class="params">   ......String[] extraArgs)</span><span class="keyword">throws</span> ZygoteStartFailedEx &#123;</span><br><span class="line">   ArrayList&lt;String&gt; argsForZygote = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">   argsForZygote.add(<span class="string">&quot;--runtime-args&quot;</span>);</span><br><span class="line">   argsForZygote.add(<span class="string">&quot;--setuid=&quot;</span> + uid);</span><br><span class="line">   argsForZygote.add(<span class="string">&quot;--setgid=&quot;</span> + gid);</span><br><span class="line">   argsForZygote.add(<span class="string">&quot;--runtime-flags=&quot;</span> + runtimeFlags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span>(mLock) &#123;</span><br><span class="line"><span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在startViaZygote中首先创建ArrayList集合，然后添加创建进程的启动参数，最后调用zygoteSendArgsAndGetResult（）执行启动进程，在zygoteSendArgsAndGetResult的第一个参数中首先调用了openZygoteSocketIfNeeded（）方法，它的作用其实就是连接Zygote 中服务端的Socket</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ZygoteState <span class="title function_">openZygoteSocketIfNeeded</span><span class="params">(String abi)</span> <span class="keyword">throws</span> ZygoteStartFailedEx &#123;</span><br><span class="line">        <span class="keyword">if</span> (primaryZygoteState == <span class="literal">null</span> || primaryZygoteState.isClosed()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                primaryZygoteState = ZygoteState.connect(mSocket); <span class="comment">//1</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ZygoteStartFailedEx</span>(<span class="string">&quot;Error connecting to primary zygote&quot;</span>, ioe);</span><br><span class="line">            &#125;</span><br><span class="line">            maybeSetApiBlacklistExemptions(primaryZygoteState, <span class="literal">false</span>);</span><br><span class="line">           maybeSetHiddenApiAccessLogSampleRate(primaryZygoteState);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (primaryZygoteState.matches(abi)) &#123; <span class="comment">//2</span></span><br><span class="line">            <span class="keyword">return</span> primaryZygoteState;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (secondaryZygoteState == <span class="literal">null</span> || secondaryZygoteState.isClosed()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                secondaryZygoteState = ZygoteState.connect(mSecondarySocket);<span class="comment">//3</span></span><br><span class="line">            &#125; </span><br><span class="line">           maybeSetApiBlacklistExemptions(secondaryZygoteState, <span class="literal">false</span>);</span><br><span class="line">           maybeSetHiddenApiAccessLogSampleRate(secondaryZygoteState);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (secondaryZygoteState.matches(abi)) &#123; <span class="comment">//4</span></span><br><span class="line">            <span class="keyword">return</span> secondaryZygoteState;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在openZygoteSocketIfNeeded（）中ZygoteState.connect（）连接Zygote进程中的Socket，连接成功后返回连接的主模式，用此主模式和传入的abi比较是否匹配，如果匹配则直接返回ZygoteState，否则连接zygote辅模式；</p>
<ul>
<li>zygoteSendArgsAndGetResult（）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Process.ProcessStartResult <span class="title function_">zygoteSendArgsAndGetResult</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="number">281</span>            ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span></span><br><span class="line"><span class="number">282</span>            <span class="keyword">throws</span> ZygoteStartFailedEx &#123;</span><br><span class="line"><span class="number">283</span>        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">286</span>            <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> args.size();</span><br><span class="line"><span class="number">287</span>            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line"><span class="number">288</span>                <span class="keyword">if</span> (args.get(i).indexOf(<span class="string">&#x27;\n&#x27;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">289</span>                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ZygoteStartFailedEx</span>(<span class="string">&quot;embedded newlines not allowed&quot;</span>);</span><br><span class="line"><span class="number">290</span>                &#125;</span><br><span class="line"><span class="number">291</span>            &#125;</span><br><span class="line"><span class="number">303</span>            <span class="keyword">final</span> <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> zygoteState.writer;</span><br><span class="line"><span class="number">304</span>            <span class="keyword">final</span> <span class="type">DataInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> zygoteState.inputStream;</span><br><span class="line"><span class="number">306</span>            writer.write(Integer.toString(args.size()));</span><br><span class="line"><span class="number">307</span>            writer.newLine();</span><br><span class="line"><span class="number">309</span>            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line"><span class="number">310</span>                <span class="type">String</span> <span class="variable">arg</span> <span class="operator">=</span> args.get(i);</span><br><span class="line"><span class="number">311</span>                writer.write(arg);</span><br><span class="line"><span class="number">312</span>                writer.newLine();</span><br><span class="line"><span class="number">313</span>            &#125;</span><br><span class="line"><span class="number">315</span>            writer.flush();</span><br><span class="line"><span class="number">323</span>            result.pid = inputStream.readInt();</span><br><span class="line"><span class="number">324</span>            result.usingWrapper = inputStream.readBoolean();</span><br><span class="line"><span class="number">326</span>            <span class="keyword">if</span> (result.pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">327</span>                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ZygoteStartFailedEx</span>(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line"><span class="number">328</span>            &#125;</span><br><span class="line"><span class="number">329</span>            <span class="keyword">return</span> result;</span><br><span class="line"><span class="number">330</span>        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="number">331</span>            zygoteState.close();</span><br><span class="line"><span class="number">332</span>            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ZygoteStartFailedEx</span>(ex);</span><br><span class="line"><span class="number">333</span>        &#125;</span><br><span class="line"><span class="number">334</span>    &#125;</span><br></pre></td></tr></table></figure>

<p>在zygoteSendArgsAndGetResult中获取连接Socket返回的ZygoteState，利用ZygoteState内部的BufferedWriter将请求参数写入Zygote进程中；</p>
<h3 id="Zygote接收信息并创建进程"><a href="#Zygote接收信息并创建进程" class="headerlink" title="Zygote接收信息并创建进程"></a>Zygote接收信息并创建进程</h3><p>由第一部分知道，在AMS发送请求后zygote进程会接收请求，并调用ZygoteConnection.processOneCommand()方法处理请求，在ZygoteInit.main（）方法中有以下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Runnable caller;</span><br><span class="line">caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line"><span class="keyword">if</span> (caller != <span class="literal">null</span>) &#123;</span><br><span class="line">    caller.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在runSelectLoop（）中接收到AMS请求信息后，然后执行处理并返回Runnable对象并执行run（）方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> Runnable <span class="title function_">processOneCommand</span><span class="params">(ZygoteServer zygoteServer)</span> &#123;</span><br><span class="line">  String args[];</span><br><span class="line">  <span class="type">Arguments</span> <span class="variable">parsedArgs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       FileDescriptor[] descriptors;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           args = readArgumentList(); <span class="comment">//1</span></span><br><span class="line">           descriptors = mSocket.getAncillaryFileDescriptors();</span><br><span class="line">       &#125; </span><br><span class="line">        parsedArgs = <span class="keyword">new</span> <span class="title class_">Arguments</span>(args); <span class="comment">//2</span></span><br><span class="line"> pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,parsedArgs.runtimeFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.startChildZygote,parsedArgs.instructionSet, parsedArgs.appDataDir);</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">               zygoteServer.setForkChild();</span><br><span class="line">               zygoteServer.closeServerSocket();</span><br><span class="line">               IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">               serverPipeFd = <span class="literal">null</span>;</span><br><span class="line">               <span class="keyword">return</span> handleChildProc(parsedArgs, descriptors, childPipeFd,</span><br><span class="line">                       parsedArgs.startChildZygote); <span class="comment">//3</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">               childPipeFd = <span class="literal">null</span>;</span><br><span class="line">               handleParentProc(pid, descriptors, serverPipeFd);</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在processOneCommand（）中首先调用readArgumentList读取参数数组，然后将数组封装在Arguments对象中，调用Zygote.forkAndSpecialize（）方法fork子进程，子进程创建成功后调用handleChildProc（）初始化进程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">handleChildProc</span><span class="params">(Arguments parsedArgs, FileDescriptor[] descriptors,FileDescriptor pipeFd, <span class="type">boolean</span> isZygote)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.niceName != <span class="literal">null</span>) &#123;</span><br><span class="line">            Process.setArgV0(parsedArgs.niceName);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isZygote) &#123;</span><br><span class="line">                <span class="keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs,<span class="literal">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ZygoteInit.childZygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">                        parsedArgs.remainingArgs, <span class="literal">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在handleChildProc调用ZygoteInit.zygoteInit（），关于ZygoteInit.zygoteInit（）方法的内容参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/Alexwll/article/details/100133524">Android进阶知识树——Android系统的启动过程</a>，其最终会使用反射调用ActivityThread.main（）方法，程序进入进程初始化，关于ActivityThread中的操作这里不做分析，相信Android开发者应该了解；</p>
<h3 id="启动Binder线程池"><a href="#启动Binder线程池" class="headerlink" title="启动Binder线程池"></a>启动Binder线程池</h3><p>本篇文章和上一篇<a target="_blank" rel="noopener" href="https://blog.csdn.net/Alexwll/article/details/100133524">Android进阶知识树——Android系统的启动过程</a>中都提到Binder线程池的创建，但都没有详细介绍，这里补充一下，程序在启动进程后会调用ZygoteInit.zygoteInit()方法，zygoteInit中调用本地方法nativeZygoteInit（），在ZygoteInit中声明了nativeZygoteInit方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable <span class="title function_">zygoteInit</span><span class="params">(<span class="type">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span> &#123;</span><br><span class="line">       RuntimeInit.commonInit();</span><br><span class="line">       ZygoteInit.nativeZygoteInit();<span class="comment">//</span></span><br><span class="line">       <span class="keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeZygoteInit</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>很明显nativeZygoteInit（）是JNI方法（关于JNI见另一篇文章<a target="_blank" rel="noopener" href="https://blog.csdn.net/Alexwll/article/details/99703403">Android进阶知识树——JNI和So库开发</a>），他在AndroidRuntime中完成方法动态注册，nativeZygoteInit中对应c文件中com_android_internal_os_ZygoteInit_nativeZygoteInit（）方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_com_android_internal_os_ZygoteInit_nativeZygoteInit</span><span class="params">(JNIEnv* env)</span></span><br><span class="line">&#123;</span><br><span class="line">    const JNINativeMethod methods[] = &#123;</span><br><span class="line">        &#123; <span class="string">&quot;nativeZygoteInit&quot;</span>, <span class="string">&quot;()V&quot;</span>,</span><br><span class="line">            (<span class="keyword">void</span>*) com_android_internal_os_ZygoteInit_nativeZygoteInit &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> jniRegisterNativeMethods(env, <span class="string">&quot;com/android/internal/os/ZygoteInit&quot;</span>,</span><br><span class="line">        methods, NELEM(methods));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">com_android_internal_os_ZygoteInit_nativeZygoteInit</span><span class="params">(JNIEnv* env, jobject clazz)</span></span><br><span class="line">&#123;</span><br><span class="line">    gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在com_android_internal_os_ZygoteInit_nativeZygoteInit（）方法中调用gCurRuntime.onZygoteInit（），这里的gCurRuntime是AppRuntime对象，它继承AndroidRuntime，在AndroidRuntime的构造函数中被初始化，AppRuntime类在app_main中实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AppRuntime</span> : <span class="keyword">public</span> AndroidRuntime</span><br><span class="line">&#123;</span><br><span class="line">virtual <span class="keyword">void</span> <span class="title function_">onZygoteInit</span><span class="params">()</span>    &#123;</span><br><span class="line">       sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">        proc-&gt;startThreadPool();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在onZygoteInit（）中调用ProcessState类的startThreadPool（），startThreadPool（）中调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ProcessState::spawnPooledThread(bool isMain)&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThreadPoolStarted) &#123;</span><br><span class="line">        <span class="type">String8</span> <span class="variable">name</span> <span class="operator">=</span> makeBinderThreadName();</span><br><span class="line">        sp&lt;Thread&gt; t = <span class="keyword">new</span> <span class="title class_">PoolThread</span>(isMain);</span><br><span class="line">        t-&gt;run(name.string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在spawnPooledThread（）中使用makeBinderThreadName（）生成线程名称，然后创建PoolThread线程并执行线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PoolThread</span> : <span class="keyword">public</span> Thread&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    virtual bool <span class="title function_">threadLoop</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        IPCThreadState::self()-&gt;joinThreadPool(mIsMain); </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    const bool mIsMain;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>PoolThread继承Thread类，启动PoolThread对象就创建了一个新的线程，在PoolThread的threadLoop（）方法中调用IPCThreadState的joinThreadPool（）方法将创建的线程加入Binder线程吃中，那么新创建的应用进程就支持Binder进程通行了；</p>
<p>总结一下整个进程启动的过程：</p>
<ol>
<li>AMS判断当前进程是否启动，对未启动的进程发送请求</li>
<li>首先根据程序的pid设置并赋值用户组gids</li>
<li>将entryPoint赋值为ActivityThread的路径，然后开始执行进程启动</li>
<li>在与zygote交互中，首先根据设置的abi连接zygote进程中的socket，并判断是匹配主模式还是辅模式，连接成功后返回zygoteState对象</li>
<li>使用zygoteState将请求参数写入zygote的Socket中，zygote进程中读取请求的信息保存在数组中</li>
<li>使用参数数组创建Argument对象，并fork出程序进程，从而启动程序进程</li>
<li>进程启动后调用ZygotezInit.zygoteInit（）方法，内部初始化Binder线程池实现进程通信，然后反射获取ActivityThread.main（）方法，完成新进程的初始化</li>
</ol>
<h1 id="AMS"><a href="#AMS" class="headerlink" title="AMS"></a>AMS</h1><h2 id="AMS源码分析-一-Activity生命周期管理"><a href="#AMS源码分析-一-Activity生命周期管理" class="headerlink" title="AMS源码分析(一)Activity生命周期管理"></a>AMS源码分析(一)Activity生命周期管理</h2><p>AMS(ActivityManagerService)是Activity管理的核心组件，提供了Activity的启动、生命周期管理、栈管理等功能，熟悉AMS会对我们认识Activity的工作原理有很大的帮助。当前比较成熟的插件化技术，也是通过对Activity启动流程中的重要组件（如Instrumentation或主线程Handler等）进行Hook完成的，掌握AMS对我们学习插件化技术也有很大的帮助</p>
<p>AMS中内容很多，对它的分析也不可能面面俱到，我期望从Activity的启动、Activity消息回传（onActivityResult）、Activity栈管理、AMS与WMS和PMS的协同工作方面入手，希望本系列文章完成后可以对AMS有一个更新的认识</p>
<h3 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h3><h4 id="一个Activity从启动到销毁所经历的周期"><a href="#一个Activity从启动到销毁所经历的周期" class="headerlink" title="一个Activity从启动到销毁所经历的周期"></a>一个Activity从启动到销毁所经历的周期</h4><p>onCreate -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestory</p>
<p>这属于Android最基础的知识，就不再赘述了</p>
<h4 id="从一个Activity启动另一个Activity的生命周期"><a href="#从一个Activity启动另一个Activity的生命周期" class="headerlink" title="从一个Activity启动另一个Activity的生命周期"></a>从一个Activity启动另一个Activity的生命周期</h4><p>现在有两个Activity,分别是AActivity和BActivity,如果从AActivity跳转到BActivity,那么它们的生命周期会是下面这个样子：</p>
<p>AActivity#onPause -&gt; BActivity#onCreate -&gt; BActivity#onStart -&gt; BActivity#onResume -&gt; AActivity#onStop</p>
<p>如下图:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3112838-c98340b7602caebe.image?imageMogr2/auto-orient/strip%7CimageView2/2/w/248/format/webp" alt="img"></p>
<p>而从BActivity返回时，它们的生命周期是这样的：</p>
<p>BActivity#onPause -&gt; AActivity#onStart -&gt; AActivity#onResume -&gt; BActivity#onStop -&gt; BActivity#onDestroy</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3112838-e0000f3c12fd415e.image?imageMogr2/auto-orient/strip%7CimageView2/2/w/317/format/webp" alt="img"></p>
<p>为什么是这样呢？下面我们从源码的角度去分析一下</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>在做源码分析之前，我们要先理解两个概念</p>
<ul>
<li>Android Binder IPC机制</li>
<li>Hander idleHandler机制</li>
</ul>
<h4 id="Binder-1"><a href="#Binder-1" class="headerlink" title="Binder"></a>Binder</h4><p>Binder是Android跨进程通信的核心，但不是本文的重点，这里不多做讲解，感兴趣的朋友可以看一下我之前写过的Binder系列文章：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/275bc9a53342">Binder系列</a></p>
<p>在本篇文章中，我们只需要知道每当看到类似<code>mRemote.transact</code><br> 这种调用时，既是跨进程通信的开始</p>
<h4 id="IdleHandler"><a href="#IdleHandler" class="headerlink" title="IdleHandler"></a>IdleHandler</h4><p>当消息队列空闲时会执行IdelHandler的queueIdle()方法，该方法返回一个boolean值，<br> 如果为false则执行完毕之后移除这条消息，<br> 如果为true则保留，等到下次空闲时会再次执行</p>
<p>也就是说，IdleHandler是Handler机制中MessageQueue空闲时才会执行的一种特殊Handler</p>
<h4 id="Activity在AMS中的标识"><a href="#Activity在AMS中的标识" class="headerlink" title="Activity在AMS中的标识"></a>Activity在AMS中的标识</h4><p>每一个Activity实例在AMS中都会对应一个ActivityRecord,ActivityRecord对象是在Activity启动过程中创建的，每个ActivityRecord中又会有一个ProcessRecord标记Activity所在的进程</p>
<p>而在APP进程中，在Activity启动时，也会创建一个ActivityClientRecord,与AMS中的ActivityRecord遥相呼应。</p>
<p>Activity、ActivityClientRecord、ActivityRecord互相联系的纽带是一个<code>token</code>对象，它继承于<code>IApplicationToken.Stub</code>,这是一个Binder对象，在Activity、ActivityClientRecord、ActivityRecord中均有一份。</p>
<p>Activity、ActivityClientRecord、ActivityRecord之间的关系图大致如下—注意区分所在进程：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3112838-0ff114d27e1a8d37.image?imageMogr2/auto-orient/strip%7CimageView2/2/w/623/format/webp" alt="img"></p>
<h4 id="启动过程时序图"><a href="#启动过程时序图" class="headerlink" title="启动过程时序图"></a>启动过程时序图</h4><p>黄色为APP进程，蓝色为AMS进程</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3112838-f98e18517de9cb28.image?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="从AActivity跳转BActivity的生命周期分析"><a href="#从AActivity跳转BActivity的生命周期分析" class="headerlink" title="从AActivity跳转BActivity的生命周期分析"></a>从AActivity跳转BActivity的生命周期分析</h4><p>AMS的逻辑太多，本文只针对Activity声明周期相关的代码，其他相关逻辑后面几篇文章继续分析</p>
<p>从Activity开始</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void startActivityForResult(<span class="meta">@RequiresPermission</span> Intent intent, int requestCode,</span><br><span class="line">                                   <span class="meta">@Nullable</span> Bundle options) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mParent == <span class="literal">null</span>) &#123;</span><br><span class="line">        options = transferSpringboardActivityOptions(options);</span><br><span class="line">        Instrumentation.ActivityResult ar =</span><br><span class="line">                mInstrumentation.execStartActivity(</span><br><span class="line">                        <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">                        intent, requestCode, options);</span><br><span class="line">       </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Instrumentation#execStartActivity方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="params"><span class="function">        Intent intent, <span class="built_in">int</span> requestCode, Bundle options</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData();</span><br><span class="line">        intent.prepareToLeaveProcess(who);</span><br><span class="line">        <span class="built_in">int</span> result = ActivityManager.getService()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != <span class="literal">null</span> ? target.mEmbeddedID : <span class="literal">null</span>,</span><br><span class="line">                    requestCode, <span class="number">0</span>, <span class="literal">null</span>, options);</span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Failure from system&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要入参及含义：</p>
<ul>
<li>who: 启动源Activity</li>
<li>contextThread ： 宿主Activity的ApplicationThread</li>
<li>token：Activity的身份标识 -&gt; Activity#mToken -&gt; ActivityClientRecord#token -&gt; ActivityRecord#appToken -&gt; IApplicationToken.Stub</li>
<li>target: 哪个activity调用的start方法，因此这个Activity会接收任何的返回结果，如果start调用不是从Activity中发起的则有可能为null</li>
<li>intent: 启动Activity时的intent</li>
<li>requestCoode: 启动Activity时的requestCode</li>
<li>options: 启动Activity的选项</li>
</ul>
<p>注意token参数，本文将重点追踪它的变化，这个参数非常重要，后面会有很多地方用到</p>
<p>继续走逻辑,在这里进行了IPC调用，从APP进程转入AMS进程执行，<code>ActivityManager.getService() .startActivity</code>调用在AMS进程对应的是<code>ActivityManagerService#startActivity</code>，我们看一下</p>
<p>ActivityManagerService#startActivity 经过一系列的调用后，会走到 ActivityStarter#startActivityMayWait</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">int</span> startActivityMayWait(IApplicationThread caller, <span class="built_in">int</span> callingUid,</span><br><span class="line">        <span class="built_in">int</span> requestRealCallingPid, <span class="built_in">int</span> requestRealCallingUid,</span><br><span class="line">        <span class="built_in">String</span> callingPackage, Intent intent, <span class="built_in">String</span> resolvedType,</span><br><span class="line">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">        IBinder resultTo, <span class="built_in">String</span> resultWho, <span class="built_in">int</span> requestCode, <span class="built_in">int</span> startFlags,</span><br><span class="line">        ProfilerInfo profilerInfo, WaitResult outResult,</span><br><span class="line">        Configuration globalConfig, Bundle bOptions, boolean ignoreTargetSecurity, <span class="built_in">int</span> userId,</span><br><span class="line">        TaskRecord inTask, <span class="built_in">String</span> reason) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Collect information about the target of the Intent.</span></span><br><span class="line">    <span class="comment">// zhangyulong 解析Intent中的Activity信息</span></span><br><span class="line">    ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// zhangyulong 声明一个ActivityRecord数组</span></span><br><span class="line">        <span class="keyword">final</span> ActivityRecord[] outRecord = <span class="keyword">new</span> ActivityRecord[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">int</span> res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">                aInfo, rInfo, voiceSession, voiceInteractor,</span><br><span class="line">                resultTo, resultWho, requestCode, callingPid,</span><br><span class="line">                callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">                options, ignoreTargetSecurity, componentSpecified, outRecord, inTask,</span><br><span class="line">                reason);</span><br><span class="line"></span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里进行的工作是解析Intent信息，并继续调用<code>startActivityLocked</code>，注意入参中的<code>resultTo</code>就是从App进程传入的token，依旧是透传给<code>startActivityLocked</code></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span><br><span class="line">        <span class="built_in">String</span> resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span><br><span class="line">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">        IBinder resultTo, <span class="built_in">String</span> resultWho, <span class="built_in">int</span> requestCode, <span class="built_in">int</span> callingPid, <span class="built_in">int</span> callingUid,</span><br><span class="line">        <span class="built_in">String</span> callingPackage, <span class="built_in">int</span> realCallingPid, <span class="built_in">int</span> realCallingUid, <span class="built_in">int</span> startFlags,</span><br><span class="line">        ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,</span><br><span class="line">        ActivityRecord[] outActivity, TaskRecord inTask, <span class="built_in">String</span> reason) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(reason)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Need to specify a reason.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mLastStartReason = reason;</span><br><span class="line">    mLastStartActivityTimeMs = System.currentTimeMillis();</span><br><span class="line">    mLastStartActivityRecord[<span class="number">0</span>] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">            aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode,</span><br><span class="line">            callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">            options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord,</span><br><span class="line">            inTask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (outActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// mLastStartActivityRecord[0] is set in the call to startActivity above.</span></span><br><span class="line">        outActivity[<span class="number">0</span>] = mLastStartActivityRecord[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Aborted results are treated as successes externally, but we must track them internally.</span></span><br><span class="line">    <span class="keyword">return</span> mLastStartActivityResult != START_ABORTED ? mLastStartActivityResult : START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法也没做太多事情，将参数透传给<code>startActivity</code>继续执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">startActivity</span><span class="params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span></span><br><span class="line"><span class="params">      String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span></span><br><span class="line"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">        IBinder resultTo, String resultWho, <span class="type">int</span> requestCode, <span class="type">int</span> callingPid, <span class="type">int</span> callingUid,</span></span><br><span class="line"><span class="params">        String callingPackage, <span class="type">int</span> realCallingPid, <span class="type">int</span> realCallingUid, <span class="type">int</span> startFlags,</span></span><br><span class="line"><span class="params">        ActivityOptions options, <span class="type">boolean</span> ignoreTargetSecurity, <span class="type">boolean</span> componentSpecified,</span></span><br><span class="line"><span class="params">        ActivityRecord[] outActivity, TaskRecord inTask)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">err</span> <span class="operator">=</span> ActivityManager.START_SUCCESS;</span><br><span class="line">    <span class="comment">// Pull the optional Ephemeral Installer-only bundle out of the options early.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Bundle</span> <span class="variable">verificationBundle</span></span><br><span class="line">            <span class="operator">=</span> options != <span class="literal">null</span> ? options.popAppVerificationBundle() : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">ProcessRecord</span> <span class="variable">callerApp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="literal">null</span>) &#123;</span><br><span class="line">        callerApp = mService.getRecordForAppLocked(caller);</span><br><span class="line">        <span class="keyword">if</span> (callerApp != <span class="literal">null</span>) &#123;</span><br><span class="line">            callingPid = callerApp.pid;</span><br><span class="line">            callingUid = callerApp.info.uid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Unable to find app for caller &quot;</span> + caller</span><br><span class="line">                    + <span class="string">&quot; (pid=&quot;</span> + callingPid + <span class="string">&quot;) when starting: &quot;</span></span><br><span class="line">                    + intent.toString());</span><br><span class="line">            err = ActivityManager.START_PERMISSION_DENIED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">userId</span> <span class="operator">=</span> aInfo != <span class="literal">null</span> ? UserHandle.getUserId(aInfo.applicationInfo.uid) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;START u&quot;</span> + userId + <span class="string">&quot; &#123;&quot;</span> + intent.toShortString(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line">                + <span class="string">&quot;&#125; from uid &quot;</span> + callingUid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ActivityRecord</span> <span class="variable">sourceRecord</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ActivityRecord</span> <span class="variable">resultRecord</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (resultTo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过resultTo在寻找记录在AMS中记录的ActivityRecord，这个ActivityRecord和启动Activity的源Activity对应</span></span><br><span class="line">        sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_RESULTS) Slog.v(TAG_RESULTS,</span><br><span class="line">                <span class="string">&quot;Will send result to &quot;</span> + resultTo + <span class="string">&quot; &quot;</span> + sourceRecord);</span><br><span class="line">        <span class="keyword">if</span> (sourceRecord != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span> &amp;&amp; !sourceRecord.finishing) &#123;</span><br><span class="line">                resultRecord = sourceRecord;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">launchFlags</span> <span class="operator">=</span> intent.getFlags();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 新建一条目标Activity的ActivityRecord，这条ActivityRecord和即将打开的Activity实例对应</span></span><br><span class="line">    <span class="type">ActivityRecord</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityRecord</span>(mService, callerApp, callingPid, callingUid,</span><br><span class="line">            callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(),</span><br><span class="line">            resultRecord, resultWho, requestCode, componentSpecified, voiceSession != <span class="literal">null</span>,</span><br><span class="line">            mSupervisor, options, sourceRecord);</span><br><span class="line">    <span class="keyword">if</span> (outActivity != <span class="literal">null</span>) &#123;</span><br><span class="line">        outActivity[<span class="number">0</span>] = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, <span class="literal">true</span>,</span><br><span class="line">            options, inTask, outActivity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记的我们在分析源码之前所画的ActivityRecord、ActivityClientRecord、Activity之间的关系图么？这里就派上用场了，入参<code>resultTo</code>就是启动Activity时传递的token,那么，在AMS中，必然会有一条ActivityRecord与之对应，通过<code>mSupervisor.isInAnyStackLocked(resultTo)</code>找到与AActivity对应的ActivityRecord。</p>
<p>这个方法还有一个重要的任务就是新建一条ActivityRecord记录，这条记录和即将打开的Activity，即BActivity对应。完成这些工作后，继续执行<code>startActivity</code>。</p>
<p><code>startActivity</code>继续调用了<code>startActivityUnchecked</code>,这个方法最重要的功能是对Acitivity栈和Activity启动模式进行处理，篇幅很长，逻辑复杂，但是不是本篇的重点，所以我们后面的文章再着重分析，现在只关注Activity启动流程相关的部分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span><br><span class="line"><span class="params">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> startFlags, <span class="type">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,</span></span><br><span class="line"><span class="params">            ActivityRecord[] outActivity)</span> &#123;</span><br><span class="line">      </span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">topTaskActivity</span> <span class="operator">=</span></span><br><span class="line">                mStartActivity.getTask().topRunningActivityLocked();</span><br><span class="line">        <span class="keyword">if</span> (!mTargetStack.isFocusable()</span><br><span class="line">                || (topTaskActivity != <span class="literal">null</span> &amp;&amp; topTaskActivity.mTaskOverlay</span><br><span class="line">                &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class="line">            mTargetStack.ensureActivitiesVisibleLocked(<span class="literal">null</span>, <span class="number">0</span>, !PRESERVE_WINDOWS);</span><br><span class="line">            mWindowManager.executeAppTransition();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123;</span><br><span class="line">                mTargetStack.moveToFront(<span class="string">&quot;startActivityUnchecked&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class="line">                    mOptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mTargetStack.addRecentActivityLocked(mStartActivity);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="AActivity-onPause"><a href="#AActivity-onPause" class="headerlink" title="AActivity#onPause"></a>AActivity#onPause</h5><p>注意看<code>mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity, mOptions)</code>，这里，mStartActivity是即将启动的ActivityRecord，mTargetStack是在本方法中计算得到的它所在的ActivityStack，继续看<code>resumeFocusedStackTopActivityLocked</code></p>
<p>还记得在开篇时讲到的从AActivity跳转到BActivity的生命周期过程么？不记得没关系，复习一下先：<br> AActivity#onPause -&gt; BActivity#onCreate -&gt; BActivity#onStart -&gt; BActivity#onResume -&gt; AActivity#onStop,<br> 在<code>resumeFocusedStackTopActivityLocked</code>这个方法我们将接触到这个过程中的第一个声明周期方法，即<code>AActivity#onPause</code>,而且本身这个方法的调用过程也特别复杂，需要重点解析一下，先看一下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mService.mBooting &amp;&amp; !mService.mBooted) &#123;</span><br><span class="line">        <span class="comment">// Not ready yet!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the next top-most activity to resume in this stack that is not finishing and is</span></span><br><span class="line">    <span class="comment">// focusable. If it is not focusable, we will fall into the case below to resume the</span></span><br><span class="line">    <span class="comment">// top activity in the next focusable task.</span></span><br><span class="line">    <span class="comment">// 获取栈顶正在聚焦的Activity</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">next</span> <span class="operator">=</span> topRunningActivityLocked(<span class="literal">true</span> <span class="comment">/* focusableOnly */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">hasRunningActivity</span> <span class="operator">=</span> next != <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Maybe this entire condition can get removed?</span></span><br><span class="line">    <span class="keyword">if</span> (hasRunningActivity &amp;&amp; getDisplay() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// zhangyulong 异常情况，有正在运行的activity但getDisplay为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mStackSupervisor.cancelInitializingActivities();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remember how we&#x27;ll process this pause/resume situation, and ensure</span></span><br><span class="line">    <span class="comment">// that the state is reset however we wind up proceeding.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">userLeaving</span> <span class="operator">=</span> mStackSupervisor.mUserLeaving;</span><br><span class="line">    mStackSupervisor.mUserLeaving = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hasRunningActivity) &#123;</span><br><span class="line">        <span class="comment">// There are no activities left in the stack, let&#x27;s look somewhere else.</span></span><br><span class="line">        <span class="comment">// zhangyulong  task 退干净了，恢复其他的task</span></span><br><span class="line">        <span class="keyword">return</span> resumeTopActivityInNextFocusableStack(prev, options, <span class="string">&quot;noMoreActivities&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next.delayedResume = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Activity栈中有需要Pause操作的Activity</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pausing</span> <span class="operator">=</span> mStackSupervisor.pauseBackStacks(userLeaving, next, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (mResumedActivity != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 暂停当前正在显示的Activity</span></span><br><span class="line">        pausing |= startPausingLocked(userLeaving, <span class="literal">false</span>, next, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pausing &amp;&amp; !resumeWhilePausing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (next.app != <span class="literal">null</span> &amp;&amp; next.app.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">            mService.updateLruProcessLocked(next.app, <span class="literal">true</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="type">ActivityStack</span> <span class="variable">lastStack</span> <span class="operator">=</span> mStackSupervisor.getLastStack();</span><br><span class="line">    <span class="keyword">if</span> (next.app != <span class="literal">null</span> &amp;&amp; next.app.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Whoops, need to restart this activity!</span></span><br><span class="line">        <span class="keyword">if</span> (!next.hasBeenLaunched) &#123;</span><br><span class="line">            next.hasBeenLaunched = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (SHOW_APP_STARTING_PREVIEW) &#123;</span><br><span class="line">                next.showStartingWindow(<span class="literal">null</span> <span class="comment">/* prev */</span>, <span class="literal">false</span> <span class="comment">/* newTask */</span>,</span><br><span class="line">                        <span class="literal">false</span> <span class="comment">/* taskSwich */</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG_SWITCH, <span class="string">&quot;Restarting: &quot;</span> + next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES, <span class="string">&quot;resumeTopActivityLocked: Restarting &quot;</span> + next);</span><br><span class="line">        mStackSupervisor.startSpecificActivityLocked(next, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法会执行两次，第一次进入时，<code>final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */);</code>获取到的是栈顶焦点Activity,在执行该方法之前，我们已经将目标ActivityRecord入栈，因此，这里获取的是要打开的目标ActivityRecord，<code>mStackSupervisor.pauseBackStacks(userLeaving, next, false);</code>是判断ActivityStack中是否有需要pause的Activity,如果有，说明还有活动的Activity没有Pause,我们要先执行Pause操作，通过执行<code>startPausingLocked(userLeaving, false, next, false);</code>将当前未Pause的Activity进行Pause,在执行完毕后方法直接return了。先进去看一下<code>startPausingLocked</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">startPausingLocked</span><span class="params">(<span class="type">boolean</span> userLeaving, <span class="type">boolean</span> uiSleeping,</span></span><br><span class="line"><span class="params">        ActivityRecord resuming, <span class="type">boolean</span> pauseImmediately)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将mResumedActivity赋值prev,并将mResumedActivity置空</span></span><br><span class="line">    <span class="type">ActivityRecord</span> <span class="variable">prev</span> <span class="operator">=</span> mResumedActivity;</span><br><span class="line">    mResumedActivity = <span class="literal">null</span>;</span><br><span class="line">    mPausingActivity = prev;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev.app != <span class="literal">null</span> &amp;&amp; prev.app.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG_PAUSE, <span class="string">&quot;Enqueueing pending pause: &quot;</span> + prev);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY,</span><br><span class="line">                    prev.userId, System.identityHashCode(prev),</span><br><span class="line">                    prev.shortComponentName);</span><br><span class="line">            mService.updateUsageStats(prev, <span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// 开始进行Pause操作</span></span><br><span class="line">            prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing,</span><br><span class="line">                    userLeaving, prev.configChangeFlags, pauseImmediately);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// Ignore exception, if process died other code will cleanup.</span></span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Exception thrown during pause&quot;</span>, e);</span><br><span class="line">            mPausingActivity = <span class="literal">null</span>;</span><br><span class="line">            mLastPausedActivity = <span class="literal">null</span>;</span><br><span class="line">            mLastNoHistoryActivity = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mPausingActivity = <span class="literal">null</span>;</span><br><span class="line">        mLastPausedActivity = <span class="literal">null</span>;</span><br><span class="line">        mLastNoHistoryActivity = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mPausingActivity != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!uiSleeping) &#123;</span><br><span class="line">            prev.pauseKeyDispatchingLocked();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_PAUSE) &#123;</span><br><span class="line">             Slog.v(TAG_PAUSE, <span class="string">&quot;Key dispatch not paused for screen off&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pauseImmediately) &#123;</span><br><span class="line">            completePauseLocked(<span class="literal">false</span>, resuming);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 延时500ms处理pause后续操作</span></span><br><span class="line">            schedulePauseTimeout(prev);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG_PAUSE, <span class="string">&quot;Activity not running, resuming next.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (resuming == <span class="literal">null</span>) &#123;</span><br><span class="line">            mStackSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mResumedActivity</code>就是将被Pause的Activity,通过<code>prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags, pauseImmediately);</code>对其进行Pause,这里实际是一个异步操作，因此，在方法的末端，添加了一个500ms的延时消息防止Pause操作timeout,当然，这个延时消息不一定会执行，如果pause操作在500ms以内完成会将这个消息取消。如果熟悉Activity启动流程的话，我们就会知道<code>schedulePauseActivity</code>最终一定会执行到<code>ApplicationThread#handlePauseActivity</code>,这个ApplicationThread在本文章的场景中是AActivity的ApplicationThread，看下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePauseActivity</span><span class="params">(IBinder token, <span class="type">boolean</span> finished,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> userLeaving, <span class="type">int</span> configChanges, <span class="type">boolean</span> dontReport, <span class="type">int</span> seq)</span> &#123;</span><br><span class="line">    <span class="type">ActivityClientRecord</span> <span class="variable">r</span> <span class="operator">=</span> mActivities.get(token);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_ORDER) Slog.d(TAG, <span class="string">&quot;handlePauseActivity &quot;</span> + r + <span class="string">&quot;, seq: &quot;</span> + seq);</span><br><span class="line">    <span class="keyword">if</span> (!checkAndUpdateLifecycleSeq(seq, r, <span class="string">&quot;pauseActivity&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//Slog.v(TAG, &quot;userLeaving=&quot; + userLeaving + &quot; handling pause of &quot; + r);</span></span><br><span class="line">        <span class="keyword">if</span> (userLeaving) &#123;</span><br><span class="line">            performUserLeavingActivity(r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line">        <span class="comment">// 真正调用Activity#onPause</span></span><br><span class="line">        performPauseActivity(token, finished, r.isPreHoneycomb(), <span class="string">&quot;handlePauseActivity&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure any pending writes are now committed.</span></span><br><span class="line">        <span class="keyword">if</span> (r.isPreHoneycomb()) &#123;</span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tell the activity manager we have paused.</span></span><br><span class="line">        <span class="keyword">if</span> (!dontReport) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通知AMS Activity已完成Pause</span></span><br><span class="line">                ActivityManager.getService().activityPaused(token);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mSomeActivitiesChanged = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>performPauseActivity</code>最终会调用AActivity的onPause,继续向下执行会通过<code>ActivityManager.getService().activityPaused(token)</code>通知AMS进程Activity已完成Pause,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActivityManagerService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">activityPaused</span><span class="params">(IBinder token)</span> &#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="type">long</span> <span class="variable">origId</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">     <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">         <span class="type">ActivityStack</span> <span class="variable">stack</span> <span class="operator">=</span> ActivityRecord.getStackLocked(token);</span><br><span class="line">         <span class="keyword">if</span> (stack != <span class="literal">null</span>) &#123;</span><br><span class="line">             stack.activityPausedLocked(token, <span class="literal">false</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     Binder.restoreCallingIdentity(origId);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>继续看<code>ActivityStack#activityPausedLocked</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">activityPausedLocked</span><span class="params">(IBinder token, <span class="type">boolean</span> timeout)</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">r</span> <span class="operator">=</span> isInStackLocked(token);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 取消Pause的延时等待消息消息</span></span><br><span class="line">        mHandler.removeMessages(PAUSE_TIMEOUT_MSG, r);</span><br><span class="line">        <span class="keyword">if</span> (mPausingActivity == r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG_STATES, <span class="string">&quot;Moving to PAUSED: &quot;</span> + r</span><br><span class="line">                    + (timeout ? <span class="string">&quot; (due to timeout)&quot;</span> : <span class="string">&quot; (pause complete)&quot;</span>));</span><br><span class="line">            mService.mWindowManager.deferSurfaceLayout();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 完成Pause的后续操作</span></span><br><span class="line">                completePauseLocked(<span class="literal">true</span> <span class="comment">/* resumeNext */</span>, <span class="literal">null</span> <span class="comment">/* resumingActivity */</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mService.mWindowManager.continueSurfaceLayout();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较重要的两个操作：</p>
<ul>
<li>取消Pause的延时等待消息消息</li>
<li>完成Pause的后续操作<br>完成Pause后续操作是在<code>ActivityStack#completePauseLocked</code>中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">completePauseLocked</span><span class="params">(<span class="type">boolean</span> resumeNext, ActivityRecord resuming)</span> &#123;</span><br><span class="line">   <span class="type">ActivityRecord</span> <span class="variable">prev</span> <span class="operator">=</span> mPausingActivity;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="comment">// 将已被Pause的Activity加入到mStackSupervisor.mStoppingActivities列表中</span></span><br><span class="line">        addToStopping(prev, <span class="literal">true</span> <span class="comment">/* scheduleIdle */</span>, <span class="literal">false</span> <span class="comment">/* idleDelayed */</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resumeNext) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ActivityStack</span> <span class="variable">topStack</span> <span class="operator">=</span> mStackSupervisor.getFocusedStack();</span><br><span class="line">        <span class="keyword">if</span> (!topStack.shouldSleepOrShutDownActivities()) &#123;</span><br><span class="line">            <span class="comment">// Resume栈顶Activity, prev是当前在pause的</span></span><br><span class="line">            mStackSupervisor.resumeFocusedStackTopActivityLocked(topStack, prev, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            checkReadyForSleep();</span><br><span class="line">            <span class="type">ActivityRecord</span> <span class="variable">top</span> <span class="operator">=</span> topStack.topRunningActivityLocked();</span><br><span class="line">            <span class="keyword">if</span> (top == <span class="literal">null</span> || (prev != <span class="literal">null</span> &amp;&amp; top != prev)) &#123;</span><br><span class="line">                mStackSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点关注<code>mStackSupervisor.resumeFocusedStackTopActivityLocked(topStack, prev, null);</code><br> 兜兜转转，又回到了原点，我们即将第二次调用<code>ActivityStack#resumeTopActivityInnerLocked</code>,这次跟上一次又有所不同，因为已经完成活跃Activity的pause，因此，判断是否需要Pause的分支语句就不会执行，继续向下执行到<code>mStackSupervisor.startSpecificActivityLocked(next, true, true);</code>，这个方法还有一个重要的事情就是将已被Pause的Activity加入到mStackSupervisor.mStoppingActivities的列表中，这是一个ArrayList<ActivityRecord>，至于什么时候用，后面会讲到</p>
<h5 id="BActivity-onCreate"><a href="#BActivity-onCreate" class="headerlink" title="BActivity#onCreate"></a>BActivity#onCreate</h5><p>讲到这里，我们只是刚完成了AActivity的Pause,有些朋友肯定已经着急了，那得分析到啥时候啊，快了快了，后面就很快了，加快进度，接着看<code>ActivityStackSupervisor#startSpecificActivityLocked</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">startSpecificActivityLocked</span><span class="params">(ActivityRecord r,</span></span><br><span class="line"><span class="params">     <span class="type">boolean</span> andResume, <span class="type">boolean</span> checkConfig)</span> &#123;</span><br><span class="line"> <span class="comment">// 获取目标Activity的进程信息</span></span><br><span class="line"> <span class="type">ProcessRecord</span> <span class="variable">app</span> <span class="operator">=</span> mService.getProcessRecordLocked(r.processName,</span><br><span class="line">         r.info.applicationInfo.uid, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"> r.getStack().setLaunchTime(r);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (app != <span class="literal">null</span> &amp;&amp; app.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == <span class="number">0</span></span><br><span class="line">                 || !<span class="string">&quot;android&quot;</span>.equals(r.info.packageName)) &#123;</span><br><span class="line">             app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,</span><br><span class="line">                     mService.mProcessStats);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 启动Activity</span></span><br><span class="line">         realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">         Slog.w(TAG, <span class="string">&quot;Exception when starting activity &quot;</span></span><br><span class="line">                 + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// If a dead object exception was thrown -- fall through to</span></span><br><span class="line">     <span class="comment">// restart the application.</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 如果没有进程信息则启动新的进程</span></span><br><span class="line"> mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="literal">true</span>, <span class="number">0</span>,</span><br><span class="line">         <span class="string">&quot;activity&quot;</span>, r.intent.getComponent(), <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的主要工作是给ActivityRecord分配进程，如果没有进程，则启动新的进程,从AActivity跳BActivity是同一个进程，因此会继续执行<code>realStartActivityLocked(r, app, andResume, checkConfig)</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">realStartActivityLocked</span><span class="params">(ActivityRecord r, ProcessRecord app,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> andResume, <span class="type">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">            app.thread.scheduleLaunchActivity(<span class="keyword">new</span> <span class="title class_">Intent</span>(r.intent), r.appToken,</span><br><span class="line">                    System.identityHashCode(r), r.info,</span><br><span class="line">                   </span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法比较长，掐头去尾只看<code>app.thread.scheduleLaunchActivity</code>,从这里开始进入App进程执行，<code>scheduleLaunchActivity</code>方法在APP进程对应的是<code>ApplicationThread#scheduleLaunchActivity</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">scheduleLaunchActivity</span><span class="params">(Intent intent, IBinder token, <span class="type">int</span> ident,</span></span><br><span class="line"><span class="params">        ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span></span><br><span class="line"><span class="params">        CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> procState, Bundle state, PersistableBundle persistentState,</span></span><br><span class="line"><span class="params">        List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> notResumed, <span class="type">boolean</span> isForward, ProfilerInfo profilerInfo)</span> &#123;</span><br><span class="line"></span><br><span class="line">    updateProcessState(procState, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">ActivityClientRecord</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityClientRecord</span>();</span><br><span class="line"></span><br><span class="line">    r.token = token;</span><br><span class="line">    r.ident = ident;</span><br><span class="line">    r.intent = intent;</span><br><span class="line">    r.referrer = referrer;</span><br><span class="line">    r.voiceInteractor = voiceInteractor;</span><br><span class="line">    r.activityInfo = info;</span><br><span class="line">    r.compatInfo = compatInfo;</span><br><span class="line">    r.state = state;</span><br><span class="line">    r.persistentState = persistentState;</span><br><span class="line"></span><br><span class="line">    r.pendingResults = pendingResults;</span><br><span class="line">    r.pendingIntents = pendingNewIntents;</span><br><span class="line"></span><br><span class="line">    r.startsNotResumed = notResumed;</span><br><span class="line">    r.isForward = isForward;</span><br><span class="line"></span><br><span class="line">    r.profilerInfo = profilerInfo;</span><br><span class="line"></span><br><span class="line">    r.overrideConfig = overrideConfig;</span><br><span class="line">    updatePendingConfiguration(curConfig);</span><br><span class="line"></span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里创建了<code>ActivityClientRecord</code>,因此ActivityClientRecord和AMS中的ActivityRecord就对应起来了。向主线程发送<code>H.LAUNCH_ACTIVITY</code>消息，消息回调后执行handleLaunchActivity:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span>(<span class="params">ActivityClientRecord r, Intent customIntent, String reason</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// If we are getting ready to gc after going to the background, well</span></span><br><span class="line">    <span class="comment">// we are back active so skip it.</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">        ....</span><br><span class="line">        handleResumeActivity(r.token, <span class="literal">false</span>, r.isForward,</span><br><span class="line">                !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用performLaunchActivity:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">    <span class="comment">// 创建Context</span></span><br><span class="line">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过ClassLoader创建Activity实例</span></span><br><span class="line">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">&quot;Unable to instantiate activity &quot;</span> + component</span><br><span class="line">                + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//读取Activity信息</span></span><br><span class="line">            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">            Configuration config = <span class="keyword">new</span> Configuration(mCompatConfiguration);</span><br><span class="line">            <span class="keyword">if</span> (r.overrideConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                config.updateFrom(r.overrideConfig);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG, <span class="string">&quot;Launching activity &quot;</span></span><br><span class="line">                    + r.activityInfo.name + <span class="string">&quot; with config &quot;</span> + config);</span><br><span class="line">            Window <span class="built_in">window</span> = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.mPendingRemoveWindow != <span class="keyword">null</span> &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class="line">                <span class="built_in">window</span> = r.mPendingRemoveWindow;</span><br><span class="line">                r.mPendingRemoveWindow = <span class="keyword">null</span>;</span><br><span class="line">                r.mPendingRemoveWindowManager = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            appContext.setOuterContext(activity);</span><br><span class="line">            <span class="comment">// 执行Actiivity attach方法</span></span><br><span class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, <span class="built_in">window</span>, r.configCallback);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (customIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                activity.mIntent = customIntent;</span><br><span class="line">            &#125;</span><br><span class="line">            r.lastNonConfigurationInstances = <span class="keyword">null</span>;</span><br><span class="line">            checkAndBlockForNetworkAccess();</span><br><span class="line">            activity.mStartedActivity = <span class="keyword">false</span>;</span><br><span class="line">            <span class="built_in">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class="line">            <span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">                activity.setTheme(theme);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// Activity onCreate执行</span></span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                    <span class="string">&quot;Activity &quot;</span> + r.intent.getComponent().toShortString() +</span><br><span class="line">                    <span class="string">&quot; did not call through to super.onCreate()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            r.activity = activity;</span><br><span class="line">            r.stopped = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">                <span class="comment">// Activity onStart执行</span></span><br><span class="line">                activity.performStart();</span><br><span class="line">                r.stopped = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (r.state != <span class="keyword">null</span> || r.persistentState != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class="line">                                r.persistentState);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        r.paused = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        mActivities.put(r.token, r);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是Activity真正创建实例且onCreate执行的地方,通过调用Activity#attach方法，ActivityClientRecord的token就和Activity联系起来了</p>
<h5 id="BActivity-onStart"><a href="#BActivity-onStart" class="headerlink" title="BActivity#onStart"></a>BActivity#onStart</h5><p>onCreate执行完成后，直接调用了<code>activity.performStart();</code>去执行onStart，因此我们可以得出结论:在Activity的<code>onCreate</code>和<code>onStart</code>方法中去处理逻辑，实际没有特别大的区别</p>
<h5 id="BActivity-onResume"><a href="#BActivity-onResume" class="headerlink" title="BActivity#onResume"></a>BActivity#onResume</h5><p><code>performLaunchActivity</code>调用有返回值，即创建的Activity,如果返回值不为空，则说明创建Activity成功，继续执行<code>handleResumeActivity</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">handleResumeActivity</span><span class="params">(IBinder token,</span></span><br><span class="line"><span class="params">    <span class="type">boolean</span> clearHide, <span class="type">boolean</span> isForward, <span class="type">boolean</span> reallyResume, <span class="type">int</span> seq, String reason)</span> &#123;</span><br><span class="line">    <span class="type">ActivityClientRecord</span> <span class="variable">r</span> <span class="operator">=</span> mActivities.get(token);</span><br><span class="line">    <span class="keyword">if</span> (!checkAndUpdateLifecycleSeq(seq, r, <span class="string">&quot;resumeActivity&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 执行onResume</span></span><br><span class="line">    r = performResumeActivity(token, clearHide, reason);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Activity</span> <span class="variable">a</span> <span class="operator">=</span> r.activity;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向messageQueue发送一个Idle消息</span></span><br><span class="line">        <span class="keyword">if</span> (!r.onlyLocalRequest) &#123;</span><br><span class="line">            r.nextIdle = mNewActivities;</span><br><span class="line">            mNewActivities = r;</span><br><span class="line">            <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">                TAG, <span class="string">&quot;Scheduling idle handler for &quot;</span> + r);</span><br><span class="line">            Looper.myQueue().addIdleHandler(<span class="keyword">new</span> <span class="title class_">Idler</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        r.onlyLocalRequest = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知AMS完成了Resume操作</span></span><br><span class="line">        <span class="keyword">if</span> (reallyResume) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ActivityManager.getService().activityResumed(token);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>performResumeActivity</code>是Activity的onResume执行的地方</p>
<h5 id="AActivity-onStop"><a href="#AActivity-onStop" class="headerlink" title="AActivity#onStop"></a>AActivity#onStop</h5><p>在执行完成后向住现成的MessageQueue发送了一个idle消息，这个很重要，具体是做什么的呢，我们进去看一下Idler的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Idler</span> <span class="keyword">implements</span> <span class="title class_">MessageQueue</span>.IdleHandler &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">queueIdle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ActivityClientRecord</span> <span class="variable">a</span> <span class="operator">=</span> mNewActivities;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">stopProfiling</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mBoundApplication != <span class="literal">null</span> &amp;&amp; mProfiler.profileFd != <span class="literal">null</span></span><br><span class="line">                &amp;&amp; mProfiler.autoStopProfiler) &#123;</span><br><span class="line">            stopProfiling = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">            mNewActivities = <span class="literal">null</span>;</span><br><span class="line">            <span class="type">IActivityManager</span> <span class="variable">am</span> <span class="operator">=</span> ActivityManager.getService();</span><br><span class="line">            ActivityClientRecord prev;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">                    TAG, <span class="string">&quot;Reporting idle of &quot;</span> + a +</span><br><span class="line">                    <span class="string">&quot; finished=&quot;</span> +</span><br><span class="line">                    (a.activity != <span class="literal">null</span> &amp;&amp; a.activity.mFinished));</span><br><span class="line">                <span class="keyword">if</span> (a.activity != <span class="literal">null</span> &amp;&amp; !a.activity.mFinished) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="comment">// 调用ActivityManagerService#activityIdle</span></span><br><span class="line">                        am.activityIdle(a.token, a.createdConfig, stopProfiling);</span><br><span class="line">                        a.createdConfig = <span class="literal">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = a;</span><br><span class="line">                a = a.nextIdle;</span><br><span class="line">                prev.nextIdle = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (a != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stopProfiling) &#123;</span><br><span class="line">            mProfiler.stopProfiling();</span><br><span class="line">        &#125;</span><br><span class="line">        ensureJitEnabled();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看<code>am.activityIdle(a.token, a.createdConfig, stopProfiling)</code>这里，这种调用在本文中出现过很多次了，我们很容易得出结论：这是一次IPC调用，对应的方法在ActivityManagerService#activityIdle:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">activityIdle</span><span class="params">(IBinder token, Configuration config, <span class="type">boolean</span> stopProfiling)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">origId</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="type">ActivityStack</span> <span class="variable">stack</span> <span class="operator">=</span> ActivityRecord.getStackLocked(token);</span><br><span class="line">        <span class="keyword">if</span> (stack != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ActivityRecord</span> <span class="variable">r</span> <span class="operator">=</span></span><br><span class="line">                    mStackSupervisor.activityIdleInternalLocked(token, <span class="literal">false</span> <span class="comment">/* fromTimeout */</span>,</span><br><span class="line">                            <span class="literal">false</span> <span class="comment">/* processPausingActivities */</span>, config);</span><br><span class="line">            <span class="keyword">if</span> (stopProfiling) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((mProfileProc == r.app) &amp;&amp; mProfilerInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">                    clearProfilerLocked();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Binder.restoreCallingIdentity(origId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做的工作不多，调用了<code>mStackSupervisor.activityIdleInternalLocked</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ActivityRecord <span class="title function_">activityIdleInternalLocked</span><span class="params">(<span class="keyword">final</span> IBinder token, <span class="type">boolean</span> fromTimeout,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> processPausingActivities, Configuration config)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_ALL) Slog.v(TAG, <span class="string">&quot;Activity idle: &quot;</span> + token);</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// Atomically retrieve all of the other things to do.</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ActivityRecord&gt; stops = processStoppingActivitiesLocked(r,</span><br><span class="line">            <span class="literal">true</span> <span class="comment">/* remove */</span>, processPausingActivities);</span><br><span class="line">    NS = stops != <span class="literal">null</span> ? stops.size() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((NF = mFinishingActivities.size()) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        finishes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(mFinishingActivities);</span><br><span class="line">        mFinishingActivities.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mStartingUsers.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        startingUsers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(mStartingUsers);</span><br><span class="line">        mStartingUsers.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Stop any activities that are scheduled to do so but have been</span></span><br><span class="line">    <span class="comment">// waiting for the next one to start.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; NS; i++) &#123;</span><br><span class="line">        r = stops.get(i);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ActivityStack</span> <span class="variable">stack</span> <span class="operator">=</span> r.getStack();</span><br><span class="line">        <span class="keyword">if</span> (stack != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.finishing) &#123;</span><br><span class="line">                stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.stopActivityLocked(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>processStoppingActivitiesLocked</code>做的操作就是寻找需要被Stop的Activity，进去看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ArrayList&lt;ActivityRecord&gt; <span class="title function_">processStoppingActivitiesLocked</span><span class="params">(ActivityRecord idleActivity,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> remove, <span class="type">boolean</span> processPausingActivities)</span> &#123;</span><br><span class="line">    ArrayList&lt;ActivityRecord&gt; stops = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">nowVisible</span> <span class="operator">=</span> allResumedActivitiesVisible();</span><br><span class="line">    <span class="comment">// 遍历mStoppingActivities列表，选择其中符合Stop条件的Activity</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">activityNdx</span> <span class="operator">=</span> mStoppingActivities.size() - <span class="number">1</span>; activityNdx &gt;= <span class="number">0</span>; --activityNdx) &#123;</span><br><span class="line">        <span class="type">ActivityRecord</span> <span class="variable">s</span> <span class="operator">=</span> mStoppingActivities.get(activityNdx);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">waitingVisible</span> <span class="operator">=</span> mActivitiesWaitingForVisibleActivity.contains(s);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG, <span class="string">&quot;Stopping &quot;</span> + s + <span class="string">&quot;: nowVisible=&quot;</span> + nowVisible</span><br><span class="line">                + <span class="string">&quot; waitingVisible=&quot;</span> + waitingVisible + <span class="string">&quot; finishing=&quot;</span> + s.finishing);</span><br><span class="line">        <span class="keyword">if</span> (waitingVisible &amp;&amp; nowVisible) &#123;</span><br><span class="line">            mActivitiesWaitingForVisibleActivity.remove(s);</span><br><span class="line">            waitingVisible = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (s.finishing) &#123;</span><br><span class="line">                s.setVisibility(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (remove) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ActivityStack</span> <span class="variable">stack</span> <span class="operator">=</span> s.getStack();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">shouldSleepOrShutDown</span> <span class="operator">=</span> stack != <span class="literal">null</span></span><br><span class="line">                    ? stack.shouldSleepOrShutDownActivities()</span><br><span class="line">                    : mService.isSleepingOrShuttingDownLocked();</span><br><span class="line">            <span class="keyword">if</span> (!waitingVisible || shouldSleepOrShutDown) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!processPausingActivities &amp;&amp; s.state == PAUSING) &#123;</span><br><span class="line">                    <span class="comment">// Defer processing pausing activities in this iteration and reschedule</span></span><br><span class="line">                    <span class="comment">// a delayed idle to reprocess it again</span></span><br><span class="line">                    removeTimeoutsForActivityLocked(idleActivity);</span><br><span class="line">                    scheduleIdleTimeoutLocked(idleActivity);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG, <span class="string">&quot;Ready to stop: &quot;</span> + s);</span><br><span class="line">                <span class="keyword">if</span> (stops == <span class="literal">null</span>) &#123;</span><br><span class="line">                    stops = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                stops.add(s);</span><br><span class="line">                mStoppingActivities.remove(activityNdx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前在执行AActivity的Pause操作后，我们将AActivity加入到了ActivityStackSupervisor类中一个叫mStoppingActivities的列表中，在这里这个列表就派上用场了，我们会遍历这个列表，从中获取符合条件的Activity并组装到一个新的列表中返回。</p>
<p>完成这个操作后，<code>activityIdleInternalLocked</code>开始遍历这个返回的列表进Stop操作。</p>
<p>看<code>stack.stopActivityLocked(r)</code>,凭我20年Android开发经验练就的火眼金睛，感觉这里就是AActivity#onStop触发的地方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActivityStack</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">stopActivityLocked</span><span class="params">(ActivityRecord r)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="literal">null</span> &amp;&amp; r.app.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">        adjustFocusedActivityStackLocked(r, <span class="string">&quot;stopActivity&quot;</span>);</span><br><span class="line">        r.resumeKeyDispatchingLocked();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            r.app.thread.scheduleStopActivity(r.appToken, r.visible, r.configChangeFlags);</span><br><span class="line">            <span class="keyword">if</span> (shouldSleepOrShutDownActivities()) &#123;</span><br><span class="line">                r.setSleeping(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(STOP_TIMEOUT_MSG, r);</span><br><span class="line">            mHandler.sendMessageDelayed(msg, STOP_TIMEOUT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>果然，在这个方法内部执行了<code>r.app.thread.scheduleStopActivity</code>,这个方法就不进去看了，我们只需要知道它最终调用了r的onStop就可以了</p>
<p>至此，从AActivity跳转BActivity所经历的生命周期就全部完成了。</p>
<p>为什么要用IdleHandler?</p>
<p>我猜测是因为google的工程师认为既然BActivity已经启动了，那么主线程Handler的首要任务还是处理B进程内部的事情，至于AActivity，反正都已经Pause了，就抽个空闲时间告诉AMS把它Stop就可以了。</p>
<h4 id="从BActivity返回到AActivity"><a href="#从BActivity返回到AActivity" class="headerlink" title="从BActivity返回到AActivity"></a>从BActivity返回到AActivity</h4><p>先回顾一下从BActivity返回AActivity经历的生命周期</p>
<p>BActivity#onPause -&gt; AActivity#onStart -&gt; AActivity#onResume -&gt; BActivity#onStop -&gt; BActivity#onDestroy</p>
<p>先从BActivity的finish方法说起</p>
<p>BActivity的finish方法最终会调用到AMS的finishActivity方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActivityManagerService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">finishActivity</span><span class="params">(IBinder token, <span class="type">int</span> resultCode, Intent resultData,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> finishTask)</span> &#123;</span><br><span class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">    <span class="keyword">if</span> (resultData != <span class="literal">null</span> &amp;&amp; resultData.hasFileDescriptors() == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;File descriptors passed in Intent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="type">ActivityRecord</span> <span class="variable">r</span> <span class="operator">=</span> ActivityRecord.isInStackLocked(token);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Keep track of the root activity of the task before we finish it</span></span><br><span class="line">        <span class="type">TaskRecord</span> <span class="variable">tr</span> <span class="operator">=</span> r.getTask();</span><br><span class="line">        <span class="comment">// 正在结束的Activity所在的ActivityTask</span></span><br><span class="line">        <span class="type">ActivityRecord</span> <span class="variable">rootR</span> <span class="operator">=</span> tr.getRootActivity();</span><br><span class="line">        <span class="keyword">if</span> (rootR == <span class="literal">null</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Finishing task with all activities already finished&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">origId</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> res;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">finishWithRootActivity</span> <span class="operator">=</span></span><br><span class="line">                    finishTask == Activity.FINISH_TASK_WITH_ROOT_ACTIVITY;</span><br><span class="line">            <span class="keyword">if</span> (finishTask == Activity.FINISH_TASK_WITH_ACTIVITY</span><br><span class="line">                    || (finishWithRootActivity &amp;&amp; r == rootR)) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = tr.getStack().requestFinishActivityLocked(token, resultCode,</span><br><span class="line">                        resultData, <span class="string">&quot;app-request&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>入参的含义：</p>
<ul>
<li>token ： 准备finish的Activity的Binder token引用</li>
<li>resultCode：  resultCode  字面意思，在onActivityResult接收到的</li>
<li>resultData： ResultData  字面意思，在onActivityResult接收得到的</li>
<li>finishTask： 是否将ActivityStack一起finish<br>在这里我们又和token见面了，在前面从AActivity启动BActivity的流程里我们分析过，这个token是BActivity在AMS中的标识。</li>
</ul>
<p><code>ActivityManagerService#finishActivity</code>经过层层调用，会调用到<code>ActivityStack#finishActivityLocked</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">finishActivityLocked</span><span class="params">(ActivityRecord r, <span class="type">int</span> resultCode, Intent resultData,</span></span><br><span class="line"><span class="params">            String reason, <span class="type">boolean</span> oomAdj, <span class="type">boolean</span> pauseImmediately)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (r.finishing) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Duplicate finish request for &quot;</span> + r);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mWindowManager.deferSurfaceLayout();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将r标记为finishing</span></span><br><span class="line">        r.makeFinishingLocked();</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 将resultCode和resultData设置给resultTo</span></span><br><span class="line">        finishActivityResultsLocked(r, resultCode, resultData);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">endTask</span> <span class="operator">=</span> index &lt;= <span class="number">0</span> &amp;&amp; !task.isClearingToReuseTask();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">transit</span> <span class="operator">=</span> endTask ? TRANSIT_TASK_CLOSE : TRANSIT_ACTIVITY_CLOSE;</span><br><span class="line">        <span class="keyword">if</span> (mResumedActivity == r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_VISIBILITY || DEBUG_TRANSITION) Slog.v(TAG_TRANSITION,</span><br><span class="line">                    <span class="string">&quot;Prepare close transition: finishing &quot;</span> + r);</span><br><span class="line">            <span class="keyword">if</span> (endTask) &#123;</span><br><span class="line">                mService.mTaskChangeNotificationController.notifyTaskRemovalStarted(</span><br><span class="line">                        task.taskId);</span><br><span class="line">            &#125;</span><br><span class="line">            mWindowManager.prepareAppTransition(transit, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Tell window manager to prepare for this one to be removed.</span></span><br><span class="line">            r.setVisibility(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPausingActivity == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG_PAUSE, <span class="string">&quot;Finish needs to pause: &quot;</span> + r);</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_USER_LEAVING) Slog.v(TAG_USER_LEAVING,</span><br><span class="line">                        <span class="string">&quot;finish() =&gt; pause with userLeaving=false&quot;</span>);</span><br><span class="line">                <span class="comment">// 将当前处于活跃状态的Activity进行Pause</span></span><br><span class="line">                startPausingLocked(<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>, pauseImmediately);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (endTask) &#123;</span><br><span class="line">                mStackSupervisor.removeLockedTaskLocked(task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state != ActivityState.PAUSING) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG_PAUSE, <span class="string">&quot;Finish waiting for pause of: &quot;</span> + r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mWindowManager.continueSurfaceLayout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本方法重点事项</p>
<ol>
<li>将r(即将要finish的Activity)的finishing标记位置为true</li>
<li>将将resultCode和resultData设置给resultTo，这个resultTo是我们在创建r的时候传入的，在AActivity跳BActivity的流程中我们介绍过，本场景中resultTo指AActivity的token</li>
<li>将当前处于活跃状态的Activity进行pause,本场景中活跃状态的Activity就是AActivity</li>
</ol>
<h5 id="BActivity-onPause"><a href="#BActivity-onPause" class="headerlink" title="BActivity#onPause"></a>BActivity#onPause</h5><p>其中<code>startPausingLocked</code>方法我们在前面已经分析过了，这里就不再赘述了，详细的分析可以看3.5.1章节。通过之前的分析我们知道，startPausingLocked会执行BActvity的onPause回调并最终调用到<code>ActivityManagerService#activityPaused</code>方法，这个放我我们之前也做过分析，最终会调用到<code>ActivityStack#resumeTopActivityInnerLocked</code>，这个方法的调用和BActivity的启动流程略有不同</p>
<h5 id="AActivity-onStart、AActivity-onResume"><a href="#AActivity-onStart、AActivity-onResume" class="headerlink" title="AActivity#onStart、AActivity#onResume"></a>AActivity#onStart、AActivity#onResume</h5><p>在调用<code>ActivityStack#resumeTopActivityInnerLocked</code>时，因为我们已经完成对BActivity的Pause，因此，获取栈顶Activity 即next时，拿到的会是AActivity，而AActivity的app和thread均不为空，因此，<br> 判断语句<code>if (next.app != null &amp;&amp; next.app.thread != null)</code> 成立，它会走入<code>ActivityStack#resumeTopActivityInnerLocked</code>如下分支：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (next.app != <span class="keyword">null</span> &amp;&amp; next.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG_SWITCH, <span class="string">&quot;Resume running: &quot;</span> + next</span><br><span class="line">            + <span class="string">&quot; stopped=&quot;</span> + next.stopped + <span class="string">&quot; visible=&quot;</span> + next.visible);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Deliver all pending results.</span></span><br><span class="line">            ArrayList&lt;ResultInfo&gt; a = next.results;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="built_in">int</span> N = a.size();</span><br><span class="line">                <span class="keyword">if</span> (!next.finishing &amp;&amp; N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_RESULTS) Slog.v(TAG_RESULTS,</span><br><span class="line">                            <span class="string">&quot;Delivering results to &quot;</span> + next + <span class="string">&quot;: &quot;</span> + a);</span><br><span class="line">                    next.app.thread.scheduleSendResult(next.appToken, a);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (next.newIntents != <span class="keyword">null</span>) &#123;</span><br><span class="line">                next.app.thread.scheduleNewIntent(</span><br><span class="line">                        next.newIntents, next.appToken, <span class="keyword">false</span> <span class="comment">/* andPause */</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Well the app will no longer be stopped.</span></span><br><span class="line">            <span class="comment">// Clear app token stopped state in window manager if needed.</span></span><br><span class="line">            next.notifyAppResumed(next.stopped);</span><br><span class="line"></span><br><span class="line">            EventLog.writeEvent(EventLogTags.AM_RESUME_ACTIVITY, next.userId,</span><br><span class="line">                    System.identityHashCode(next), next.getTask().taskId,</span><br><span class="line">                    next.shortComponentName);</span><br><span class="line"></span><br><span class="line">            next.sleeping = <span class="keyword">false</span>;</span><br><span class="line">            mService.showUnsupportedZoomDialogIfNeededLocked(next);</span><br><span class="line">            mService.showAskCompatModeDialogLocked(next);</span><br><span class="line">            next.app.pendingUiClean = <span class="keyword">true</span>;</span><br><span class="line">            next.app.forceProcessStateUpTo(mService.mTopProcessState);</span><br><span class="line">            next.clearOptionsLocked();</span><br><span class="line">            <span class="comment">// zhangyulong ResumeNextActivity</span></span><br><span class="line">            next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState,</span><br><span class="line">                    mService.isNextTransitionForward(), resumeAnimOptions);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES, <span class="string">&quot;resumeTopActivityLocked: Resumed &quot;</span></span><br><span class="line">                    + next);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意看<code>next.app.thread.scheduleResumeActivity</code>这里，这个方法最终会调用AActivity的onRestart、onStart和onResume,这个部分的调用大家肯定都轻车熟路了，就不跟进去看了</p>
<h5 id="BActivity-onStop、BActivity-onDestroy"><a href="#BActivity-onStop、BActivity-onDestroy" class="headerlink" title="BActivity#onStop、BActivity#onDestroy"></a>BActivity#onStop、BActivity#onDestroy</h5><p>在BActivity启动流程分析中，我们知道在onResume时，会向主线程MessageQueue发送一个IdleHandler，这个IdleHandler最终会调用<code>ActivityStackSupervisor#activityIdleInternalLocked</code>，但这次的调用又跟之前有所不同，因为我们在之前的操作时已经将BActivity置为finishing，因此<code>if (r.finishing)</code>判断为true，方法调用会执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ActivityRecord <span class="title function_">activityIdleInternalLocked</span><span class="params">(<span class="keyword">final</span> IBinder token, <span class="type">boolean</span> fromTimeout,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> processPausingActivities, Configuration config)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_ALL) Slog.v(TAG, <span class="string">&quot;Activity idle: &quot;</span> + token);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Atomically retrieve all of the other things to do.</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ActivityRecord&gt; stops = processStoppingActivitiesLocked(r,</span><br><span class="line">            <span class="literal">true</span> <span class="comment">/* remove */</span>, processPausingActivities);</span><br><span class="line">    NS = stops != <span class="literal">null</span> ? stops.size() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((NF = mFinishingActivities.size()) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        finishes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(mFinishingActivities);</span><br><span class="line">        mFinishingActivities.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mStartingUsers.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        startingUsers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(mStartingUsers);</span><br><span class="line">        mStartingUsers.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stop any activities that are scheduled to do so but have been</span></span><br><span class="line">    <span class="comment">// waiting for the next one to start.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; NS; i++) &#123;</span><br><span class="line">        r = stops.get(i);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ActivityStack</span> <span class="variable">stack</span> <span class="operator">=</span> r.getStack();</span><br><span class="line">        <span class="keyword">if</span> (stack != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.finishing) &#123;</span><br><span class="line">                <span class="comment">// stop 且 pause</span></span><br><span class="line">                stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 仅stop</span></span><br><span class="line">                stack.stopActivityLocked(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法执行<code>stack.finishCurrentActivityLocked</code>后，在APP进程对应执行BActivity的onStop和onDestroy</p>
<p>至此，BActivity返回AActivity的生命周期也执行完毕</p>
<h2 id="AMS源码分析-二-onActivityResult执行过程"><a href="#AMS源码分析-二-onActivityResult执行过程" class="headerlink" title="AMS源码分析(二)onActivityResult执行过程"></a>AMS源码分析(二)onActivityResult执行过程</h2><h3 id="onActivityResult"><a href="#onActivityResult" class="headerlink" title="onActivityResult"></a>onActivityResult</h3><p>onActivityResult机制的使用，属于Android基础知识，我想每一个Android程序员都用过，这里就不多做解释了，看一下使用方式</p>
<h4 id="AActivity跳转BAcitivty并从BActivity返回数据"><a href="#AActivity跳转BAcitivty并从BActivity返回数据" class="headerlink" title="AActivity跳转BAcitivty并从BActivity返回数据"></a>AActivity跳转BAcitivty并从BActivity返回数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AActivity</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    activityName = <span class="string">&quot;AActivity&quot;</span>;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_stack_test);</span><br><span class="line">    jumpBtn = findViewById(R.id.jumpBtn);</span><br><span class="line">    jumpBtn.setOnClickListener(v -&gt; &#123;</span><br><span class="line">        BActivity.start(<span class="built_in">this</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    setActivityName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onActivityResult</span><span class="params">(<span class="type">int</span> requestCode, <span class="type">int</span> resultCode, Intent data)</span> &#123;</span><br><span class="line">    Log.d(<span class="string">&quot;zyl&quot;</span>, activityName + <span class="string">&quot;      requestCode = &quot;</span> + requestCode + <span class="string">&quot;       resultCode = &quot;</span> + resultCode);</span><br><span class="line">    <span class="built_in">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// BActivity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Activity activity, <span class="type">int</span> requestCode)</span> &#123;</span><br><span class="line">   activity.startActivityForResult(<span class="keyword">new</span> <span class="title class_">Intent</span>(activity, BActivity.class), requestCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    activityName = <span class="string">&quot;BActivity&quot;</span>;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_stack_test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finish</span><span class="params">()</span> &#123;</span><br><span class="line">    setResult(<span class="number">102</span>);</span><br><span class="line">    <span class="built_in">super</span>.finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当BActivity finish时，会将resultCode和requestCode通过AActivity的onActivityResult回传回来</p>
<h3 id="Intent-FLAG-ACTIVITY-FORWARD-RESULT"><a href="#Intent-FLAG-ACTIVITY-FORWARD-RESULT" class="headerlink" title="Intent.FLAG_ACTIVITY_FORWARD_RESULT"></a>Intent.FLAG_ACTIVITY_FORWARD_RESULT</h3><p>这是onActivityResult的另一种表现形式，在日常开发中我们经常会遇到如下场景<br> 1.我要从Activity A 跳到B再跳到C<br> 2.我要从Activity C 返回数据给Activity A<br> 3.这种跳转层级有可能有很多层，比如 A -&gt;B -&gt; C -&gt; D -&gt; E等等</p>
<p>有同学看完肯定会说，这个简单啊，每个Activity都实现onActivityResult，每次跳转都使用startActivityForResult不就行了，这样当然可以，但是代码会稍显冗余。实际上，Android系统已经帮我们想好了这种场景的处理方式了</p>
<p>Intent.FLAG_ACTIVITY_FORWARD_RESULT的作用就是最后一个Activity直接调用第一个Activity的onActivityResult</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p>以AActivity跳转BActivity跳转CActivity为例：</p>
<h5 id="AActivity以startActivityForResult方式打开BActivity"><a href="#AActivity以startActivityForResult方式打开BActivity" class="headerlink" title="AActivity以startActivityForResult方式打开BActivity"></a>AActivity以startActivityForResult方式打开BActivity</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Activity activity, <span class="type">int</span> requestCode)</span> &#123;</span><br><span class="line">    <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(activity, BActivity.class);</span><br><span class="line">    activity.startActivityForResult(intent, requestCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="BActivity以普通方式打开CActivity，设置Intent-的Flag-Intent-FLAG-ACTIVITY-FORWARD-RESULT"><a href="#BActivity以普通方式打开CActivity，设置Intent-的Flag-Intent-FLAG-ACTIVITY-FORWARD-RESULT" class="headerlink" title="BActivity以普通方式打开CActivity，设置Intent 的Flag Intent.FLAG_ACTIVITY_FORWARD_RESULT"></a>BActivity以普通方式打开CActivity，设置Intent 的Flag Intent.FLAG_ACTIVITY_FORWARD_RESULT</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">    <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(context, CActivity.class);</span><br><span class="line">    intent.setFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);</span><br><span class="line">    context.startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CActivity和BActivity返回后，AActivity会接收到从CActivity传递过来的消息</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="ActivityResult数据的写入"><a href="#ActivityResult数据的写入" class="headerlink" title="ActivityResult数据的写入"></a>ActivityResult数据的写入</h4><p>上篇文章我们在解析Activity的finish过程时其实稍微接触了一些onActivity的执行流程，在Activity的finish过程中，会调用到<code>ActivityStack#finishActivityResultsLocked</code>方法</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishActivityResultsLocked</span>(<span class="params">ActivityRecord r, <span class="built_in">int</span> resultCode, Intent resultData</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// zhangyulong 将结果传递给谁</span></span><br><span class="line">    ActivityRecord resultTo = r.resultTo;</span><br><span class="line">    <span class="keyword">if</span> (resultTo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_RESULTS) Slog.v(TAG_RESULTS, <span class="string">&quot;Adding result to &quot;</span> + resultTo</span><br><span class="line">                + <span class="string">&quot; who=&quot;</span> + r.resultWho + <span class="string">&quot; req=&quot;</span> + r.requestCode</span><br><span class="line">                + <span class="string">&quot; res=&quot;</span> + resultCode + <span class="string">&quot; data=&quot;</span> + resultData);</span><br><span class="line">        <span class="keyword">if</span> (resultTo.userId != r.userId) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultData != <span class="literal">null</span>) &#123;</span><br><span class="line">                resultData.prepareToLeaveUser(r.userId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.info.applicationInfo.uid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mService.grantUriPermissionFromIntentLocked(r.info.applicationInfo.uid,</span><br><span class="line">                    resultTo.packageName, resultData,</span><br><span class="line">                    resultTo.getUriPermissionsLocked(), resultTo.userId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// zhangyulong 将ActivityResult结果放在resultTo中保存</span></span><br><span class="line">        resultTo.addResultLocked(r, r.resultWho, r.requestCode, resultCode,</span><br><span class="line">                                 resultData);</span><br><span class="line">        r.resultTo = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_RESULTS) Slog.v(TAG_RESULTS, <span class="string">&quot;No result destination from &quot;</span> + r);</span><br><span class="line">    r.results = <span class="literal">null</span>;</span><br><span class="line">    r.pendingResults = <span class="literal">null</span>;</span><br><span class="line">    r.newIntents = <span class="literal">null</span>;</span><br><span class="line">    r.icicle = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>入参含义：</p>
<ul>
<li>r：即将finish的Activity</li>
<li>resultCode: 要传递的resultCode</li>
<li>resultData：要传递的Intent<br>这个方法将result信息封装成一个ResultIfo对象，并保存在列表中</li>
</ul>
<h4 id="ActivityResult数据的传递"><a href="#ActivityResult数据的传递" class="headerlink" title="ActivityResult数据的传递"></a>ActivityResult数据的传递</h4><p>在上篇文章中，我们在分析Activity的finish流程时提到过<code>ActivityStack#resumeTopActivityInnerLocked</code>方法，这个方法还有一个作用就是向上一个Activity,即<code>resultTo</code>传递ActivityResult</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (next.app != <span class="literal">null</span> &amp;&amp; next.app.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">synchronized</span>(mWindowManager.getWindowManagerLock()) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Deliver all pending results.</span></span><br><span class="line">                ArrayList&lt;ResultInfo&gt; a = next.results;</span><br><span class="line">                <span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> a.size();</span><br><span class="line">                    <span class="keyword">if</span> (!next.finishing &amp;&amp; N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_RESULTS) Slog.v(TAG_RESULTS,</span><br><span class="line">                                <span class="string">&quot;Delivering results to &quot;</span> + next + <span class="string">&quot;: &quot;</span> + a);</span><br><span class="line">                        next.app.thread.scheduleSendResult(next.appToken, a);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       ....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用<code>next.app.thread.scheduleSendResult(next.appToken, a)</code>将ResultInfo发送到App进程中对应的Activity中，并回调onActivityResult方法</p>
<h4 id="Intent-FLAG-ACTIVITY-FORWARD-RESULT的实现"><a href="#Intent-FLAG-ACTIVITY-FORWARD-RESULT的实现" class="headerlink" title="Intent.FLAG_ACTIVITY_FORWARD_RESULT的实现"></a>Intent.FLAG_ACTIVITY_FORWARD_RESULT的实现</h4><p>上篇文章我们分析过，Activity的启动流程会调用<code>ActivityStarter#startActivity</code>,这个方法有对Intent.FLAG_ACTIVITY_FORWARD_RESULT的处理，废话不多说，直接看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">startActivity</span><span class="params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span></span><br><span class="line"><span class="params">       String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span></span><br><span class="line"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">        IBinder resultTo, String resultWho, <span class="type">int</span> requestCode, <span class="type">int</span> callingPid, <span class="type">int</span> callingUid,</span></span><br><span class="line"><span class="params">        String callingPackage, <span class="type">int</span> realCallingPid, <span class="type">int</span> realCallingUid, <span class="type">int</span> startFlags,</span></span><br><span class="line"><span class="params">        ActivityOptions options, <span class="type">boolean</span> ignoreTargetSecurity, <span class="type">boolean</span> componentSpecified,</span></span><br><span class="line"><span class="params">        ActivityRecord[] outActivity, TaskRecord inTask)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">ActivityRecord</span> <span class="variable">sourceRecord</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ActivityRecord</span> <span class="variable">resultRecord</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (resultTo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// zhangyulong 获取启动的源activity</span></span><br><span class="line">        sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_RESULTS) Slog.v(TAG_RESULTS,</span><br><span class="line">                <span class="string">&quot;Will send result to &quot;</span> + resultTo + <span class="string">&quot; &quot;</span> + sourceRecord);</span><br><span class="line">        <span class="keyword">if</span> (sourceRecord != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span> &amp;&amp; !sourceRecord.finishing) &#123;</span><br><span class="line">                resultRecord = sourceRecord;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != <span class="number">0</span> &amp;&amp; sourceRecord != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 添加Intent.FLAG_ACTIVITY_FORWARD_RESULT启动的Activity不能使用startActivityForResult启动</span></span><br><span class="line">        <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ActivityOptions.abort(options);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将源Activity的resultTo赋值给目标Activity</span></span><br><span class="line">        resultRecord = sourceRecord.resultTo;</span><br><span class="line">        <span class="keyword">if</span> (resultRecord != <span class="literal">null</span> &amp;&amp; !resultRecord.isInStackLocked()) &#123;</span><br><span class="line">            resultRecord = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        resultWho = sourceRecord.resultWho;</span><br><span class="line">        requestCode = sourceRecord.requestCode;</span><br><span class="line">        sourceRecord.resultTo = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (resultRecord != <span class="literal">null</span>) &#123;</span><br><span class="line">            resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sourceRecord.launchedFromUid == callingUid) &#123;</span><br><span class="line">            callingPackage = sourceRecord.launchedFromPackage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, <span class="literal">true</span>,</span><br><span class="line">            options, inTask, outActivity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码比较简单，主要就是判断Intent中是否带有Intent.FLAG_ACTIVITY_FORWARD_RESULT标签，如果有，则将源Activity的resultTo赋值给目标Activity</p>
<p>如果有多个中间Activity，比如使用这种方式启动ABCDE五个Activity,其中，BCD都是中间Activity，<br> 那么resultTo的传递过程如下：<br> 1.A启动B，A作为resultTo传递给B<br> 2.B启动C，添加Intent.FLAG_ACTIVITY_FORWARD_RESULT，C获取B的ResultTo即A<br> 3.C启动D，添加Intent.FLAG_ACTIVITY_FORWARD_RESULT，D获取C的ResultTo即A<br> 4.D启动E，添加Intent.FLAG_ACTIVITY_FORWARD_RESULT，E获取D的ResultTo即A<br> 5.从E逐级返回，当E返回时，将ResultInfo赋值给A，当返回到A时，触发<code>next.app.thread.scheduleSendResult(next.appToken, a)</code></p>
<h2 id="AMS源码分析-三-AMS中Activity栈管理详解"><a href="#AMS源码分析-三-AMS中Activity栈管理详解" class="headerlink" title="AMS源码分析(三)AMS中Activity栈管理详解"></a>AMS源码分析(三)AMS中Activity栈管理详解</h2><p>Activity栈管理是AMS的另一个重要功能，栈管理又和Activity的启动模式和startActivity时所设置的Flag息息相关，Activity栈管理的主要处理逻辑是在<code>ActivityStarter#startActivityUnchecked</code>方法中，本文也会围绕着这个方法进进出出，反复摩擦，直到脑海中都是它的形状。goolge的工程师起名还是很讲究的，为什么要带Unchecked呢? Unchecked-不确定，是因为在执行这个方法时，我要启动哪个Activity还没决定呢，具体为什么，我想看过这篇文章你就明白了。</p>
<h3 id="Activity栈管理相关类"><a href="#Activity栈管理相关类" class="headerlink" title="Activity栈管理相关类"></a>Activity栈管理相关类</h3><h4 id="ActivityStackSupervisor"><a href="#ActivityStackSupervisor" class="headerlink" title="ActivityStackSupervisor"></a>ActivityStackSupervisor</h4><p>顾名思义，Activity栈的功能提供者和管理者</p>
<h4 id="ActivityDisplay"><a href="#ActivityDisplay" class="headerlink" title="ActivityDisplay"></a>ActivityDisplay</h4><p>表示一个屏幕，Android支持三种屏幕：主屏幕，外接屏幕（HDMI等），虚拟屏幕（投屏）。一般情况下，即只有主屏幕时，ActivityStackSupervisor与ActivityDisplay都是系统唯一</p>
<h4 id="TaskRecord"><a href="#TaskRecord" class="headerlink" title="TaskRecord"></a>TaskRecord</h4><p>ActivityTask记录, Task是我们管理Activity栈的重要单元，它的表现形式与逻辑和Activity启动模式息息相关，也是本文重点要分析的</p>
<h4 id="ActivityStack"><a href="#ActivityStack" class="headerlink" title="ActivityStack"></a>ActivityStack</h4><p>针对ActivityRecord 和 TaskRecord进行管理，记录ActivityRecord的状态和TaskRecord的状态。在Android N之前只有两种ActivityStack:homeStack（launcher和recents Activity）和其他。Android N开始有5种，增加了DockedStack（分屏Activity）、PinnedStack（画中画Activity）、freeformstack(自由模式Activity)，虽然它名字叫ActivityStack，但是跟我们熟知的数据结构中的栈基本上没啥关系，这也是有可能会增加一点理解难度的地方</p>
<h4 id="关系图："><a href="#关系图：" class="headerlink" title="关系图："></a>关系图：</h4><p>先说一下关系：</p>
<ul>
<li>一个ActivityDisplay包含多个ActivityStack</li>
<li>一个ActivityStack包含多个TaskRecord</li>
<li>一个TaskRecord包含多个ActivityRecord</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3112838-9cc3f298a586ec45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1106/format/webp" alt="img"></p>
<h3 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h3><h4 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h4><p>标准启动模式，启动Activity时依次向栈顶添加ActivityRecord，返回时依次推出，示例:AActivity打开BActivity打开CActivity</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3112838-cd8e980ebd343e68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/591/format/webp" alt="img"></p>
<p>这是基本的Activity启动模式，需要注意的点不太多</p>
<h5 id="Intent-FLAG-ACTIVITY-CLEAR-TOP"><a href="#Intent-FLAG-ACTIVITY-CLEAR-TOP" class="headerlink" title="Intent.FLAG_ACTIVITY_CLEAR_TOP"></a>Intent.FLAG_ACTIVITY_CLEAR_TOP</h5><p>还是刚才的案例，如果依次打开AActivity-&gt;BActivity-&gt;CActivity-&gt;DActivity，此时在DActivity打开AActivity时Intent添加Flag <code>Intent.FLAG_ACTIVITY_CLEAR_TOP</code>,系统会从BActivity开始依次将Task中的Activity依次销毁，直到DActivity,因为DActivity处于活跃状态，因此会先执行onPause,在onPause后，会销毁原来的AActivity,然后打开新的AActivity,最后执行DActivity的onStop和onDestory<br> 流程图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3112838-6c3bcffc85f5f084.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1189/format/webp" alt="img"></p>
<p>log:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3112838-474e338521ee9f68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/871/format/webp" alt="img"></p>
<h5 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h5><h6 id="加入TaskRecord"><a href="#加入TaskRecord" class="headerlink" title="加入TaskRecord"></a>加入TaskRecord</h6><p>摘抄<code>ActivityStarter#startActivityUnchecked</code>部分代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mStartActivity.resultTo == <span class="literal">null</span> &amp;&amp; mInTask == <span class="literal">null</span> &amp;&amp; !mAddingToTask</span><br><span class="line">    &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span>) &#123;</span><br><span class="line">    newTask = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// zhangyulong 使用一个旧的Task 或者新建一个</span></span><br><span class="line">    result = setTaskFromReuseOrCreateNewTask(</span><br><span class="line">            taskToAffiliate, preferredLaunchStackId, topStack);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSourceRecord != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// zhangyulong 使用源Activity的task</span></span><br><span class="line">    result = setTaskFromSourceRecord();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mInTask != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// zhangyulong 使用启动时传递的task</span></span><br><span class="line">    result = setTaskFromInTask();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// zhangyulong 理论上的可能，不可能走到这里</span></span><br><span class="line">    setTaskToCurrentTopOrCreateNewTask();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (result != START_SUCCESS) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们使用标准模式启动，因此，<code>resultTo</code>和<code>mSourceRecord</code>均不为空，这段逻辑会执行<code>setTaskFromSourceRecord</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">int</span> <span class="title">setTaskFromSourceRecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">        <span class="built_in">addOrReparentStartingActivity</span>(sourceTask, <span class="string">&quot;setTaskFromSourceRecord&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> START_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">addOrReparentStartingActivity最终会执行TaskRecord#addActivityAtIndex:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addActivityAtIndex</span><span class="params">(<span class="type">int</span> index, ActivityRecord r)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        mActivities.<span class="built_in">add</span>(index, r);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>向对应的ActivityRecord中的mActivities添加本条记录，完成加入TaskRecord的操作</p>
<h6 id="standard-Intent-FLAG-ACTIVITY-CLEAR-TOP"><a href="#standard-Intent-FLAG-ACTIVITY-CLEAR-TOP" class="headerlink" title="standard + Intent.FLAG_ACTIVITY_CLEAR_TOP"></a>standard + Intent.FLAG_ACTIVITY_CLEAR_TOP</h6><p>回到<code>ActivityStarter#startActivityUnchecked</code>,摘抄部分逻辑如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!mAddingToTask &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_CLEAR_TOP) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 将ActivityTask目标Actiivty之上的Activity全部清空，返回值top为可以复用的Activity</span></span><br><span class="line">    ActivityRecord top = sourceTask.performClearTaskLocked(mStartActivity, mLaunchFlags);</span><br><span class="line">    mKeepCurTransition = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果可复用的Activity不为空，直接调用它的onNewIntent方法并将其resume</span></span><br><span class="line">    <span class="keyword">if</span> (top != <span class="literal">null</span>) &#123;</span><br><span class="line">        ActivityStack.logStartActivity(AM_NEW_INTENT, mStartActivity, top.getTask());</span><br><span class="line">        deliverNewIntent(top);</span><br><span class="line">        mTargetStack.mLastPausedActivity = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">            mSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        ActivityOptions.abort(mOptions);</span><br><span class="line">        <span class="keyword">return</span> START_DELIVERED_TO_TOP;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点看<code>performClearTaskLocked</code>,这里是将目标Activity顶部元素清空的逻辑</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="language-markdown">/<span class="strong">***</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment">* newR: 需要启动的新Activity</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment">* launchFlags: 新Activity的启动模式</span></span></span></span><br><span class="line"><span class="strong"><span class="language-markdown"><span class="comment"><span class="emphasis">*/</span></span></span></span></span><br><span class="line"><span class="keyword">final</span> ActivityRecord performClearTaskLocked(ActivityRecord newR, <span class="built_in">int</span> launchFlags) &#123;</span><br><span class="line">    <span class="built_in">int</span> numActivities = mActivities.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> activityNdx = numActivities - <span class="number">1</span>; activityNdx &gt;= <span class="number">0</span>; --activityNdx) &#123;</span><br><span class="line">        ActivityRecord r = mActivities.<span class="keyword">get</span>(activityNdx);</span><br><span class="line">        <span class="keyword">if</span> (r.finishing) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在目标Task中找到了和新Activity相同的记录</span></span><br><span class="line">        <span class="keyword">if</span> (r.realActivity.equals(newR.realActivity)) &#123;</span><br><span class="line">            <span class="keyword">final</span> ActivityRecord ret = r;</span><br><span class="line">            <span class="comment">//将在其之上的Activity全部清除</span></span><br><span class="line">            <span class="keyword">for</span> (++activityNdx; activityNdx &lt; numActivities; ++activityNdx) &#123;</span><br><span class="line">                r = mActivities.<span class="keyword">get</span>(activityNdx);</span><br><span class="line">                <span class="keyword">if</span> (r.finishing) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ActivityOptions opts = r.takeOptionsLocked();</span><br><span class="line">                <span class="keyword">if</span> (opts != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ret.updateOptionsLocked(opts);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 执行finishActivityLocked，如果Activity已经stop,会直接执行onDestroy,</span></span><br><span class="line">                <span class="comment">// 如果Activity还在活跃，则会先执行onPause</span></span><br><span class="line">                <span class="keyword">if</span> (mStack != <span class="keyword">null</span> &amp;&amp; mStack.finishActivityLocked(</span><br><span class="line">                        r, Activity.RESULT_CANCELED, <span class="keyword">null</span>, <span class="string">&quot;clear-task-stack&quot;</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                    --activityNdx;</span><br><span class="line">                    --numActivities;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ActivityInfo.LAUNCH_MULTIPLE == standrad</span></span><br><span class="line">            <span class="comment">// 如果新Activity的launchMode是standard,且launchFlag没有FLAG_ACTIVITY_SINGLE_TOP，则将之前task</span></span><br><span class="line">            <span class="comment">// 内的activity也结束，以便建立新的</span></span><br><span class="line">            <span class="keyword">if</span> (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE</span><br><span class="line">                    &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_SINGLE_TOP) == <span class="number">0</span></span><br><span class="line">                    &amp;&amp; !ActivityStarter.isDocumentLaunchesIntoExisting(launchFlags)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ret.finishing) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mStack != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mStack.finishActivityLocked(</span><br><span class="line">                                ret, Activity.RESULT_CANCELED, <span class="keyword">null</span>, <span class="string">&quot;clear-task-top&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 返回空，说明不执行onNewIntent</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完这部分代码，我想FLAG_ACTIVITY_CLEAR_TOP是怎么工作的大家也就明白了。</p>
<h4 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h4><p>singleTop:栈顶唯一，它和standrad的区别在于，如果是standrad模式，在栈顶启动一个相同的Activity，会创建一个新的Activity实例，如果是singleTop模式，在栈顶启动相同的Activity则只会调用原有Activity的onNewIntent,如果原Activity不在栈顶，那么表现形式就和standrad相同</p>
<h5 id="流程图："><a href="#流程图：" class="headerlink" title="流程图："></a>流程图：</h5><h6 id="原Activity不在栈顶"><a href="#原Activity不在栈顶" class="headerlink" title="原Activity不在栈顶"></a>原Activity不在栈顶</h6><p><img src="https://upload-images.jianshu.io/upload_images/3112838-a44aedbebde4ad4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/767/format/webp" alt="img"></p>
<h6 id="原Activity在栈顶"><a href="#原Activity在栈顶" class="headerlink" title="原Activity在栈顶"></a>原Activity在栈顶</h6><p><img src="https://upload-images.jianshu.io/upload_images/3112838-0a897cf31cb9aa8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1103/format/webp" alt="img"></p>
<h5 id="singleTop-Intent-FLAG-ACTIVITY-CLEAR-TOP"><a href="#singleTop-Intent-FLAG-ACTIVITY-CLEAR-TOP" class="headerlink" title="singleTop + Intent.FLAG_ACTIVITY_CLEAR_TOP"></a>singleTop + Intent.FLAG_ACTIVITY_CLEAR_TOP</h5><p>现在设想一种场景，AActivitylanchMode为singleTop，在AActivity的基础上依次打开了BActivity、CActivity， 在CActivity再次打开AActivity，但打开时设置Intent属性<code>Intent.FLAG_ACTIVITY_CLEAR_TOP</code>,此时的启动流程：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3112838-7ba227bafbceb763.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/922/format/webp" alt="img"></p>
<h5 id="log"><a href="#log" class="headerlink" title="log"></a>log</h5><h6 id="原Activity不在栈顶-1"><a href="#原Activity不在栈顶-1" class="headerlink" title="原Activity不在栈顶"></a>原Activity不在栈顶</h6><p><img src="https://upload-images.jianshu.io/upload_images/3112838-6a5468b4fbb56192.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/961/format/webp" alt="img"></p>
<h6 id="原Activity在栈顶-1"><a href="#原Activity在栈顶-1" class="headerlink" title="原Activity在栈顶"></a>原Activity在栈顶</h6><p><img src="https://upload-images.jianshu.io/upload_images/3112838-09cafa3d81155741.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1022/format/webp" alt="img"></p>
<h6 id="原Actiivty在栈顶且设置Intent-FLAG-ACTIVITY-CLEAR-TOP"><a href="#原Actiivty在栈顶且设置Intent-FLAG-ACTIVITY-CLEAR-TOP" class="headerlink" title="原Actiivty在栈顶且设置Intent.FLAG_ACTIVITY_CLEAR_TOP"></a>原Actiivty在栈顶且设置Intent.FLAG_ACTIVITY_CLEAR_TOP</h6><p><img src="https://upload-images.jianshu.io/upload_images/3112838-78c410cfc373debf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/821/format/webp" alt="img"></p>
<h5 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h5><p>我们又要进入<code>ActivityStarter#startActivityUnchecked</code>方法了， startActivityUnchecked：你要对我负责555…</p>
<p>摘抄startActivityUnchecked方法中关于singleTop模式的处理如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要启动的Activity正好是当前在栈顶的Activity</span></span><br><span class="line"><span class="comment">// 当前聚焦的ActivityStack</span></span><br><span class="line"><span class="keyword">final</span> ActivityStack topStack = mSupervisor.mFocusedStack;</span><br><span class="line"><span class="comment">// 当前聚焦的ActivityStack中的栈顶Actiivty</span></span><br><span class="line"><span class="keyword">final</span> ActivityRecord topFocused = topStack.topActivity();</span><br><span class="line"><span class="comment">// 当前栈顶Activity</span></span><br><span class="line"><span class="keyword">final</span> ActivityRecord top = topStack.topRunningNonDelayedActivityLocked(mNotTop);</span><br><span class="line"><span class="keyword">final</span> boolean dontStart = top != <span class="literal">null</span> &amp;&amp; mStartActivity.resultTo == <span class="literal">null</span></span><br><span class="line">        &amp;&amp; top.realActivity.equals(mStartActivity.realActivity)</span><br><span class="line">        &amp;&amp; top.userId == mStartActivity.userId</span><br><span class="line">        &amp;&amp; top.app != <span class="literal">null</span> &amp;&amp; top.app.thread != <span class="literal">null</span></span><br><span class="line">        &amp;&amp; ((mLaunchFlags &amp; FLAG_ACTIVITY_SINGLE_TOP) != <span class="number">0</span></span><br><span class="line">        || mLaunchSingleTop || mLaunchSingleTask);</span><br><span class="line"><span class="comment">// dontStart为true说明可以直接复用栈顶Activity</span></span><br><span class="line"><span class="keyword">if</span> (dontStart) &#123;</span><br><span class="line">    <span class="comment">// For paranoia, make sure we have correctly resumed the top activity.</span></span><br><span class="line">    topStack.mLastPausedActivity = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">        mSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    ActivityOptions.abort(mOptions);</span><br><span class="line">    <span class="keyword">if</span> ((mStartFlags &amp; START_FLAG_ONLY_IF_NEEDED) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// We don&#x27;t need to start a new activity, and the client said not to do</span></span><br><span class="line">        <span class="comment">// anything if that is the case, so this is it!</span></span><br><span class="line">        <span class="keyword">return</span> START_RETURN_INTENT_TO_CALLER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// zhangyulong singleTop  sigleTask onNewIntent 执行</span></span><br><span class="line">    deliverNewIntent(top);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> START_DELIVERED_TO_TOP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，当我们设置目标Activity launchMode是singleTop时，判断条件用的是mLaunchSingleTop，而(mLaunchFlags &amp; FLAG_ACTIVITY_SINGLE_TOP是指启动时设置的Intent的Flag属性。这两种方式都能达到singleTop的效果。</p>
<h6 id="singleTop-Intent-FLAG-ACTIVITY-CLEAR-TOP-1"><a href="#singleTop-Intent-FLAG-ACTIVITY-CLEAR-TOP-1" class="headerlink" title="singleTop + Intent.FLAG_ACTIVITY_CLEAR_TOP"></a>singleTop + Intent.FLAG_ACTIVITY_CLEAR_TOP</h6><p>这部分的逻辑处理和standard时差不多，还是<code>performClearTaskLocked</code>方法，这个方法在3.1.2.2章节已经分析过了，这里摘抄部分逻辑如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActivityInfo.LAUNCH_MULTIPLE == standrad</span></span><br><span class="line"><span class="comment">// 如果新Activity的launchMode是standard,且launchFlag没有FLAG_ACTIVITY_SINGLE_TOP，则将之前task</span></span><br><span class="line"><span class="comment">// 内的activity也结束，以便建立新的</span></span><br><span class="line"><span class="keyword">if</span> (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE</span><br><span class="line">        &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_SINGLE_TOP) == <span class="number">0</span></span><br><span class="line">        &amp;&amp; !ActivityStarter.isDocumentLaunchesIntoExisting(launchFlags)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ret.finishing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mStack != <span class="literal">null</span>) &#123;</span><br><span class="line">            mStack.finishActivityLocked(</span><br><span class="line">                    ret, Activity.RESULT_CANCELED, <span class="literal">null</span>, <span class="string">&quot;clear-task-top&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回空，说明不执行onNewIntent</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们的launchMode是FLAG_ACTIVITY_SINGLE_TOP，条件不成立，不会销毁命中的原Activity,但原Actiivty上面的记录均已销户，此时它已经是栈顶Activity了，继续执行会执行到<code>startActivityUnchecked</code>方法中3.2.3章节部分，和上面的逻辑就一致了。</p>
<h4 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h4><p>singleTask: 栈内唯一，如果Activity设置了launchMode为singleTask，那么在整个ActivityStack中有且仅有一个实例存在。有些朋友看到它名字叫singleTask，就想当然的认为它是Task内唯一的，我们不要被它的名字骗了。需要注意的一点是，singleTask模式启动是默认clearTop的。</p>
<h5 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h5><h6 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h6><p>假设AActivity的launchMode为singleTask，AActivity后依次启动BActivity和CActivity, CActivity又启动了AActivity,<br> 那么这个过程经历的流程如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3112838-1fa789833f2166c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/901/format/webp" alt="img"></p>
<p>log:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3112838-a4fbd4f21483e22d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/896/format/webp" alt="img"></p>
<h6 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h6><p> 假设AActivity和BActivity都是Standard,CActivity为singleTask,CActiivty再次启动CActivity,这个过程的启动流程：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3112838-acca060d14e0b0c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/783/format/webp" alt="img"></p>
<p>log：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3112838-1260cfaa0a9d1eee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h6 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a>场景三</h6><p> 看完前面两种场景，肯定会有同学不服气，你不是说singleTask是栈内唯一么，这两种场景都是task内的处理啊，那不就应该是task内唯一么，你说栈内唯一拿出证据来啊！别着急，证据马上来。</p>
<p>现在假设AActivity是singleTask， BActivity是standard, BActivity打开CActivity时创建新的Task, 然后CActivity再次打开AActivity<br> 流程如下：<br> 1.AActivity在其自身所在task启动BActivity<br> 2.BActivity在启动CActivity时创建新的Task<br> 3.CActivity启动AActivity时将AActivity所在的Task移到顶部<br> 4.AActivity将BActivity清除并重新启动</p>
<p>流程图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3112838-fe78ffaab3dbbbb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1052/format/webp" alt="img"></p>
<p>看下log是不是这样：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3112838-fea64811c8bae7ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1162/format/webp" alt="img"></p>
<p>log也验证了这个说法的正确性，从这个案例中我们看出，虽然AB在一个task, C在另一个task，但C启动A的时候，并没有在其自身的task启动，而是操作AB所在的task。因此，singeTask是栈内唯一的。</p>
<h5 id="singeTask源码分析"><a href="#singeTask源码分析" class="headerlink" title="singeTask源码分析"></a>singeTask源码分析</h5><p>再进入一次<code>ActivityStarter#startActivityUnchecked</code>一次，此时<code>startActivityUnchecked</code>内心活动：别进了，再进就怀孕了！！</p>
<p>为什么说singleTask自带clearTop属性呢？ 看下<code>startActivityUnchecked</code>的这段逻辑：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果启动Intent设置了FLAG_ACTIVITY_CLEAR_TOP或者目标Activity启动模式为singleInstance或者singleTask，执行以下逻辑</span></span><br><span class="line"><span class="keyword">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_CLEAR_TOP) != <span class="number">0</span></span><br><span class="line">        || isDocumentLaunchesIntoExisting(mLaunchFlags)</span><br><span class="line">        || mLaunchSingleInstance || mLaunchSingleTask) &#123;</span><br><span class="line">    <span class="keyword">final</span> TaskRecord task = reusedActivity.getTask();</span><br><span class="line">    <span class="comment">// 将与新Actiivty在Task内相同的Activity的顶部元素清空</span></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord top = task.performClearTaskForReuseLocked(mStartActivity,</span><br><span class="line">            mLaunchFlags);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么task切换到栈顶是在哪里呢，这段逻辑执行完成后，就会执行到Task切换的逻辑了，代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将目标Activity所在Task移动到栈顶</span></span><br><span class="line">reusedActivity = <span class="built_in">setTargetStackAndMoveToFrontIfNeeded</span>(reusedActivity);</span><br></pre></td></tr></table></figure>

<p>当前面的逻辑完成后，可复用用的Activity就已经在Task顶部，而Task也已经在Stack顶部，完事俱备，只欠东风，继续执行<code>startActivityUnchecked</code>会执行到3.2.3的内容，和singleTop的处理是一致的，最终回调了目标Activity的onNewIntent。</p>
<h4 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h4><p>singleInstance这个启动模式比sigleTask更NB一些，它不光在栈内唯一，而且还独占一个Task，一看就是那种有独立办公室的老板，跟其他打工人完全不是一个等级的。关于singleInstance的栈管理和切换，你可以把它理解成只有一个singleTask的Activity存在的Task就比较好理解了，上面我们也已经分析过了。</p>
<h3 id="Intent-FLAG-ACTIVITY-NEW-TASK、taskAffinity、新Task的创建"><a href="#Intent-FLAG-ACTIVITY-NEW-TASK、taskAffinity、新Task的创建" class="headerlink" title="Intent.FLAG_ACTIVITY_NEW_TASK、taskAffinity、新Task的创建"></a>Intent.FLAG_ACTIVITY_NEW_TASK、taskAffinity、新Task的创建</h3><p>先看几个有意思的案例：<br> 现在有两个Activity，分别是AActivity和BActivity，我们先设置A和B均为standard，在A启动B时设置<code>Intent.FLAG_ACTIVITY_NEW_TASK</code>,跳转时Task会新建么？<br> 看一下log:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3112838-76e4c948605a09a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/767/format/webp" alt="img"></p>
<p> 从图上我们看到，A和B的TaskId都是305，也就是没有创建新的Task,怎么回事，Intent.FLAG_ACTIVITY_NEW_TASK怎么失效了？</p>
<p>这个时候把B的launchMode设置为singleTask呢？<br> 看一下log:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3112838-c27c170253ec3831.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1039/format/webp" alt="img"></p>
<p>依然没有生效！！</p>
<p>这个时候保持B的launchMode为singleTask, 设置B的taskAffinity为”.b”试一下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3112838-6c40dcb6ecf32be1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1032/format/webp" alt="img"></p>
<p>生效了！！</p>
<p>这个时候把Intent.FLAG_ACTIVITY_NEW_TASK取消，保持B的launchMode为singleTask, 设置B的taskAffinity为”.b”试一下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3112838-e0c3f1585d574b24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1061/format/webp" alt="img"></p>
<p>生效了！</p>
<p>这个时候把Intent.FLAG_ACTIVITY_NEW_TASK取消，修改B的launchMode为standard, 设置B的taskAffinity为”.b”试一下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3112838-bd3c6b843d72f901.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1025/format/webp" alt="img"></p>
<p>没生效！</p>
<p>这个时候把B的taskAffinity删掉，设置B为singleInstace试一下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3112838-88f51fe4a9a20a16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1034/format/webp" alt="img"></p>
<p>又生效了！！</p>
<p>看到这里是不是感觉已经晕了，那到底啥时候生效啥时候失效啊！别着急，看完源码我们再做总结</p>
<p>我们又要进入<code>ActivityStarter#startActivityUnchecked</code>方法了， startActivityUnchecked:不挣扎了，已经有你的形状了…</p>
<h4 id="Intent-FLAG-ACTIVITY-NEW-TASK的自动设置"><a href="#Intent-FLAG-ACTIVITY-NEW-TASK的自动设置" class="headerlink" title="Intent.FLAG_ACTIVITY_NEW_TASK的自动设置"></a>Intent.FLAG_ACTIVITY_NEW_TASK的自动设置</h4><p>startActivityUnchecked前面几行代码执行了一个叫做<code>computeLaunchingTaskFlags</code>的方法，这个方法的作用是根据新Activity的launchMode对launchFlag做处理：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">computeLaunchingTaskFlags</span>()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mInTask == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mSourceRecord == <span class="literal">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) &#123;</span><br><span class="line">            <span class="comment">// 如果源Activity是singleInstance，则新启动Activity时自动添加launchFlag FLAG_ACTIVITY_NEW_TASK</span></span><br><span class="line">            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mLaunchSingleInstance || mLaunchSingleTask) &#123;</span><br><span class="line">            <span class="comment">// 如果新Activity的launchMode是singleInstace或者singleTask，则新启动Activity时自动添加launchFlag FLAG_ACTIVITY_NEW_TASK</span></span><br><span class="line">            mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，如果一个Actiivty是singleInstacne的，那么不管是别人启动它还是它启动别人，都会自动添加启动flag FLAG_ACTIVITY_NEW_TASK, 如果是singeTask，则只有别人启动它时才会这样设置</p>
<h4 id="taskAffinity的识别"><a href="#taskAffinity的识别" class="headerlink" title="taskAffinity的识别"></a>taskAffinity的识别</h4><p>上一部分的逻辑执行后，<code>startActivityUnchecked</code>会执行<code>getReusableIntentActivity</code>方法，这个方法主要是寻找ActivityStack中是否有可复用的Task， 返回值会可复用Task的顶部元素:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ActivityRecord <span class="title function_">getReusableIntentActivity</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置了launchFlag为FLAG_ACTIVITY_NEW_TASK或者 launchMode为singleInstance或singleTask</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">putIntoExistingTask</span> <span class="operator">=</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (mLaunchFlags &amp; FLAG_ACTIVITY_MULTIPLE_TASK) == <span class="number">0</span>)</span><br><span class="line">            || mLaunchSingleInstance || mLaunchSingleTask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inTask为null 且requestCode小于0（即resultTo ==  null）</span></span><br><span class="line">    putIntoExistingTask &amp;= mInTask == <span class="literal">null</span> &amp;&amp; mStartActivity.resultTo == <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ActivityRecord</span> <span class="variable">intentActivity</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mOptions != <span class="literal">null</span> &amp;&amp; mOptions.getLaunchTaskId() != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TaskRecord</span> <span class="variable">task</span> <span class="operator">=</span> mSupervisor.anyTaskForIdLocked(mOptions.getLaunchTaskId());</span><br><span class="line">        intentActivity = task != <span class="literal">null</span> ? task.getTopActivity() : <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (putIntoExistingTask) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mLaunchSingleInstance) &#123;</span><br><span class="line">            <span class="comment">// 如果launchMode为singleInstance,只要当前状态下Stack中有和要启动的Activity相同的记录，就说明可以复用</span></span><br><span class="line">           intentActivity = mSupervisor.findActivityLocked(mIntent, mStartActivity.info,</span><br><span class="line">                   mStartActivity.isHomeActivity());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_LAUNCH_ADJACENT) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 没研究</span></span><br><span class="line">            intentActivity = mSupervisor.findActivityLocked(mIntent, mStartActivity.info,</span><br><span class="line">                    !mLaunchSingleTask);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 其他情况查找Stack中是否有适用的Task和可复用的Actiivty</span></span><br><span class="line">            intentActivity = mSupervisor.findTaskLocked(mStartActivity, mSourceDisplayId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intentActivity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>findActivityLocked</code>逻辑比较简单，就是在整个Stack中遍历Activity作对比，重点看<code>ActivitySuperVisor#findTaskLocked</code>,<code>ActivitySuperVisor#findTaskLocked</code>中调用了<code>ActivityStack#findTaskLocked</code>，看一下重要逻辑：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findTaskLocked</span>(<span class="params">ActivityRecord target, FindTaskResult result</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isDocument &amp;&amp; !taskIsDocument</span><br><span class="line">                &amp;&amp; result.r == <span class="literal">null</span> &amp;&amp; task.rootAffinity != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果Task的rootAffinity和新Activity的taskAffinity匹配，则说明有可复用的栈</span></span><br><span class="line">            <span class="comment">// ，task的rootAffinity一般由底部Actiivty决定，不特意设置的话,一般使用包名</span></span><br><span class="line">            <span class="keyword">if</span> (task.rootAffinity.<span class="keyword">equals</span>(target.taskAffinity)) &#123;</span><br><span class="line">                result.r = r;</span><br><span class="line">                result.matchedByRootAffinity = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG_TASKS, <span class="string">&quot;Not a match: &quot;</span> + task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是匹配taskAffinity的地方。回到<code>getReusableIntentActivity</code>方法，说一下它的返回值逻辑：</p>
<ul>
<li>如果launchMode是singleInstance，则判断当前stack中是否有相同Actiivty，如果有则返回对应Actiivty，否则是null</li>
<li>如果launchMode是其他，则判断当前stack中是否有可以匹配其affinity的Task，如果有则返回对应Task顶部Activity，否则是null</li>
</ul>
<h4 id="是否创建新task的识别"><a href="#是否创建新task的识别" class="headerlink" title="是否创建新task的识别"></a>是否创建新task的识别</h4><p>如果<code>getReusableIntentActivity</code>方法返回值不为null，<code>startActivityUncheck</code>后面的逻辑会执行<code>setTaskFromReuseOrCreateNewTask</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setTaskFromIntentActivity</span><span class="params">(ActivityRecord intentActivity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((mLaunchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))</span><br><span class="line">            == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TaskRecord</span> <span class="variable">task</span> <span class="operator">=</span> intentActivity.getTask();</span><br><span class="line">        task.performClearTaskLocked();</span><br><span class="line">        <span class="comment">// 设置启动新Actiivty时所使用的task</span></span><br><span class="line">        mReuseTask = task;</span><br><span class="line">        mReuseTask.setIntent(mStartActivity);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这个方法执行的必要条件是<code>getReusableIntentActivity</code>方法返回值不为null，入参intentActivity即是<code>getReusableIntentActivity</code>方法的返回值。<br> 因此，假如mReuseTask 为null，则启动Actiivty时会创建新的task，否则向mReuseTask 中添加，逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">setTaskFromReuseOrCreateNewTask</span><span class="params">(</span></span><br><span class="line"><span class="params">        TaskRecord taskToAffiliate, <span class="type">int</span> preferredLaunchStackId, ActivityStack topStack)</span> &#123;</span><br><span class="line">    mTargetStack = computeStackFocus(</span><br><span class="line">            mStartActivity, <span class="literal">true</span>, mLaunchBounds, mLaunchFlags, mOptions);</span><br><span class="line">    <span class="keyword">if</span> (mReuseTask == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建新的Task</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">TaskRecord</span> <span class="variable">task</span> <span class="operator">=</span> mTargetStack.createTaskRecord(</span><br><span class="line">                mSupervisor.getNextTaskIdForUserLocked(mStartActivity.userId),</span><br><span class="line">                mNewTaskInfo != <span class="literal">null</span> ? mNewTaskInfo : mStartActivity.info,</span><br><span class="line">                mNewTaskIntent != <span class="literal">null</span> ? mNewTaskIntent : mIntent, mVoiceSession,</span><br><span class="line">                mVoiceInteractor, !mLaunchTaskBehind <span class="comment">/* toTop */</span>, mStartActivity.mActivityType);</span><br><span class="line">        <span class="comment">// 向新Task中添加</span></span><br><span class="line">        addOrReparentStartingActivity(task, <span class="string">&quot;setTaskFromReuseOrCreateNewTask - mReuseTask&quot;</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 向旧task中添加</span></span><br><span class="line">        addOrReparentStartingActivity(mReuseTask, <span class="string">&quot;setTaskFromReuseOrCreateNewTask&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>通过上面的代码分析，我们可以总结出在Activity启动过程中创建新Task的条件：</p>
<ol>
<li>standard、singleTop模式   Intent.FLAG_ACTIVITY_NEW_TASK 和taskAffinity必须同时设置</li>
<li>sinlgeTask模式   只需设置taskAffinity，Intent.FLAG_ACTIVITY_NEW_TASK 可有可无</li>
<li>singeInstance Intent.FLAG_ACTIVITY_NEW_TASK 和taskAffinity均可有可无</li>
</ol>
<h1 id="PMS"><a href="#PMS" class="headerlink" title="PMS"></a>PMS</h1><h2 id="深入PMS源码（一）——-PMS的启动过程和执行流程"><a href="#深入PMS源码（一）——-PMS的启动过程和执行流程" class="headerlink" title="深入PMS源码（一）—— PMS的启动过程和执行流程"></a>深入PMS源码（一）—— PMS的启动过程和执行流程</h2><h3 id="PMS简介"><a href="#PMS简介" class="headerlink" title="PMS简介"></a>PMS简介</h3><p>作为Android开发者，或多或少的都接触过Android的framework层架构，这也是开发者从使用Android到了解安卓的过程，framework层的核心功能有AMS、PMS、WMS等，这三个也是系统中最基础的使用，在Android程序启动完成后回启动一系列的核心服务，AMS、PMS、WMS就是在此过程中启动的，之后的系列文章之后会一次介绍他们，本篇主要介绍PMS关于PMS文章共分为3篇，本篇最为首篇也是PMS的主要逻辑部分；</p>
<ul>
<li>PMS主要功能</li>
</ul>
<ol>
<li>管理设备上安装的所有应用程序，并在系统启动时加载应用程序；</li>
<li>根据请求的Intent匹配到对应的Activity、Provider、Service，提供包含包名和Component的信息对象；</li>
<li>调用需要权限的系统函数时，检查程序是否具备相应权限从而保证系统安全；</li>
<li>提供应用程序的安装、卸载的接口；</li>
</ol>
<ul>
<li>PMS包管理</li>
</ul>
<ol>
<li>应用程序层：使用getPackageManager（）获取包的管理对象PackageManager，PMS使用的也是Binder通信，PackageManager是从ServiceManager中获取注册的Binder对象，具体的实现为PackageManagerService，PMS实现对所有程序的安装和加载；</li>
<li>PMS服务层：PMS运行在SystemServer进程中，主要使用&#x2F;system&#x2F;etc&#x2F;permissions.xml和&#x2F;data&#x2F;system&#x2F;packages.xml管理包信息；</li>
<li>数据文件管理：PMS负责对系统的配置文件、apk安装文件、apk的数据文件执行管理、读写、创建和删除等功能；<br>（1）程序文件：所有系统程序的文件处于&#x2F;system&#x2F;app&#x2F;目录下，第三方程序文件处于&#x2F;data&#x2F;app&#x2F;目录下，在程序安装过程中PMS会将要安装的apk文件复制到&#x2F;data&#x2F;app&#x2F;目录下，以包名命名apk文件并添加“-x”后缀，在文件更新时会修改后缀编号；<br>（2）&#x2F;data&#x2F;dalvik-cache&#x2F; 目录保存了程序中的执行代码，在应用程序运行前PMS会从apk中提取dex文件并保存在该目录下，以便之后能快速运行；<br>（3）对framework库文件，PMS会将其中所有的apk、jar文件中提取dex文件，将dex文件保存在&#x2F;data&#x2F;dalvik-cache&#x2F;目录下；<br>（4）应用程序所使用的数据文件：数据以键值对保存、数据库保存、File保存所产生的文件都保存带&#x2F;data&#x2F;data&#x2F;xxx&#x2F;目录下，PMS在程序卸载会删除相应文件；</li>
</ol>
<ul>
<li>&#x2F;data&#x2F;system&#x2F;packages.xml ：系统的配置文件，记录所有的应用程序的包管理信息，PMS根据此文件管理所有程序</li>
</ul>
<ol>
<li>last-platform-version：记录系统最后一次修改的版本信息；</li>
<li>permissions：保存系统中所有的权限信息列表，系统权限以androd开头、自定义权限以包名开头；</li>
<li>sigs：签名标签，一个程序只能有一个签名但可以有多个证书，包含count属性表示证书数量；</li>
<li>cert：表示签名证书，包含index、key属性，index表示证书的下标；</li>
<li>perms：表示一个程序中声明使用的权限列表，存在package标签之下；</li>
<li>package：包含一个应用程序的对应关系：<br>（1）name：应用程序的包名<br>（2）codePath：程序apk文件所在的路径<br>（3）nativeLibraryPath：程序中使用的native文件路径，一般指程序包下的lib文件中导入的依赖<br>（4）flags：表示应用程序的类型<br>（5）it、ut：分别表示程序首次安装的install time、更新时间update time<br>（6）userId：表示应用程序在Linux下的用户id<br>（7）shareId：表示应用程序所共享的Linux用户Id，与userId互斥<br>（8）installer：安装器的名称，在调用PackageManager.installPackage()方法时设置的名称</li>
</ol>
<h3 id="PMS的启动过程"><a href="#PMS的启动过程" class="headerlink" title="PMS的启动过程"></a>PMS的启动过程</h3><p>在Android系统启动过程中，程序会执行到SystemServer中，然后调用startBootstrapServices()方法启动核心服务，在startBootstrapServices（）方法中完成PMS的启动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startBootstrapServices</span><span class="params">()</span> &#123;</span><br><span class="line">       mPackageManagerService = PackageManagerService.main(mSystemContext, installer,mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); <span class="comment">// 1、调用main（）创建PMS对象，注册Binder</span></span><br><span class="line">    </span><br><span class="line">mPackageManager = mSystemContext.getPackageManager(); <span class="comment">//2、初始化PackageManager对象</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>调用PackageManagerService.main()方法，在main（）方法中创建PMS的对象，并向ServiceManager注册Binder</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> PackageManagerService <span class="title function_">main</span><span class="params">(Context context, Installer installer, <span class="type">boolean</span> factoryTest, <span class="type">boolean</span> onlyCore)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、创建PMS对象</span></span><br><span class="line">        <span class="type">PackageManagerService</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageManagerService</span>(context, installer,factoryTest, onlyCore);</span><br><span class="line">        m.enableSystemUserPackages();</span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;package&quot;</span>, m); <span class="comment">// 2、注册PMS对象到ServiceManager中</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">PackageManagerNative</span> <span class="variable">pmn</span> <span class="operator">=</span> m.<span class="keyword">new</span> <span class="title class_">PackageManagerNative</span>(); <span class="comment">// 3、 创建PMN对象</span></span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;package_native&quot;</span>, pmn); <span class="comment">// 4、注册PMN对象</span></span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>调用ContextImpl.getPackageManager（）获取PackageManager对象，getPackageManager（）中使用ActivityThread.getPackageManager()获取前面创建并注册的Binder对象，然后创建ApplicationPackageManager实例</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PackageManager <span class="title function_">getPackageManager</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">IPackageManager</span> <span class="variable">pm</span> <span class="operator">=</span> ActivityThread.getPackageManager(); <span class="comment">// 3、初始化PackageManagerService的代理Binder对象</span></span><br><span class="line">     <span class="keyword">if</span> (pm != <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> (mPackageManager = <span class="keyword">new</span> <span class="title class_">ApplicationPackageManager</span>(<span class="built_in">this</span>, pm)); <span class="comment">//创建Packagemanager的实例</span></span><br><span class="line">     &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>程序在获取PMS对象时会调用ActivityThread.getPackageManager()，从ServiceManager中获取Binder，并获取BInder代理对象PMS实例</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IPackageManager <span class="title function_">getPackageManager</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sPackageManager != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sPackageManager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">IBinder</span> <span class="variable">b</span> <span class="operator">=</span> ServiceManager.getService(<span class="string">&quot;package”);  // 获取注册Binder</span></span><br><span class="line"><span class="string">    sPackageManager = IPackageManager.Stub.asInterface(b); // 获取IPackageManager代理对象，即PMS</span></span><br><span class="line"><span class="string">    return sPackageManager;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>从上面的3个过程可以得出以下结论：</p>
<ol>
<li>PMS使用Binder通信机制，最终IPackageManager接口的实现类为PackageManagerService类；</li>
<li>系统中获取的PackageManager对象具体实现的子类是ApplicationPackageManager对象；</li>
</ol>
<h3 id="PMS构造函数"><a href="#PMS构造函数" class="headerlink" title="PMS构造函数"></a>PMS构造函数</h3><p>由上面的分析知道，在系统启动后程序执行PMS的构造函数创建对象，整个系统对程序的管理就从这里开始，先介绍下相关类和属性信息：</p>
<ul>
<li>PMS中属性</li>
</ul>
<ol>
<li>ArrayMap&lt;String, PackageParser.Package&gt; mPackages：在扫描程序文件目录时会将信息保存在Package对象中，然后将所有程序包名极其的package保存在此集合中；</li>
<li>Settings mSettings：保存整个系统信息的Setting对象；</li>
<li>ActivityIntentResolver mActivities：遍历所有程序的目录，并解析所有的注册清单文件，将提取所有的Intent-filter数据保存在对应的集合中；</li>
<li>ActivityIntentResolver mReceivers：同上</li>
<li>ServiceIntentResolver mServices：同上</li>
<li>ProviderIntentResolver mProviders：同上</li>
</ol>
<ul>
<li>PackageParser：解析apk文件的主要类，执行解析操作；</li>
<li>PackageParser.Package：PackageParser的内部类，保存apk文件中的解析信息，每个应用程序对应一个Package对象，属性信息如下：</li>
</ul>
<ol>
<li>String packageName：程序包名</li>
<li>String codePath： 软件包的路径</li>
<li>ApplicationInfo applicationInfo ：applicationInfo对象</li>
<li>final ArrayList permissions：申请权限的集合</li>
<li>final ArrayList activities：Activity标签解析的结合</li>
<li>final ArrayList receivers：Receiver标签解析的结合</li>
<li>final ArrayList providers ：Provider标签解析的结合</li>
<li>final ArrayList services ：Service标签解析的结合</li>
<li>Bundle mAppMetaData &#x3D; null：注册清单中设置的信息</li>
<li>int mVersionCode：版本Code</li>
<li>String mVersionName：版本名称</li>
<li>int mCompileSdkVersion：Sdk版本</li>
</ol>
<ul>
<li>Settings：PMS内部主要保存信息的类，主要属性如下：</li>
</ul>
<ol>
<li>mSettingsFilename：配置系统目录下的package.xml文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mSystemDir = <span class="keyword">new</span> <span class="title class_">File</span>(dataDir, <span class="string">&quot;system&quot;</span>); <span class="comment">// </span></span><br><span class="line">mSettingsFilename = <span class="keyword">new</span> <span class="title class_">File</span>(mSystemDir, <span class="string">&quot;packages.xml&quot;</span>); <span class="comment">//获取系统目录下package.xml文件</span></span><br></pre></td></tr></table></figure>

<ol>
<li>mBackupSettingsFilename：配置系统目录下的packages-backup.xml文件，一般在创建和修改package文件前，会先创建packages-backup保存原来信息，在操作读写后会删除此文件；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mBackupSettingsFilename = <span class="keyword">new</span> <span class="title class_">File</span>(mSystemDir, <span class="string">&quot;packages-backup.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li>mPackageListFilename：配置系统目录下的packages.list文件，保存了所有应用程序列表，每一行对应一个应用程序</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mPackageListFilename = <span class="keyword">new</span> <span class="title class_">File</span>(mSystemDir, <span class="string">&quot;packages.list”);</span></span><br><span class="line"><span class="string">如：com.android.hai 10032 1 data/data/com.android.hai ，第一项：应用程序包名、第二项：Linux用户Id、第三项：1表示可以debug，0表示不能debug、第四项：程序数据文件目录</span></span><br></pre></td></tr></table></figure>

<ol>
<li>ArrayMap&lt;String, PackageSetting&gt; mPackages：解析package.xml文件中的每个程序信息保存在PackageSetting对象中，将所有程序的PackageSetting都填充到集合中</li>
<li>mDisabledSysPackages：保存那些没有经过正常程序卸载的应用程序列表，按照正常卸载程序时，PMS会自动删除package.xml文件中的信息，使用adb命令或其他方法删除时package文件信息则不会删除，系统启动时PMS会检查package文件，并检查对应的应用程序的文件目录，从而判断是否意外删除，如果意外删除则加入mDisabledSysPackages集合；</li>
<li>mUserIds：保存Linux下所有的用户Id列表</li>
<li>mPendingPackages：在解析每个PackageSetting时如果是使用sharedId，则将此Setting加入此集合，等相应的share-user标签后再补充Setting</li>
<li>mPastSignatures：保存所有的签名文件信息</li>
<li>mPermissions：保存所有的权限信息</li>
<li>ArraySet mInstallerPackages：已安装的应用软件包</li>
</ol>
<h4 id="PMS的工作过程"><a href="#PMS的工作过程" class="headerlink" title="PMS的工作过程"></a>PMS的工作过程</h4><ul>
<li>构造函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PackageManagerService</span><span class="params">(Context context, Installer installer, // PMS的构造函数</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> factoryTest, <span class="type">boolean</span> onlyCore)</span> &#123;</span><br><span class="line">sUserManager = <span class="keyword">new</span> <span class="title class_">UserManagerService</span>(context, <span class="built_in">this</span>, <span class="comment">// 创建UserManagerService</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">UserDataPreparer</span>(mInstaller, mInstallLock, mContext, mOnlyCore), mPackages);</span><br><span class="line">mSettings = <span class="keyword">new</span> <span class="title class_">Settings</span>(mPermissionManager.getPermissionSettings(), mPackages); <span class="comment">//1、创建保存系统信息的Settings对象</span></span><br><span class="line"></span><br><span class="line">mHandlerThread = <span class="keyword">new</span> <span class="title class_">ServiceThread</span>(TAG,Process.THREAD_PRIORITY_BACKGROUND, <span class="literal">true</span> );</span><br><span class="line">mHandlerThread.start();</span><br><span class="line">mHandler = <span class="keyword">new</span> <span class="title class_">PackageHandler</span>(mHandlerThread.getLooper()); <span class="comment">// 2、使用HandlerThread初始化PackageHandler对象</span></span><br><span class="line"></span><br><span class="line">mFirstBoot = !mSettings.readLPw(sUserManager.getUsers(<span class="literal">false</span>)); <span class="comment">// 3、调用readLPw（）读取并解析配置package.xml</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">packageSettingCount</span> <span class="operator">=</span> mSettings.mPackages.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> packageSettingCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="type">PackageSetting</span> <span class="variable">ps</span> <span class="operator">=</span> mSettings.mPackages.valueAt(i); <span class="comment">// 4、遍历所有的程序的packageSettings对象</span></span><br><span class="line">    <span class="keyword">if</span> (!isExternal(ps) &amp;&amp; (ps.codePath == <span class="literal">null</span> || !ps.codePath.exists())</span><br><span class="line">            &amp;&amp; mSettings.getDisabledSystemPkgLPr(ps.name) != <span class="literal">null</span>) &#123; <span class="comment">// 判断文件已经被删除的或程序已被卸载</span></span><br><span class="line">        mSettings.mPackages.removeAt(i); <span class="comment">// 移除对应的PackageSettings对象</span></span><br><span class="line">        mSettings.enableSystemPackageLPw(ps.name); <span class="comment">// 从mDisabledSysPackages集合中也移除此程序的Settings对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">File</span> <span class="variable">frameworkDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(Environment.getRootDirectory(), <span class="string">&quot;framework”); // 5、获取系统的framework文件</span></span><br><span class="line"><span class="string">Iterator&lt;PackageSetting&gt; pkgSettingIter = mSettings.mPackages.values().iterator();</span></span><br><span class="line"><span class="string">while (pkgSettingIter.hasNext()) &#123;</span></span><br><span class="line"><span class="string">    PackageSetting ps = pkgSettingIter.next();</span></span><br><span class="line"><span class="string">    if (isSystemApp(ps)) &#123; // 6、保存已经安装的系统的应用程序</span></span><br><span class="line"><span class="string">        mExistingSystemPackages.add(ps.name);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">scanDirTracedLI(frameworkDir, // 7、扫描framework文件目录</span></span><br><span class="line"><span class="string">        mDefParseFlags</span></span><br><span class="line"><span class="string">        | PackageParser.PARSE_IS_SYSTEM_DIR,</span></span><br><span class="line"><span class="string">        scanFlags</span></span><br><span class="line"><span class="string">        | SCAN_NO_DEX</span></span><br><span class="line"><span class="string">        | SCAN_AS_SYSTEM</span></span><br><span class="line"><span class="string">        | SCAN_AS_PRIVILEGED,</span></span><br><span class="line"><span class="string">        0);</span></span><br><span class="line"><span class="string">final File systemAppDir = new File(Environment.getRootDirectory(), &quot;</span>app<span class="string">&quot;);</span></span><br><span class="line"><span class="string">scanDirTracedLI(systemAppDir, // 8、扫描系统app文件</span></span><br><span class="line"><span class="string">        mDefParseFlags</span></span><br><span class="line"><span class="string">        | PackageParser.PARSE_IS_SYSTEM_DIR,</span></span><br><span class="line"><span class="string">        scanFlags</span></span><br><span class="line"><span class="string">        | SCAN_AS_SYSTEM,</span></span><br><span class="line"><span class="string">        0);</span></span><br><span class="line"><span class="string">。。。。。。扫描各种目录下的文件信息</span></span><br><span class="line"><span class="string">scanDirTracedLI(sAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0); //9、扫描安装app目录/data/app/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mSettings.writeLPr(); // 10、写入配置文件</span></span><br><span class="line"><span class="string">Runtime.getRuntime().gc();</span></span><br></pre></td></tr></table></figure>

<p>在启动程序后，PMS的所有工作基本都在构造函数中执行的，具体的执行过程见上面代码注释，这里列出几点主要的执行步骤：</p>
<ol>
<li>创建Settings对象，将PMS中的mPackage集合传入，此集合保存所有apk的解析数据</li>
<li>调用readLPw（）方法解析系统配置文件package.xml</li>
<li>调用scanDirTracedLI（）扫描系统app</li>
<li>调用scanDirTracedLI（）扫描&#x2F;data&#x2F;app&#x2F;下安装的第三方啊app</li>
<li>执行mSettings.writeLPr()将扫描后的结果，重新写入配置文件</li>
</ol>
<p>上面的几个主要过程即可实现PMS对所有安装程序的执行和管理，下面从源码的角度分析下PMS具体的执行细节；</p>
<h4 id="解析配置文件package-xml"><a href="#解析配置文件package-xml" class="headerlink" title="解析配置文件package.xml"></a>解析配置文件package.xml</h4><ul>
<li>readLPw()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">boolean</span> <span class="title function_">readLPw</span><span class="params">(<span class="meta">@NonNull</span> List&lt;UserInfo&gt; users)</span> &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">        <span class="keyword">if</span> (mBackupSettingsFilename.exists()) &#123; <span class="comment">// 1、如果package-backUp.xml 文件存在，读取package-back.xml文件</span></span><br><span class="line">                str = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(mBackupSettingsFilename); <span class="comment">// 一般当写入配置时发生意外才会存在此文件</span></span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">str = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(mSettingsFilename); <span class="comment">// 2、正常情况下读取package.xml文件信息</span></span><br><span class="line"><span class="type">XmlPullParser</span> <span class="variable">parser</span> <span class="operator">=</span> Xml.newPullParser(); <span class="comment">// 3、使用PullParser解析xml文件</span></span><br><span class="line">parser.setInput(str, StandardCharsets.UTF_8.name());</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">        &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; <span class="comment">// 4、循环读取xml的节点数据</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">tagName</span> <span class="operator">=</span> parser.getName(); <span class="comment">// 读取每个标签名称</span></span><br><span class="line"><span class="number">3044</span>                <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;package&quot;</span>)) &#123;</span><br><span class="line"><span class="number">3045</span>                    readPackageLPw(parser);  <span class="comment">// 解析package标签中信息保存在PackageSetting对象中</span></span><br><span class="line"><span class="number">3046</span>                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;permissions&quot;</span>)) &#123;</span><br><span class="line"><span class="number">3047</span>                    mPermissions.readPermissions(parser);  <span class="comment">// 解析系统所有的权限信息，保存在PermissionSettings中</span></span><br><span class="line"><span class="number">3048</span>                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;shared-user&quot;</span>)) &#123;</span><br><span class="line"><span class="number">3051</span>                    readSharedUserLPw(parser); <span class="comment">// 如果使用share-user，解析此标签</span></span><br><span class="line">                    &#125;</span><br><span class="line"> <span class="comment">// 在解析package标签时，如果程序使用的shareUserId，则将此setting对象加入此集合，等相应共享的程序加载完成后再完善信息</span></span><br><span class="line"> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> mPendingPackages.size();</span><br><span class="line"><span class="number">3172</span>        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123; <span class="comment">//  5、遍历mPendingPackage集合中的PackageSetting对象，逐步完善每个对象</span></span><br><span class="line"><span class="number">3173</span>            <span class="keyword">final</span> <span class="type">PackageSetting</span> <span class="variable">p</span> <span class="operator">=</span> mPendingPackages.get(i);</span><br><span class="line"><span class="number">3174</span>            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">sharedUserId</span> <span class="operator">=</span> p.getSharedUserId();</span><br><span class="line"><span class="number">3175</span>            <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">idObj</span> <span class="operator">=</span> getUserIdLPr(sharedUserId); <span class="comment">// 获取次shareUserId对应的程序</span></span><br><span class="line"><span class="number">3176</span>            <span class="keyword">if</span> (idObj <span class="keyword">instanceof</span> SharedUserSetting) &#123;</span><br><span class="line"><span class="number">3177</span>                <span class="keyword">final</span> <span class="type">SharedUserSetting</span> <span class="variable">sharedUser</span> <span class="operator">=</span> (SharedUserSetting) idObj;</span><br><span class="line"><span class="number">3178</span>                p.sharedUser = sharedUser; <span class="comment">// 完善p的信息</span></span><br><span class="line"><span class="number">3179</span>                p.appId = sharedUser.userId;</span><br><span class="line"><span class="number">3180</span>                addPackageSettingLPw(p, sharedUser);  </span><br><span class="line"><span class="number">3181</span>            &#125;</span><br><span class="line"><span class="number">3192</span>        &#125;</span><br><span class="line"><span class="number">3193</span>        mPendingPackages.clear(); <span class="comment">// 清除集合</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件在readLPw（）中首先判断mBackupSettingsFilename文件是否存在，前面提到当更新配置文件时，系统会先将package.xml文件重名为backup文件，然后创建package.xml并将mSettings内容写入文件，写入完成之后将back-up为难删除，如果此过程发生意外则系统会保留back-up文件，再此重启PMS时会优先读取backup文件，一般情况会直接读取package.xml，读取信息后使用Xml解析文件中信息，在解析中提取每个标签中的属性，这里需要注意的是package 标签，其中包好应用程序的基本信息，程序回调用readPackageLPw（）解析；</p>
<ul>
<li>readPackageLPw（）：解析并获取package标签下的信息，并创建PackageSetting对象保存信息；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readPackageLPw</span><span class="params">(XmlPullParser parser)</span> <span class="keyword">throws</span> XmlPullParserException, IOException &#123;</span><br><span class="line">name = parser.getAttributeValue(<span class="literal">null</span>, ATTR_NAME); <span class="comment">// 1、提前标签下的属性信息，保存在相应的变量中</span></span><br><span class="line">realName = parser.getAttributeValue(<span class="literal">null</span>, <span class="string">&quot;realName&quot;</span>);</span><br><span class="line">idStr = parser.getAttributeValue(<span class="literal">null</span>, <span class="string">&quot;userId&quot;</span>);</span><br><span class="line">uidError = parser.getAttributeValue(<span class="literal">null</span>, <span class="string">&quot;uidError&quot;</span>);</span><br><span class="line">sharedIdStr = parser.getAttributeValue(<span class="literal">null</span>, <span class="string">&quot;sharedUserId&quot;</span>);</span><br><span class="line">codePathStr = parser.getAttributeValue(<span class="literal">null</span>, <span class="string">&quot;codePath&quot;</span>);</span><br><span class="line">.......</span><br><span class="line">version = parser.getAttributeValue(<span class="literal">null</span>, <span class="string">&quot;version&quot;</span>);</span><br><span class="line">timeStampStr = parser.getAttributeValue(<span class="literal">null</span>, <span class="string">&quot;it&quot;</span>);</span><br><span class="line">timeStampStr = parser.getAttributeValue(<span class="literal">null</span>, <span class="string">&quot;ut&quot;</span>);</span><br><span class="line"><span class="comment">//2、创建PackageSetting对象保存从package标签解析出的信息，并保存在集合中mPackages集合中</span></span><br><span class="line">packageSetting = addPackageLPw(name.intern(), realName, <span class="keyword">new</span> <span class="title class_">File</span>(codePathStr), </span><br><span class="line"><span class="number">3836</span>                        <span class="keyword">new</span> <span class="title class_">File</span>(resourcePathStr), legacyNativeLibraryPathStr, primaryCpuAbiString,</span><br><span class="line"><span class="number">3837</span>                        secondaryCpuAbiString, cpuAbiOverrideString, userId, versionCode, pkgFlags,</span><br><span class="line"><span class="number">3838</span>                        pkgPrivateFlags, parentPackageName, <span class="literal">null</span> <span class="comment">/*childPackageNames*/</span>,</span><br><span class="line"><span class="number">3839</span>                        <span class="literal">null</span> <span class="comment">/*usesStaticLibraries*/</span>, <span class="literal">null</span> <span class="comment">/*usesStaticLibraryVersions*/</span>);</span><br><span class="line">packageSetting.setTimeStamp(timeStamp);</span><br><span class="line">packageSetting.firstInstallTime = firstInstallTime;</span><br><span class="line">packageSetting.lastUpdateTime = lastUpdateTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sharedIdStr != <span class="literal">null</span>) &#123;<span class="comment">//3、如果使用sharedId，则创建packageSetting对象保存在mPending集合中，稍后补充解析信息</span></span><br><span class="line"><span class="number">3853</span>                <span class="keyword">if</span> (sharedUserId &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">3854</span>                    packageSetting = <span class="keyword">new</span> <span class="title class_">PackageSetting</span>(name.intern(), realName, <span class="keyword">new</span> <span class="title class_">File</span>(</span><br><span class="line"><span class="number">3855</span>                            codePathStr), <span class="keyword">new</span> <span class="title class_">File</span>(resourcePathStr), legacyNativeLibraryPathStr,</span><br><span class="line"><span class="number">3856</span>                            primaryCpuAbiString, secondaryCpuAbiString, cpuAbiOverrideString,</span><br><span class="line"><span class="number">3857</span>                            versionCode, pkgFlags, pkgPrivateFlags, parentPackageName,</span><br><span class="line"><span class="number">3858</span>                            <span class="literal">null</span> <span class="comment">/*childPackageNames*/</span>, sharedUserId,</span><br><span class="line"><span class="number">3859</span>                            <span class="literal">null</span> <span class="comment">/*usesStaticLibraries*/</span>, <span class="literal">null</span> <span class="comment">/*usesStaticLibraryVersions*/</span>);</span><br><span class="line"><span class="number">3860</span>                    packageSetting.setTimeStamp(timeStamp);</span><br><span class="line"><span class="number">3861</span>                    packageSetting.firstInstallTime = firstInstallTime;</span><br><span class="line"><span class="number">3862</span>                    packageSetting.lastUpdateTime = lastUpdateTime;</span><br><span class="line"><span class="number">3863</span>                    mPendingPackages.add(packageSetting); <span class="comment">// 4、将packageSetting保存在mPendingPackages集合中</span></span><br><span class="line"><span class="number">3873</span>            &#125;</span><br><span class="line"><span class="keyword">if</span> (installerPackageName != <span class="literal">null</span>) &#123;</span><br><span class="line">    mInstallerPackages.add(installerPackageName); <span class="comment">// 添加到已安装程序列表集合中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在readPackageLPw（）中首先从解析器parser中提取所有的标签信息，然后调用addPackageLPw（）方法保存这些属性，最后当程序使用shareId时先暂时将对象的解析 添加到mPendingPackages集合中，等共享的应用执行结束后再补充信息；</p>
<ul>
<li>addPackageLPw（）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PackageSetting <span class="title function_">addPackageLPw</span><span class="params">(String name,......)</span> &#123;</span><br><span class="line"><span class="number">598</span>        <span class="type">PackageSetting</span> <span class="variable">p</span> <span class="operator">=</span> mPackages.get(name); <span class="comment">//从集合中取出对象</span></span><br><span class="line"><span class="number">599</span>        <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="number">600</span>            <span class="keyword">if</span> (p.appId == uid) &#123;</span><br><span class="line"><span class="number">601</span>                <span class="keyword">return</span> p;</span><br><span class="line"><span class="number">602</span>            &#125;</span><br><span class="line"><span class="number">606</span>        &#125;</span><br><span class="line"><span class="number">607</span>    p = <span class="keyword">new</span> <span class="title class_">PackageSetting</span>(name, realName, codePath, resourcePath, <span class="comment">// 创建PackageSetting对象</span></span><br><span class="line"><span class="number">608</span>                legacyNativeLibraryPathString, primaryCpuAbiString, secondaryCpuAbiString,</span><br><span class="line"><span class="number">609</span>                cpuAbiOverrideString, vc, pkgFlags, pkgPrivateFlags, parentPackageName,</span><br><span class="line"><span class="number">610</span>                childPackageNames, <span class="number">0</span> <span class="comment">/*userId*/</span>, usesStaticLibraries, usesStaticLibraryNames);</span><br><span class="line"><span class="number">611</span>        p.appId = uid;</span><br><span class="line"><span class="number">612</span>        <span class="keyword">if</span> (addUserIdLPw(uid, p, name)) &#123;</span><br><span class="line"><span class="number">613</span>            mPackages.put(name, p); <span class="comment">// 在mpackages中添加保存对象</span></span><br><span class="line"><span class="number">614</span>            <span class="keyword">return</span> p;</span><br><span class="line"><span class="number">615</span>        &#125;</span><br><span class="line"><span class="number">616</span>        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"><span class="number">617</span>    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addPackageLPw（）中直接创建PackageSetting对象，将解析的信息封装起来，然后以程序的name为Key将PackageSetting对象添加的mPackages集合中，那此时mPackages就保存了手机中所有app的应用信息；</p>
<h4 id="扫描安装的应用程序"><a href="#扫描安装的应用程序" class="headerlink" title="扫描安装的应用程序"></a>扫描安装的应用程序</h4><ul>
<li>scanDirTracedLI()：扫描&#x2F;data&#x2F;app&#x2F;目录文件下的所有apk文件信息，在scanDirTracedLI（）中直接调用scanDirLI（）方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scanDirLI</span><span class="params">(File scanDir, <span class="type">int</span> parseFlags, <span class="type">int</span> scanFlags, <span class="type">long</span> currentTime)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> File[] files = scanDir.listFiles(); <span class="comment">// 1、获取目录下的文件集合,即所有的apk列表，然后逐个解析</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ParallelPackageParser</span> <span class="variable">parallelPackageParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParallelPackageParser</span>(</span><br><span class="line">        mSeparateProcesses, mOnlyCore, mMetrics, mCacheDir,</span><br><span class="line">        mParallelPackageParserCallback)) &#123; <span class="comment">// 2、创建ParallelPackageParser对象</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">fileCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        parallelPackageParser.submit(file, parseFlags); <span class="comment">//3、遍历files集合，使用parallelPackageParser提交每个apk文件</span></span><br><span class="line">        fileCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; fileCount &gt; <span class="number">0</span>; fileCount--) &#123;</span><br><span class="line">        ParallelPackageParser.<span class="type">ParseResult</span> <span class="variable">parseResult</span> <span class="operator">=</span> parallelPackageParser.take();<span class="comment">//4、取出每个File的扫描结果，执行scan</span></span><br><span class="line">        scanPackageChildLI(parseResult.pkg, parseFlags, scanFlags,currentTime, <span class="literal">null</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scanDirLI（）方法执行的逻辑很简单：</p>
<ol>
<li>遍历文件目录下的所有文件</li>
<li>创建ParallelPackageParser对象，调用submit（）方法提交请求，执行解析每个apk文件</li>
<li>调用parallelPackageParser.take()逐个取出每个解析的结果</li>
</ol>
<p>到这里我们知道PMS是对&#x2F;data&#x2F;app&#x2F;目录中所有apk文件进行解析，在之前的版本中会直接创建PackageParser对象执行解析，在Androip P版本中引入ParallelPackageParser类，使用线程池和队列执行程序的解析；</p>
<ul>
<li>ParallelPackageParser：内部使用线程池和队列执行文件目录中apk扫描解析</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;ParseResult&gt; mQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY); <span class="comment">// 1、保存请求结果的队列，阻塞线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">mService</span> <span class="operator">=</span> ConcurrentUtils.newFixedThreadPool(MAX_THREADS,</span><br><span class="line">        <span class="string">&quot;package-parsing-thread&quot;</span>, Process.THREAD_PRIORITY_FOREGROUND); <span class="comment">// 2、创建线程池</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(File scanFile, <span class="type">int</span> parseFlags)</span> &#123;</span><br><span class="line">    mService.submit(() -&gt; &#123; <span class="comment">// 3、线程池提交任务</span></span><br><span class="line">        <span class="type">ParseResult</span> <span class="variable">pr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParseResult</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">PackageParser</span> <span class="variable">pp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageParser</span>();</span><br><span class="line">            pp.setSeparateProcesses(mSeparateProcesses);</span><br><span class="line">            pp.setOnlyCoreApps(mOnlyCore);</span><br><span class="line">            pp.setDisplayMetrics(mMetrics);</span><br><span class="line">            pp.setCacheDir(mCacheDir);</span><br><span class="line">            pp.setCallback(mPackageParserCallback);</span><br><span class="line">            pr.scanFile = scanFile;</span><br><span class="line">            pr.pkg = parsePackage(pp, scanFile, parseFlags); <span class="comment">// 执行文件的解析扫描，将结果封装在ParseResult中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mQueue.put(pr); <span class="comment">// 4、将解析的结果添加到队列中</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            mInterruptedInThread = Thread.currentThread().getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> ParseResult <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mQueue.take(); <span class="comment">// 从队列中取出解析结果</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ParallelPackageParser中利用线程池处理并发问题，执行多个apk文件的解析，并使用阻塞队列的方式同步线程的数据，在submit提交的任务run（）方法中，创建了PackageParser对象并调用parser（）方法解析apk，之后将解析的结果封装在ParseResult中，最后添加到mQueue队列中，PMS中在依次调用take（）方法从mQueue队列中获取执行的结果；</p>
<ul>
<li>PackageParser.parsePackage（）：解析每个apk文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Package <span class="title function_">parsePackage</span><span class="params">(File packageFile, <span class="type">int</span> flags, <span class="type">boolean</span> useCaches)</span></span><br><span class="line">        <span class="keyword">throws</span> PackageParserException &#123;</span><br><span class="line">    <span class="type">Package</span> <span class="variable">parsed</span> <span class="operator">=</span> useCaches ? getCachedResult(packageFile, flags) : <span class="literal">null</span>; <span class="comment">// 1、从缓存中获取解析结果</span></span><br><span class="line">    <span class="keyword">if</span> (parsed != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> parsed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (packageFile.isDirectory()) &#123; <span class="comment">// 2、判断是文件还是文件夹，分别执行不同的方法；</span></span><br><span class="line">        parsed = parseClusterPackage(packageFile, flags); <span class="comment">// 执行文件夹解析</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parsed = parseMonolithicPackage(packageFile, flags); <span class="comment">// 执行单个apk文件解析，单个安装apk文件时执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    cacheResult(packageFile, flags, parsed); <span class="comment">// 3、缓存解析的结果parser</span></span><br><span class="line">    <span class="keyword">return</span> parsed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ParserPackage.parser（）中开始执行apk文件的解析，对于apk文件执行parseMonolithicPackage（），在执行解析结束后会缓存解析结果；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Package <span class="title function_">parseMonolithicPackage</span><span class="params">(File apkFile, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> PackageParserException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">PackageLite</span> <span class="variable">lite</span> <span class="operator">=</span> parseMonolithicPackageLite(apkFile, flags);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SplitAssetLoader</span> <span class="variable">assetLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultSplitAssetLoader</span>(lite, flags); <span class="comment">// 1、使用AssetManager加载资源文件</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Package</span> <span class="variable">pkg</span> <span class="operator">=</span> parseBaseApk(apkFile, assetLoader.getBaseAssetManager(), flags); <span class="comment">// 执行parseBaseAPk</span></span><br><span class="line">        pkg.setCodePath(apkFile.getCanonicalPath());</span><br><span class="line">        pkg.setUse32bitAbi(lite.use32bitAbi);</span><br><span class="line">        <span class="keyword">return</span> pkg;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>parseMonolithicPackageLite（）:先解析出apk文件的基本信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> PackageLite <span class="title function_">parseMonolithicPackageLite</span><span class="params">(File packageFile, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> PackageParserException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ApkLite</span> <span class="variable">baseApk</span> <span class="operator">=</span> parseApkLite(packageFile, flags);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">packagePath</span> <span class="operator">=</span> packageFile.getAbsolutePath();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PackageLite</span>(packagePath, baseApk, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先轻量级解析apk的基本信息</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> ApkLite <span class="title function_">parseApkLite</span><span class="params">(String codePath, XmlPullParser parser, AttributeSet attrs,SigningDetails signingDetails)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, XmlPullParserException, PackageParserException &#123;</span><br><span class="line">        <span class="keyword">final</span> Pair&lt;String, String&gt; packageSplit = parsePackageSplitNames(parser, attrs);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; attrs.getAttributeCount(); i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">attr</span> <span class="operator">=</span> attrs.getAttributeName(i);</span><br><span class="line">            <span class="keyword">if</span> (attr.equals(<span class="string">&quot;installLocation&quot;</span>)) &#123;</span><br><span class="line">                installLocation = attrs.getAttributeIntValue(i,</span><br><span class="line">                        PARSE_DEFAULT_INSTALL_LOCATION);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (attr.equals(<span class="string">&quot;versionCode&quot;</span>)) &#123;</span><br><span class="line">                versionCode = attrs.getAttributeIntValue(i, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (attr.equals(<span class="string">&quot;versionCodeMajor&quot;</span>)) &#123;</span><br><span class="line">                versionCodeMajor = attrs.getAttributeIntValue(i, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (attr.equals(<span class="string">&quot;revisionCode&quot;</span>)) &#123;</span><br><span class="line">                revisionCode = attrs.getAttributeIntValue(i, <span class="number">0</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            .....</span><br><span class="line">        &#125;</span><br><span class="line">         ......</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApkLite</span>(codePath, packageSplit.first, packageSplit.second, isFeatureSplit,</span><br><span class="line">                configForSplit, usesSplitName, versionCode, versionCodeMajor, revisionCode,</span><br><span class="line">                installLocation, verifiers, signingDetails, coreApp, debuggable,</span><br><span class="line">                multiArch, use32bitAbi, extractNativeLibs, isolatedSplits);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在parseMonolithicPackage（）中先调用parseApkLite（）将File先简单的解析以下，这里的解析只是获取注册清单中的基础信息，并将信息保存在ApkLite对象中，然后将ApkLite和文件路径<br>封装在PackageLite对象中；</p>
<ul>
<li><p>DefaultSplitAssetLoader：内部使用AssestManager加载apk文件的资源，并缓存AssestManager对象信息，主要针对split APK；</p>
</li>
<li><p>parseBaseApk（）：解析每个apk文件</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Package <span class="title function_">parseBaseApk</span><span class="params">(File apkFile, AssetManager assets, <span class="type">int</span> flags)</span></span><br><span class="line">        <span class="keyword">throws</span> PackageParserException &#123;<span class="comment">// 参数：apk文件File、apk文件路径destCodePath</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">apkPath</span> <span class="operator">=</span> apkFile.getAbsolutePath(); <span class="comment">// 1、获取apk文件路径</span></span><br><span class="line">         mArchiveSourcePath = sourceFile.getPath(); </span><br><span class="line"><span class="number">399</span>        <span class="type">int</span> <span class="variable">cookie</span> <span class="operator">=</span> assmgr.findCookieForPath(mArchiveSourcePath); <span class="comment">// 2、将apk的路径添加到AssetManager中加载资源</span></span><br><span class="line"><span class="number">401</span>        parser = assmgr.openXmlResourceParser(cookie, <span class="string">&quot;AndroidManifest.xml”); // 3、解析xml注册清单文件</span></span><br><span class="line"><span class="string">           Resources res = new Resources(assmgr, metrics, null); // 4、创建Resource对象</span></span><br><span class="line"><span class="string">           pkg = parseBaseApk(res, parser, flags, errorText); // 解析parser中的信息，保存在Package对象中</span></span><br><span class="line"><span class="string">pkg.setVolumeUuid(volumeUuid);</span></span><br><span class="line"><span class="string">pkg.setApplicationVolumeUuid(volumeUuid);</span></span><br><span class="line"><span class="string">pkg.setBaseCodePath(apkPath);</span></span><br><span class="line"><span class="string">pkg.setSigningDetails(SigningDetails.UNKNOWN);</span></span><br><span class="line"><span class="string">return pkg;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>parseBaseApk（）中从apkFile对象中获取apk文件路径，然后使用assmgr加载apk文件中的资源，从文件中读取注册清单文件，然后调用parseBaseApk解析注册清单；</p>
<ol>
<li>parseBaseApk（）：从Parser对象中获取解析的信息，保存在Package对象中</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> Package <span class="title function_">parseBaseApk</span><span class="params">(String apkPath,Resources res, XmlResourceParser parser, <span class="type">int</span> flags, String[] outError)</span>&#123;</span><br><span class="line">Pair&lt;String, String&gt; packageSplit = parsePackageSplitNames(parser, parser); <span class="comment">//1、从parser中解析出“package”设置的包名pkgName</span></span><br><span class="line">pkgName = packageSplit.first;</span><br><span class="line">splitName = packageSplit.second;</span><br><span class="line"><span class="type">Package</span> <span class="variable">pkg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Package</span>(pkgName); <span class="comment">// 2、创建Package对象，保存apk的包名</span></span><br><span class="line"><span class="comment">//从Resource中获取各种信息，并保存在Package的属性中</span></span><br><span class="line"> pkg.mVersionCode = sa.getInteger(…...</span><br><span class="line">pkg.mVersionName = sa.getNonConfigurationString(…...</span><br><span class="line"> pkg.mSharedUserId = str.intern(…...);</span><br><span class="line">pkg.mSharedUserLabel = sa.getResourceId(…...</span><br><span class="line">pkg.installLocation = sa.getInteger(…...</span><br><span class="line">pkg.applicationInfo.installLocation = pkg.installLocation;</span><br><span class="line"><span class="keyword">return</span> parseBaseApkCommon(pkg, <span class="literal">null</span>, res, parser, flags, outError); <span class="comment">// 3、调用parseBaseApkCommon（）继续解析文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>parseBaseApk中从parser中提取注册清单中的基础信息，并封装保存在Pakage对象中，然后调用parseBaseApkCommon（）方法继续解析清单文件中内容</p>
<ul>
<li>parseBaseApkCommon（）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//parseBaseApkCommon（）从Parser对象中解析数据信息</span></span><br><span class="line"><span class="type">int</span> <span class="variable">outerDepth</span> <span class="operator">=</span> parser.getDepth(); <span class="comment">// 获取parser的深度</span></span><br><span class="line"><span class="keyword">while</span> ((type=parser.next()) != parser.END_DOCUMENT. <span class="comment">// 1、循环解析parser对象</span></span><br><span class="line"><span class="number">804</span>               &amp;&amp; (type != parser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line"> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;application&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!parseBaseApplication(pkg, res, parser, attrs, flags, outError)) &#123; <span class="comment">// 2、解析application标签</span></span><br><span class="line"><span class="number">825</span>                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;permission&quot;</span>)) &#123; <span class="comment">// 3、解析权限标签</span></span><br><span class="line"><span class="number">832</span>                <span class="keyword">if</span> (parsePermission(pkg, res, parser, attrs, outError) == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="number">833</span>                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"><span class="number">834</span>                &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;uses-feature&quot;</span>)) &#123; <span class="comment">// 4、解析使用的user-feature标签，并保存在Package的集合中</span></span><br><span class="line"> <span class="type">FeatureInfo</span> <span class="variable">fi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FeatureInfo</span>();</span><br><span class="line">    …….</span><br><span class="line">pkg.reqFeatures.add(fi);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;uses-sdk&quot;</span>)) &#123; <span class="comment">// 解析user-sdk标签</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;supports-screens&quot;</span>)) &#123; <span class="comment">// 解析support-screens标签</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>parseBaseApkCommon（）中主要负责解析清单文件中的各种标签信息，其中最主要的就是解析标签下的四大组件的信息，在遇到applicaiton标签时直接调用了parseBaseApplication（）执行解析；</p>
<ul>
<li>parseBaseApplication（），主要的解析工作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">tagName</span> <span class="operator">=</span> parser.getName();</span><br><span class="line"><span class="keyword">final</span> <span class="type">ApplicationInfo</span> <span class="variable">ai</span> <span class="operator">=</span> owner.applicationInfo;</span><br><span class="line">ai.theme = sa.getResourceId(</span><br><span class="line">        com.android.internal.R.styleable.AndroidManifestApplication_theme, <span class="number">0</span>);</span><br><span class="line">ai.descriptionRes = sa.getResourceId(</span><br><span class="line">        com.android.internal.R.styleable.AndroidManifestApplication_description, <span class="number">0</span>);</span><br><span class="line">ai.maxAspectRatio = sa.getFloat(R.styleable.AndroidManifestApplication_maxAspectRatio, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别解析四大组件，将解析结果保存在Package对应的集合中</span></span><br><span class="line"><span class="number">1644</span>            <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;activity&quot;</span>)) &#123; </span><br><span class="line"><span class="number">1645</span>                <span class="type">Activity</span> <span class="variable">a</span> <span class="operator">=</span> parseActivity(owner, res, parser, attrs, flags, outError, <span class="literal">false</span>);</span><br><span class="line"><span class="number">1651</span>                owner.activities.add(a);</span><br><span class="line"><span class="number">1653</span>            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;receiver&quot;</span>)) &#123;</span><br><span class="line"><span class="number">1654</span>                <span class="type">Activity</span> <span class="variable">a</span> <span class="operator">=</span> parseActivity(owner, res, parser, attrs, flags, outError, <span class="literal">true</span>);</span><br><span class="line"><span class="number">1660</span>                owner.receivers.add(a);</span><br><span class="line"><span class="number">1662</span>            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;service&quot;</span>)) &#123;</span><br><span class="line"><span class="number">1663</span>                <span class="type">Service</span> <span class="variable">s</span> <span class="operator">=</span> parseService(owner, res, parser, attrs, flags, outError);</span><br><span class="line"><span class="number">1669</span>                owner.services.add(s);</span><br><span class="line"><span class="number">1671</span>            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;provider&quot;</span>)) &#123;</span><br><span class="line"><span class="number">1672</span>                <span class="type">Provider</span> <span class="variable">p</span> <span class="operator">=</span> parseProvider(owner, res, parser, attrs, flags, outError);</span><br><span class="line"><span class="number">1678</span>                owner.providers.add(p);</span><br><span class="line"><span class="number">1680</span>            &#125;</span><br></pre></td></tr></table></figure>

<p>清单文件解析共分两部分：</p>
<ol>
<li>解析出application标签下设置的name类名、icon、theme、targetSdk、processName等属性标签并保存在ApplicationInfo对象中</li>
<li>循环解析activity、receiver、service、provider四个标签，并将信息到保存在Package中对应的集合中</li>
</ol>
<p>下面逐个分析下四大组件是如何解析保存的：</p>
<ul>
<li>parserActivity（）：解析Activity和Receiver标签并返回Activity对象封装所有属性；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Activity <span class="title function_">parseActivity</span><span class="params">(Package owner,...)</span></span><br><span class="line">        <span class="keyword">throws</span> XmlPullParserException, IOException &#123;</span><br><span class="line"><span class="type">TypedArray</span> <span class="variable">sa</span> <span class="operator">=</span> res.obtainAttributes(parser, R.styleable.AndroidManifestActivity);</span><br><span class="line">cachedArgs.mActivityArgs.tag = receiver ? <span class="string">&quot;&lt;receiver&gt;&quot;</span> : <span class="string">&quot;&lt;activity&gt;”; // 1、判断为activity或receiver</span></span><br><span class="line"><span class="string">cachedArgs.mActivityArgs.sa = sa;</span></span><br><span class="line"><span class="string">cachedArgs.mActivityArgs.flags = flags;</span></span><br><span class="line"><span class="string">Activity a = new Activity(cachedArgs.mActivityArgs, new ActivityInfo()); // 2、创建Activity实例，并初始化系列属性</span></span><br><span class="line"><span class="string">a.info.theme = sa.getResourceId(R.styleable.AndroidManifestActivity_theme, 0);</span></span><br><span class="line"><span class="string">a.info.taskAffinity = buildTaskAffinityName(owner.applicationInfo.packageName,</span></span><br><span class="line"><span class="string">        owner.applicationInfo.taskAffinity, str, outError);</span></span><br><span class="line"><span class="string">a.info.launchMode = ...</span></span><br><span class="line"><span class="string">if (parser.getName().equals(&quot;</span>intent-filter<span class="string">&quot;)) &#123; // 3、解析intent-filter</span></span><br><span class="line"><span class="string">    ActivityIntentInfo intent = new ActivityIntentInfo(a);</span></span><br><span class="line"><span class="string">    if (!parseIntent(res, parser, true /*allowGlobs*/, true /*allowAutoVerify*/,</span></span><br><span class="line"><span class="string">            intent, outError)) &#123;</span></span><br><span class="line"><span class="string">        return null;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">        a.order = Math.max(intent.getOrder(), a.order);</span></span><br><span class="line"><span class="string">        a.intents.add(intent); // 将intent设置到Activity</span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">return a;</span></span><br></pre></td></tr></table></figure>

<p>在解析Activity和Receiver标签时，当标签设置intent-filter时则创建一个ActivityIntentInfo对象，并调用parseIntent（）将intent-filter标签下的信息解析到ActivityIntentInfo中，并将ActivityIntentInfo对象保存在a.intents的集合中，简单的说一个intent-filter对应一个ActivityIntentInfo对象，一个Activity和Receiver可以包好多个intent-filter；</p>
<ol>
<li>parseIntent()：解析每个intent-filter标签下的action、name等属性值，并将所有的属性值保存在outInfo对象中，这里的outInfo是ActivityIntentInfo对象；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">        &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">nodeName</span> <span class="operator">=</span> parser.getName(); <span class="comment">// 1、获取节点名称</span></span><br><span class="line">    <span class="keyword">if</span> (nodeName.equals(<span class="string">&quot;action&quot;</span>)) &#123; <span class="comment">//2、处理action节点</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> parser.getAttributeValue( <span class="comment">// 3、获取action节点的name属性，并保存在outInfo属性中</span></span><br><span class="line">        ANDROID_RESOURCES, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">    outInfo.addAction(value); <span class="comment">//</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeName.equals(<span class="string">&quot;category&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> parser.getAttributeValue( <span class="comment">// 4、获取category属性，保存在outInfo属性中</span></span><br><span class="line">            ANDROID_RESOURCES, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">    outInfo.addCategory(value); <span class="comment">// 添加到Category集合中</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeName.equals(<span class="string">&quot;data&quot;</span>)) &#123;</span><br><span class="line">sa = res.obtainAttributes(parser,</span><br><span class="line">        com.android.internal.R.styleable.AndroidManifestData); <span class="comment">// 解析parser为sa属性</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sa.getNonConfigurationString(</span><br><span class="line">        com.android.internal.R.styleable.AndroidManifestData_mimeType, <span class="number">0</span>);</span><br><span class="line">        outInfo.addDataType(str); <span class="comment">// 获取并保存mimeType中</span></span><br><span class="line">str = sa.getNonConfigurationString(</span><br><span class="line">        com.android.internal.R.styleable.AndroidManifestData_scheme, <span class="number">0</span>);</span><br><span class="line">    outInfo.addDataScheme(str); <span class="comment">// 获取并保存scheme中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> sa.getNonConfigurationString(</span><br><span class="line">        com.android.internal.R.styleable.AndroidManifestData_host, <span class="number">0</span>); <span class="comment">// </span></span><br><span class="line"><span class="type">String</span> <span class="variable">port</span> <span class="operator">=</span> sa.getNonConfigurationString(</span><br><span class="line">        com.android.internal.R.styleable.AndroidManifestData_port, <span class="number">0</span>);</span><br><span class="line">    outInfo.addDataAuthority(host, port); <span class="comment">// 获取并保存host、port属性</span></span><br><span class="line">outInfo.hasDefault = outInfo.hasCategory(Intent.CATEGORY_DEFAULT); <span class="comment">// 设置Default属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ActivityIntentInfo 继承 IntentInfo ，IntentInfo继承IntentFilter属性，所以outInfo保存的数据都保存在IntentFilter中，在IntentFilter中有标签对应的集合，如actions、mDataSchemes等，所以遍历的所有intent-filter中设置的数据都保存在其中；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ActivityIntentInfo</span> <span class="keyword">extends</span> <span class="title class_">IntentInfo</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">IntentInfo</span> <span class="keyword">extends</span> <span class="title class_">IntentFilter</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addAction</span><span class="params">(String action)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mActions.contains(action)) &#123;</span><br><span class="line">        mActions.add(action.intern()); <span class="comment">// 在Intent-Filter中保存action</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCategory</span><span class="params">(String category)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCategories == <span class="literal">null</span>) mCategories = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="keyword">if</span> (!mCategories.contains(category)) &#123;</span><br><span class="line">        mCategories.add(category.intern()); <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addDataScheme</span><span class="params">(String scheme)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mDataSchemes == <span class="literal">null</span>) mDataSchemes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="keyword">if</span> (!mDataSchemes.contains(scheme)) &#123;</span><br><span class="line">        mDataSchemes.add(scheme.intern()); <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>parserService（）：解析Service标签并返回Service对象，对应service标签下的信息保存在ServiceIntentInfo对象中，ServiceIntentInfo的作用和保存和ActivityIntentInfo一样</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TypedArray</span> <span class="variable">sa</span> <span class="operator">=</span> res.obtainAttributes(parser,</span><br><span class="line">        com.android.internal.R.styleable.AndroidManifestService);</span><br><span class="line">cachedArgs.mServiceArgs.sa = sa;</span><br><span class="line">cachedArgs.mServiceArgs.flags = flags;</span><br><span class="line"><span class="type">Service</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Service</span>(cachedArgs.mServiceArgs, <span class="keyword">new</span> <span class="title class_">ServiceInfo</span>()); <span class="comment">// 创建Service对象</span></span><br><span class="line"><span class="keyword">if</span> (parser.getName().equals(<span class="string">&quot;intent-filter&quot;</span>)) &#123; <span class="comment">// 解析intent-filter节点</span></span><br><span class="line">    <span class="type">ServiceIntentInfo</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceIntentInfo</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (!parseIntent(res, parser, <span class="literal">true</span> <span class="comment">/*allowGlobs*/</span>, <span class="literal">false</span> <span class="comment">/*allowAutoVerify*/</span>,</span><br><span class="line">            intent, outError)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.order = Math.max(intent.getOrder(), s.order);</span><br><span class="line">    s.intents.add(intent);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parser.getName().equals(<span class="string">&quot;meta-data&quot;</span>)) &#123; <span class="comment">// 解析meta-data数据，保存在bundle中</span></span><br><span class="line">    <span class="keyword">if</span> ((s.metaData=parseMetaData(res, parser, s.metaData,</span><br><span class="line">            outError)) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>parserProvider（）：解析provider标签并返回provider对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TypedArray</span> <span class="variable">sa</span> <span class="operator">=</span> res.obtainAttributes(parser,</span><br><span class="line">        com.android.internal.R.styleable.AndroidManifestProvider);</span><br><span class="line">cachedArgs.mProviderArgs.tag = <span class="string">&quot;&lt;provider&gt;&quot;</span>;</span><br><span class="line">cachedArgs.mProviderArgs.sa = sa;</span><br><span class="line">cachedArgs.mProviderArgs.flags = flags;</span><br><span class="line"></span><br><span class="line"><span class="type">Provider</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Provider</span>(cachedArgs.mProviderArgs, <span class="keyword">new</span> <span class="title class_">ProviderInfo</span>()); <span class="comment">// 创建Provider对象</span></span><br><span class="line">p.info.exported = sa.getBoolean(</span><br><span class="line">        com.android.internal.R.styleable.AndroidManifestProvider_exported,</span><br><span class="line">        providerExportedDefault);</span><br><span class="line"><span class="type">String</span> <span class="variable">permission</span> <span class="operator">=</span> sa.getNonConfigurationString(</span><br><span class="line">        com.android.internal.R.styleable.AndroidManifestProvider_permission, <span class="number">0</span>);</span><br><span class="line">p.info.multiprocess = sa.getBoolean(</span><br><span class="line">        com.android.internal.R.styleable.AndroidManifestProvider_multiprocess,</span><br><span class="line">        <span class="literal">false</span>);</span><br><span class="line">p.info.authority = cpname.intern();</span><br><span class="line"><span class="keyword">if</span> (!parseProviderTags( <span class="comment">// 调用parseProvider解析provider下的标签</span></span><br><span class="line">        res, parser, visibleToEphemeral, p, outError)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在解析provider标签中，创建ProviderInfo对象保存设置的属性信息，如export、permission等，然后调用parseProviderTags解析provider标签中使用的其他标签信息</p>
<ol>
<li>parseProviderTags（）：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">parseProviderTags</span><span class="params">(Resources res, XmlResourceParser parser,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> visibleToEphemeral, Provider outInfo, String[] outError)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">outerDepth</span> <span class="operator">=</span> parser.getDepth();</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="keyword">while</span> ((type=parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">           &amp;&amp; (type != XmlPullParser.END_TAG</span><br><span class="line">                   || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line"><span class="keyword">if</span> (parser.getName().equals(<span class="string">&quot;intent-filter&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">ProviderIntentInfo</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProviderIntentInfo</span>(outInfo);</span><br><span class="line">    <span class="keyword">if</span> (!parseIntent(res, parser, <span class="literal">true</span> <span class="comment">/*allowGlobs*/</span>, <span class="literal">false</span> <span class="comment">/*allowAutoVerify*/</span>,</span><br><span class="line">            intent, outError)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    outInfo.order = Math.max(intent.getOrder(), outInfo.order);</span><br><span class="line">    outInfo.intents.add(intent);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (parser.getName().equals(<span class="string">&quot;meta-data&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((outInfo.metaData=parseMetaData(res, parser,</span><br><span class="line">            outInfo.metaData, outError)) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (parser.getName().equals(<span class="string">&quot;grant-uri-permission&quot;</span>)) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sa.getNonConfigurationString(</span><br><span class="line">        com.android.internal.R.styleable.AndroidManifestGrantUriPermission_path, <span class="number">0</span>);</span><br><span class="line"><span class="type">PatternMatcher</span>   <span class="variable">pa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PatternMatcher</span>(str, PatternMatcher.PATTERN_LITERAL); <span class="comment">// 创建PatterMatcher匹配权限</span></span><br><span class="line">PatternMatcher[] newp = <span class="keyword">new</span> <span class="title class_">PatternMatcher</span>[N+<span class="number">1</span>];</span><br><span class="line">newp[N] = pa;</span><br><span class="line">outInfo.info.uriPermissionPatterns = newp; <span class="comment">// 保存临时权限数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (parser.getName().equals(<span class="string">&quot;path-permission&quot;</span>)) &#123; <span class="comment">// 保存路径权限</span></span><br><span class="line">newp[N] = pa;</span><br><span class="line">outInfo.info.pathPermissions = newp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要解析如下：</p>
<ol>
<li>对于intent-filter标签，调用parserIntent（）解析保存在ProviderIntentInfo对象中，并添加到intent集合中</li>
<li>解析设置的meta-data值</li>
<li>解析grant-uri-permission和path-permission等权限的匹配状况保存在Provider对象中的数组中；</li>
</ol>
<p>到此apk文件已经解析完成，相应的文件和属性都封装在Package对象中，并都保存在PMS属性集合mPackages集合中；</p>
<h4 id="将apk解析数据同步到PMS的属性中"><a href="#将apk解析数据同步到PMS的属性中" class="headerlink" title="将apk解析数据同步到PMS的属性中"></a>将apk解析数据同步到PMS的属性中</h4><p>在使用线程池执行所有的apk解析后，所有的解析结果都保存在队列中，系统会循环调用take（）方法取出解析的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; fileCount &gt; <span class="number">0</span>; fileCount--) &#123;</span><br><span class="line">                ParallelPackageParser.<span class="type">ParseResult</span> <span class="variable">parseResult</span> <span class="operator">=</span> parallelPackageParser.take();</span><br><span class="line">                </span><br><span class="line">scanPackageChildLI(parseResult.pkg, parseFlags, scanFlags,</span><br><span class="line">                                    currentTime, <span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p>取出apk文件解析结果后，调用scanPackageChildLI（）扫描获取到的ParseResult中的Pakcage对象，scanPackageChildLI（）中直接调用addForInitLI（）方法</p>
<ul>
<li>addForInitLI（）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">PackageSetting</span> <span class="variable">installedPkgSetting</span> <span class="operator">=</span> mSettings.getPackageLPr(pkg.packageName); <span class="comment">// 1、获取从配置文件中读取的Settings</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> PackageParser.<span class="type">Package</span> <span class="variable">scannedPkg</span> <span class="operator">=</span> scanPackageNewLI(pkg, parseFlags, scanFlags | SCAN_UPDATE_SIGNATURE, currentTime, user)； <span class="comment">// 调用scanPackageNewLI将pkg中的数据保存到PMS的变量中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scanPackageNewLI（）：创建ScanRequest对象，执行文件扫描修改或更新对应的PackageSetting对象</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">ScanRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScanRequest</span>(pkg, sharedUserSetting,</span><br><span class="line">        pkgSetting == <span class="literal">null</span> ? <span class="literal">null</span> : pkgSetting.pkg, pkgSetting, disabledPkgSetting,</span><br><span class="line">        originalPkgSetting, realPkgName, parseFlags, scanFlags,</span><br><span class="line">        (pkg == mPlatformPackage), user);</span><br><span class="line"><span class="keyword">final</span> <span class="type">ScanResult</span> <span class="variable">result</span> <span class="operator">=</span> scanPackageOnlyLI(request, mFactoryTest, currentTime); </span><br><span class="line"><span class="keyword">if</span> (result.success) &#123;</span><br><span class="line">    commitScanResultsLocked(request, result); <span class="comment">// 调用commitScanResultsLocked（）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>commitScanResultsLocked（）中直接调用commitPackageSettings（）调教apk的解析数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commitPackageSettings(pkg, oldPkg, pkgSetting, user, scanFlags,</span><br><span class="line">(parseFlags &amp; PackageParser.PARSE_CHATTY) != <span class="number">0</span> <span class="comment">/*chatty*/</span>); <span class="comment">// 提交包解析数据</span></span><br></pre></td></tr></table></figure>

<ul>
<li>commitPackageSettings（）：将解析得到的Package中的信息保存到PMS内部变量中，并创建程序包所需的各种文件信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">pkgName</span> <span class="operator">=</span> pkg.packageName;</span><br><span class="line"><span class="keyword">if</span> (pkg.packageName.equals(<span class="string">&quot;android&quot;</span>)) &#123; <span class="comment">// 1、针对系统包，特殊处理属性的初始化</span></span><br><span class="line">                   mPlatformPackage = pkg;</span><br><span class="line"><span class="number">2897</span>                pkg.mVersionCode = mSdkVersion;</span><br><span class="line"><span class="number">2898</span>                mAndroidApplication = pkg.applicationInfo;</span><br><span class="line"><span class="number">2899</span>                mResolveActivity.applicationInfo = mAndroidApplication;</span><br><span class="line"><span class="number">2900</span>                mResolveActivity.name = ResolverActivity.class.getName();</span><br><span class="line">。。。。。。</span><br><span class="line"><span class="number">2912</span>                mResolveComponentName = <span class="keyword">new</span> <span class="title class_">ComponentName</span>(</span><br><span class="line"><span class="number">2913</span>             mAndroidApplication.packageName, mResolveActivity.name);</span><br><span class="line">&#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> pkg.usesLibraries != <span class="literal">null</span> ? pkg.usesLibraries.size() : <span class="number">0</span>;</span><br><span class="line"><span class="number">2950</span>                <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line"><span class="number">2951</span>                <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> mSharedLibraries.get(pkg.usesLibraries.get(i)); </span><br><span class="line">                    mTmpSharedLibraries[num] = file;   <span class="comment">// 遍历所有的user-library标签保存在数组中</span></span><br><span class="line"><span class="number">2960</span>                num++;</span><br><span class="line"><span class="number">2961</span>                &#125;</span><br><span class="line">            <span class="keyword">if</span> (!verifySignaturesLP(pkgSetting, pkg)) &#123; <span class="comment">// 校验签名文件</span></span><br><span class="line">  ……. </span><br><span class="line">&#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> pkg.providers.size();</span><br><span class="line"><span class="number">3404</span>            <span class="type">StringBuilder</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="number">3405</span>            <span class="type">int</span> i;</span><br><span class="line"><span class="number">3406</span>            <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line"><span class="number">3407</span>            PackageParser.<span class="type">Provider</span> <span class="variable">p</span> <span class="operator">=</span> pkg.providers.get(i); <span class="comment">//遍历提取每个provider</span></span><br><span class="line"><span class="number">3408</span>                p.info.processName = fixProcessName(pkg.applicationInfo.processName,</span><br><span class="line"><span class="number">3409</span>                        p.info.processName, pkg.applicationInfo.uid);</span><br><span class="line"><span class="number">3410</span>                mProvidersByComponent.put(<span class="keyword">new</span> <span class="title class_">ComponentName</span>(p.info.packageName,</span><br><span class="line"><span class="number">3411</span>                        p.info.name), p); <span class="comment">// 针对Provider创建ComponentName对象，保存在mProvidersByComponent集合中</span></span><br><span class="line"><span class="number">3413</span>                <span class="keyword">if</span> (p.info.authority != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="number">3414</span>                    String names[] = p.info.authority.split(<span class="string">&quot;;”); // 获取Provider的权限信息</span></span><br><span class="line"><span class="string">3415                    p.info.authority = null;</span></span><br><span class="line"><span class="string">3416                    for (int j = 0; j &lt; names.length; j++) &#123;</span></span><br><span class="line"><span class="string">3417                        if (j == 1 &amp;&amp; p.syncable) &#123;</span></span><br><span class="line"><span class="string">3425                            p = new PackageParser.Provider(p);</span></span><br><span class="line"><span class="string">3426                            p.syncable = false;</span></span><br><span class="line"><span class="string">3427                        &#125;</span></span><br><span class="line"><span class="string">3428                        if (!mProviders.containsKey(names[j])) &#123;</span></span><br><span class="line"><span class="string">3429                            mProviders.put(names[j], p); // 将权限和对应的Provider以键值对保存在 mProviders 集合中</span></span><br><span class="line"><span class="string">3447                    &#125;</span></span><br><span class="line"><span class="string">3448                &#125;</span></span><br><span class="line"><span class="string">3457            &#125;</span></span><br><span class="line"><span class="string">3460            &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">N = pkg.services.size();</span></span><br><span class="line"><span class="string">3463            r = null;</span></span><br><span class="line"><span class="string">3464            for (i=0; i&lt;N; i++) &#123;</span></span><br><span class="line"><span class="string">3465                PackageParser.Service s = pkg.services.get(i);</span></span><br><span class="line"><span class="string">3466                s.info.processName = fixProcessName(pkg.applicationInfo.processName,</span></span><br><span class="line"><span class="string">3467                        s.info.processName, pkg.applicationInfo.uid);</span></span><br><span class="line"><span class="string">3468                mServices.addService(s);</span></span><br><span class="line"><span class="string">N = pkg.receivers.size();</span></span><br><span class="line"><span class="string">3483            r = null;</span></span><br><span class="line"><span class="string">3484            for (i=0; i&lt;N; i++) &#123;</span></span><br><span class="line"><span class="string">3485                PackageParser.Activity a = pkg.receivers.get(i);</span></span><br><span class="line"><span class="string">3486                a.info.processName = fixProcessName(pkg.applicationInfo.processName,</span></span><br><span class="line"><span class="string">3487                        a.info.processName, pkg.applicationInfo.uid);</span></span><br><span class="line"><span class="string">3488                mReceivers.addActivity(a, &quot;</span>receiver<span class="string">&quot;);</span></span><br><span class="line"><span class="string">3497            &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> N = pkg.activities.size();</span></span><br><span class="line"><span class="string">3503            r = null;</span></span><br><span class="line"><span class="string">3504            for (i=0; i&lt;N; i++) &#123;</span></span><br><span class="line"><span class="string">3505                PackageParser.Activity a = pkg.activities.get(i);</span></span><br><span class="line"><span class="string">3506                a.info.processName = fixProcessName(pkg.applicationInfo.processName,</span></span><br><span class="line"><span class="string">3507                        a.info.processName, pkg.applicationInfo.uid);</span></span><br><span class="line"><span class="string">3508                mActivities.addActivity(a, &quot;</span>activity<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>在commitPackageSettings中，主要是将每个apk文件获得的Package对象中保存的四大组件信息分别提取保存在PMS内部对应的属性中，在PMS内部有4个专门储存四大组件的属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ActivityIntentResolver</span> <span class="variable">mActivities</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityIntentResolver</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="type">ActivityIntentResolver</span> <span class="variable">mReceivers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityIntentResolver</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="type">ServiceIntentResolver</span> <span class="variable">mServices</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceIntentResolver</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="type">ProviderIntentResolver</span> <span class="variable">mProviders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProviderIntentResolver</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>ActivityIntentResolver.addActivity()：处理Activity和Receiver分别保存在各自的ArrayMap中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addActivity</span><span class="params">(PackageParser.Activity a, String type)</span> &#123;</span><br><span class="line">    mActivities.put(a.getComponentName(), a); <span class="comment">// 1、获取内部的Component对象，在Activity会自动创建Component对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NI</span> <span class="operator">=</span> a.intents.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;NI; j++) &#123;</span><br><span class="line">        PackageParser.<span class="type">ActivityIntentInfo</span> <span class="variable">intent</span> <span class="operator">=</span> a.intents.get(j); <span class="comment">// 获取Activity中设置的intent</span></span><br><span class="line">        addFilter(intent); <span class="comment">// 添加Intent过滤</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ServiceIntentResolver.addActivity()：将Package中极细获取的Service对象，保存在ArrayMap中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addService</span><span class="params">(PackageParser.Service s)</span> &#123;</span><br><span class="line">    mServices.put(s.getComponentName(), s); <span class="comment">//保存service</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NI</span> <span class="operator">=</span> s.intents.size();</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;NI; j++) &#123;</span><br><span class="line">        PackageParser.<span class="type">ServiceIntentInfo</span> <span class="variable">intent</span> <span class="operator">=</span> s.intents.get(j);</span><br><span class="line">        addFilter(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ProviderIntentResolver.addActivity()：将Package中极细获取的Provider对象，保存在ArrayMap中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addProvider</span><span class="params">(PackageParser.Provider p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mProviders.containsKey(p.getComponentName())) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mProviders.put(p.getComponentName(), p); <span class="comment">// 保存provider</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NI</span> <span class="operator">=</span> p.intents.size();</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; NI; j++) &#123;</span><br><span class="line">        PackageParser.<span class="type">ProviderIntentInfo</span> <span class="variable">intent</span> <span class="operator">=</span> p.intents.get(j);</span><br><span class="line">        addFilter(intent); <span class="comment">// 添加查找过滤的intent</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更新配置文件"><a href="#更新配置文件" class="headerlink" title="更新配置文件"></a>更新配置文件</h4><ul>
<li>mSettings.writeLPr（）：将mPackages中的数据分别写入package.xml和package.list文件中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">void</span> <span class="title function_">writeLPr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mSettingsFilename.exists()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mBackupSettingsFilename.exists()) &#123; <span class="comment">// 重命名文件</span></span><br><span class="line">                <span class="keyword">if</span> (!mSettingsFilename.renameTo(mBackupSettingsFilename)) &#123;</span><br><span class="line">                    Slog.wtf(PackageManagerService.TAG,</span><br><span class="line">                            <span class="string">&quot;Unable to backup package manager settings, &quot;</span></span><br><span class="line">                            + <span class="string">&quot; current changes will be lost at reboot&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mSettingsFilename.delete(); <span class="comment">//删除package文件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fstr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(mSettingsFilename);</span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fstr);</span><br><span class="line"> 。。。。。。</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">final</span> PackageSetting pkg : mPackages.values()) &#123;</span><br><span class="line"> writePackageLPr(serializer, pkg); <span class="comment">// 写入配置信息</span></span><br><span class="line"> &#125;</span><br><span class="line"> .......</span><br><span class="line">&#125;</span><br><span class="line">writePackageListLPr(); <span class="comment">// 更新package.list文件</span></span><br></pre></td></tr></table></figure>

<ol>
<li>先判断package.xml和backup.xml文件是否存在，如果两个都存在则删除package.xml</li>
<li>如果backup.xml文件不存在，则将package.xml重命名为backup。xml</li>
<li>创建新的package.xml文件，并将mSetting中的内容写入文件夹</li>
<li>删除backup文件，并重新生成package.list文件</li>
</ol>
<p>到此PMS的启动过程介绍完毕，简单来说系统在启动会会创建PMS对象，使用PMS对象读取配置文件，然后扫描手机上所有的app程序，并将所有的程序的内容信息都封装在Package对象中，然后将Package集合中信息转换为PMS的属性供系统使用，最后并更新配置文件；</p>
<h2 id="深入PMS源码（二）——-APK的安装和卸载源码分析"><a href="#深入PMS源码（二）——-APK的安装和卸载源码分析" class="headerlink" title="深入PMS源码（二）—— APK的安装和卸载源码分析"></a>深入PMS源码（二）—— APK的安装和卸载源码分析</h2><h3 id="应用程序安装基础"><a href="#应用程序安装基础" class="headerlink" title="应用程序安装基础"></a>应用程序安装基础</h3><ul>
<li>单个APK程序安装的过程</li>
</ul>
<ol>
<li>把原始的APk文件复制到程序相应的目录文件下，对于第三方app复制到&#x2F;data&#x2F;app&#x2F;目录下</li>
<li>为程序创建相应的数据目录、提取dex文件、修改系统包管理信息</li>
</ol>
<ul>
<li>程序安装过程</li>
</ul>
<ol>
<li>在程序目录下创建以包名称命名的程序apk文件File</li>
<li>在data&#x2F;data&#x2F;目录下创建应用程序的数据文件</li>
<li>将程序所有的信息写入到配置文件package.xml文件中</li>
</ol>
<ul>
<li>HandlerParams主要实现子类</li>
</ul>
<ol>
<li>InstallParams：完成要安装程序的Copy工作</li>
<li>MoveParams：实现对已安装程序移动到外部保存目录中</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HandlerParams</span> &#123; <span class="comment">// 抽象类</span></span><br><span class="line"><span class="number">4676</span>        <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX_RETRIES</span> <span class="operator">=</span> <span class="number">4</span>; <span class="comment">// 最多重试4次</span></span><br><span class="line"><span class="number">4677</span>        <span class="type">int</span> <span class="variable">retry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">4678</span>        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">startCopy</span><span class="params">()</span> &#123; <span class="comment">// 提供文件Copy方法</span></span><br><span class="line"><span class="number">4679</span>            <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">4681</span>                retry++;</span><br><span class="line"><span class="number">4682</span>                <span class="keyword">if</span> (retry &gt; MAX_RETRIES) &#123; <span class="comment">// 尝试超过4次报错</span></span><br><span class="line"><span class="number">4684</span>                    mHandler.sendEmptyMessage(MCS_GIVE_UP); <span class="comment">// 超过4次后发送报错信息，回调错误方法</span></span><br><span class="line"><span class="number">4685</span>                    handleServiceError();</span><br><span class="line"><span class="number">4686</span>                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="number">4687</span>                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">4688</span>                    handleStartCopy(); <span class="comment">// 子类需重写，执行文件复制操作</span></span><br><span class="line">                        res = <span class="literal">true</span>;</span><br><span class="line"><span class="number">4691</span>                &#125;</span><br><span class="line"><span class="number">4692</span>            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line"><span class="number">4694</span>                mHandler.sendEmptyMessage(MCS_RECONNECT);</span><br><span class="line"><span class="number">4695</span>            &#125;</span><br><span class="line"><span class="number">4696</span>            handleReturnCode();</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line"><span class="number">4697</span>        &#125;</span><br><span class="line"><span class="number">4699</span>        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">serviceError</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">4701</span>            handleServiceError();</span><br><span class="line"><span class="number">4702</span>            handleReturnCode();</span><br><span class="line"><span class="number">4703</span>        &#125;</span><br><span class="line"><span class="number">4704</span>        <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleStartCopy</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException; <span class="comment">// 抽象方法</span></span><br><span class="line"><span class="number">4705</span>        <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleServiceError</span><span class="params">()</span>;</span><br><span class="line"><span class="number">4706</span>        <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleReturnCode</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>由上面源码知道，HandlerParams是抽象类，内部提供程序文件的复制功能，执行将安装的apk文件复制到程序的制定安装位置，程序调用startCopy（）后开始执行文件赋值，具体赋值调用抽象方法handleStartCopy（），所以具体的功能子类需要重写此方法，在copy发生异常时会发送Handler消息实现重试，最多重试4次后抛出异常；</p>
<h3 id="PMS中APK安装过程"><a href="#PMS中APK安装过程" class="headerlink" title="PMS中APK安装过程"></a>PMS中APK安装过程</h3><p>程序的安装执行到PMS中后，从Packagemanager的installpackage（）方法开始，间接调用到PMS中installStage（）函数，installStage（）中首先创建InstallParams对象，保存要安装的文件URI和其他信息，然后发送INIT_COPY异步消息启动文件复制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">installStage</span><span class="params">(….)</span> &#123;</span><br><span class="line"><span class="number">4590</span>        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(INIT_COPY); <span class="comment">// 创建INIT_COPY消息</span></span><br><span class="line"><span class="number">4591</span>        msg.obj = <span class="keyword">new</span> <span class="title class_">InstallParams</span>(packageURI, observer, flags,</span><br><span class="line"><span class="number">4592</span>                installerPackageName); <span class="comment">// 创建InstallParams对象封装安装包属性信息</span></span><br><span class="line"><span class="number">4593</span>        mHandler.sendMessage(msg);</span><br><span class="line"><span class="number">4594</span>    &#125;</span><br></pre></td></tr></table></figure>

<p>Handler在处理INIT_COPY消息时，根据mBound变量确定是否绑定了MSC服务，未绑定的先调用connectToService（）执行绑定过程，然后将HandlerParams加入mPendingInstalls集合中等待执行，在服务绑定后发送MCS_BOUND消息，对于已经绑定的直接发送MSC_BOUND事件执行任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (!mBound) &#123; <span class="comment">// 1、判断服务是否绑定</span></span><br><span class="line"><span class="number">457</span>                        <span class="keyword">if</span> (!connectToService()) &#123; <span class="comment">// 2、执行Service绑定</span></span><br><span class="line"><span class="number">459</span>                            params.serviceError();</span><br><span class="line"><span class="number">460</span>                            <span class="keyword">return</span>;</span><br><span class="line"><span class="number">461</span>                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">464</span>                            mPendingInstalls.add(idx, params); <span class="comment">// 3、添加要执行的任务</span></span><br><span class="line"><span class="number">465</span>                        &#125;</span><br><span class="line"><span class="number">466</span>                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">467</span>                        mPendingInstalls.add(idx, params); <span class="comment">// 3、添加任务</span></span><br><span class="line"><span class="number">470</span>                        <span class="keyword">if</span> (idx == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">471</span>                            mHandler.sendEmptyMessage(MCS_BOUND); <span class="comment">// 4、就一个事件时，直接发送事件立即执行</span></span><br><span class="line"><span class="number">472</span>                        &#125;</span><br><span class="line"><span class="number">473</span>                    &#125;</span><br></pre></td></tr></table></figure>

<p>在处理MCS_BOUND消息时，使用获取的Binder服务从mPendingInstalls列表中取出安装信息HandlerParams类中，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (msg.obj != <span class="literal">null</span>) &#123;</span><br><span class="line">mContainerService = (IMediaContainerService) msg.obj; <span class="comment">// 1、获取对应的服务</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">HandlerParams</span> <span class="variable">params</span> <span class="operator">=</span> mPendingInstalls.get(<span class="number">0</span>); <span class="comment">// 2、取出要安装的参数</span></span><br><span class="line"><span class="keyword">if</span> (params != <span class="literal">null</span>) &#123;</span><br><span class="line">If（params.startCopy()）&#123; <span class="comment">// 3、执行Copy文件，最终执行到FileInstallArgs.copyApk()</span></span><br><span class="line">    <span class="keyword">if</span> (mPendingInstalls.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mPendingInstalls.remove(<span class="number">0</span>);  <span class="comment">// 删除集合中的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Handler处理事件时，从消息msg中获取IMediaContainerService服务对象，并从mPendingInstalls集合中获取要执行的任务，此处获取的是前面创建的InstallParams对象，然后调用params.startCopy()方法执行文件复制，按照HandlerParams的源码程序会调用InstallParams.handleStartCopy()方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InstallParams：实现全新安装时的复制过程</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">InstallParams</span> <span class="keyword">extends</span> <span class="title class_">HandlerParams</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleStartCopy</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">            mArgs = createInstallArgs(<span class="built_in">this</span>); <span class="comment">// 1、</span></span><br><span class="line"><span class="number">4834</span>        <span class="keyword">if</span> (ret == PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line"><span class="number">4837</span>        ret = mArgs.copyApk(mContainerService, <span class="literal">true</span>); <span class="comment">// 2、</span></span><br><span class="line"><span class="number">4838</span>        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在InstallParams中主要执行两个过程：</p>
<ol>
<li>根据Params类型创建InstallerArgs对象保存请求数据</li>
<li>调用InstallArgs.copyApk()方法实现复制</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> InstallArgs <span class="title function_">createInstallArgs</span><span class="params">(InstallParams params)</span> &#123;</span><br><span class="line"><span class="number">4931</span>        <span class="keyword">if</span> (installOnSd(params.flags)) &#123;</span><br><span class="line"><span class="number">4932</span>            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SdInstallArgs</span>(params);<span class="comment">//复制到外部存储时使用</span></span><br><span class="line"><span class="number">4933</span>        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">4934</span>            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FileInstallArgs</span>(params); <span class="comment">// 复制到内部存储时使用，在FileInstallArgs内部调用IMediaContainerService服务执行Copy过程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InstallArgs本身是一个抽象类，内部包含了很多属性信息，它的实现类主要有两个FileInstallArgs和SdInstallArgs，FileInstallArgs主要实现将文件复制到内部存储，而SdInstallArgs执行复制到外部文件存储，这里会创建FileInstallArgs对象，在FileInstallArgs.copy()中直接调用doCopyApk（）；</p>
<ul>
<li>FileInstallArgs.copyApk（）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">doCopyApk</span><span class="params">(IMediaContainerService imcs, <span class="type">boolean</span> temp)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line"><span class="comment">// 1、创建临时文件路径：data/app/vmd.sessionId.tmp 文件目录</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">File</span> <span class="variable">tempDir</span> <span class="operator">=</span> mInstallerService.allocateStageDirLegacy(volumeUuid, isEphemeral);</span><br><span class="line">codeFile = tempDir;</span><br><span class="line">resourceFile = tempDir;</span><br><span class="line"><span class="keyword">final</span> <span class="type">IParcelFileDescriptorFactory</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IParcelFileDescriptorFactory</span>.Stub() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ParcelFileDescriptor <span class="title function_">open</span><span class="params">(String name, <span class="type">int</span> mode)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(codeFile, name); <span class="comment">// 创建apk文件</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">FileDescriptor</span> <span class="variable">fd</span> <span class="operator">=</span> Os.open(file.getAbsolutePath(),</span><br><span class="line">                    O_RDWR | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">            Os.chmod(file.getAbsolutePath(), <span class="number">0644</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ParcelFileDescriptor</span>(fd); <span class="comment">//2、以临时File创建ParcelFileDescriptor对象，用于进程通信</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 3、调用IMS方法实现文件Copy，将apk文件复制到temp文件中，然后将tmp文件复制到data/app/下，删除临时tmp文件</span></span><br><span class="line">ret = imcs.copyPackage(origin.file.getAbsolutePath(), target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在doCopyApk（）中，首先在data&#x2F;app&#x2F;目录下创建临时目录data&#x2F;app&#x2F;vmd.sessionId.tmp 文件，然后实例化IParcelFileDescriptorFactory.Stub()对象，并以临时文件File创建ParcelFileDescriptor类用于Binder通信，最后调用imcs.copyPackage（）执行文件复制，这里imcs实际是DefaultContainerService的对象；</p>
<ul>
<li>DefaultContainerService.copyPackage（）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">File</span> <span class="variable">packageFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(packagePath); <span class="comment">// 1、获取要复制的apk文件</span></span><br><span class="line">pkg = PackageParser.parsePackageLite(packageFile, <span class="number">0</span>); <span class="comment">// 2、parser程序包</span></span><br><span class="line"><span class="keyword">return</span> copyPackageInner(pkg, target); <span class="comment">// 3、执行文件复制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">copyPackageInner</span><span class="params">(PackageLite pkg, IParcelFileDescriptorFactory target)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, RemoteException &#123;</span><br><span class="line">    copyFile(pkg.baseCodePath, target, <span class="string">&quot;base.apk”); // 1、复制apk文件</span></span><br><span class="line"><span class="string">    if (!ArrayUtils.isEmpty(pkg.splitNames)) &#123;</span></span><br><span class="line"><span class="string">        for (int i = 0; i &lt; pkg.splitNames.length; i++) &#123;</span></span><br><span class="line"><span class="string">            copyFile(pkg.splitCodePaths[i], target, &quot;</span>split_<span class="string">&quot; + pkg.splitNames[i] + &quot;</span>.apk”); <span class="comment">// 2、复制拆分的apk</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> PackageManager.INSTALL_SUCCEEDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在copyPackage（）方法中，首先根据文件路径获取apk文件，调用PackageParser解析apk文件，这里的解析主要是看apk是否包含split apk，然后调用copyPackageInner执行文件复制工作，在copyPackageInner中调用copyFile（）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(String sourcePath, IParcelFileDescriptorFactory target, String targetName)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, RemoteException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        in = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(sourcePath);</span><br><span class="line">        out = <span class="keyword">new</span> <span class="title class_">ParcelFileDescriptor</span>.AutoCloseOutputStream(</span><br><span class="line">        target.open(targetName, ParcelFileDescriptor.MODE_READ_WRITE)); <span class="comment">// 回调target</span></span><br><span class="line">        FileUtils.copy(in, out); <span class="comment">// 执行文件复制，在tmp/base.apk/</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoUtils.closeQuietly(out);</span><br><span class="line">        IoUtils.closeQuietly(in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在copyFile（）中，首先回调target的open（）方法完成ParcelFileDescriptor的创建，然后调用FileUtils.copy（）方法，将apk文件复制到tmp&#x2F;base.apk&#x2F;中，由前面的HandlerParam知道apk复制成功之后，回调InstallParams.handleReturnCode（），handleReturnCode（）中直接调用processPendingInstall（）方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processPendingInstall</span><span class="params">(<span class="keyword">final</span> InstallArgs args, <span class="keyword">final</span> <span class="type">int</span> currentStatus)</span> &#123;</span><br><span class="line">    mHandler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; <span class="comment">//1、mHandler发送延时任务</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            mHandler.removeCallbacks(<span class="built_in">this</span>); <span class="comment">//移除其它任务</span></span><br><span class="line">            <span class="type">PackageInstalledInfo</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageInstalledInfo</span>();</span><br><span class="line">            res.setReturnCode(currentStatus);</span><br><span class="line">            res.uid = -<span class="number">1</span>;</span><br><span class="line">            res.pkg = <span class="literal">null</span>;</span><br><span class="line">            res.removedInfo = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">                args.doPreInstall(res.returnCode); <span class="comment">//2、执行安装前处理</span></span><br><span class="line">                <span class="keyword">synchronized</span> (mInstallLock) &#123;</span><br><span class="line">                    installPackageTracedLI(args, res); <span class="comment">//3、执行安装和解析</span></span><br><span class="line">                &#125;</span><br><span class="line">                args.doPostInstall(res.returnCode, res.uid);<span class="comment">//4、执行安装后的扫尾工作</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在processPendingInstall（）中直接发送handler事件执行APK的安装工作，在Handler事件中首先创建PackageInstalledInfo对象，保存安装的状态，在复制成功后执行以下操作：</p>
<ol>
<li>调用args.doPreInstall（）执行安装apk前准备；</li>
<li>调用installPackageTracedLI(args, res)执行apk的解析和安装工作</li>
<li>调用args.doPostInstall（）执行apk文件安装完成后的工作</li>
</ol>
<ul>
<li>args.doPreInstall(res.returnCode)：如果复制状态不为Success，则清除复制的文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">doPreInstall</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (status != PackageManager.INSTALL_SUCCEEDED) &#123;<span class="comment">//未复制成功清除文件</span></span><br><span class="line">        cleanUp();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>installPackageTracedLI（）中直接调用installPackageLI（）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">installPackageLI</span><span class="params">(InstallArgs args, PackageInstalledInfo res)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">installFlags</span> <span class="operator">=</span> args.installFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">installerPackageName</span> <span class="operator">=</span> args.installerPackageName;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">File</span> <span class="variable">tmpPackageFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(args.getCodePath());</span><br><span class="line">    <span class="type">PackageParser</span> <span class="variable">pp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageParser</span>();</span><br><span class="line">    pkg = pp.parsePackage(tmpPackageFile, parseFlags); <span class="comment">// 1、解析apk文件</span></span><br><span class="line"><span class="comment">//检查apk</span></span><br><span class="line"><span class="comment">//校验签名</span></span><br><span class="line"><span class="comment">// 2、/data/app/vmdl18300388.tmp/base.apk，重命名为/data/app/包名-1/base.apk。</span></span><br><span class="line"><span class="keyword">if</span> (!args.doRename(res.returnCode, pkg, oldCodePath)) &#123; </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (replace) &#123;</span><br><span class="line">replacePackageLIF(pkg, parseFlags, scanFlags, args.user,</span><br><span class="line">            installerPackageName, res, args.installReason); <span class="comment">// 3、替换apk</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">installNewPackageLIF(pkg, parseFlags, scanFlags | SCAN_DELETE_DATA_ON_FAILURES,</span><br><span class="line">        args.user, installerPackageName, volumeUuid, res, args.installReason); <span class="comment">// 3、安装新的apk</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在installPackageLI（）中主要执行以下操作：</p>
<ol>
<li>创建PackageParser对象解析复制的临时apk文件；</li>
<li>检查复制的apk文件并校验签名信息等；</li>
<li>将复制的apk文件目录，重命名为以包名为目录的文件</li>
<li>确认是已安装的apk更新还是新安装的app，对于新安装的app执行installNewPackageLIF（）方法</li>
</ol>
<ul>
<li>installNewPackageLIF（）：安装新的apk</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PackageParser.<span class="type">Package</span> <span class="variable">newPackage</span> <span class="operator">=</span> scanPackageTracedLI(pkg, parseFlags, scanFlags, <span class="comment">// 重新扫描apk文件</span></span><br><span class="line">        System.currentTimeMillis(), user);</span><br><span class="line">updateSettingsLI(newPackage, installerPackageName, <span class="literal">null</span>, res, user, installReason); <span class="comment">// 更新Setting</span></span><br><span class="line"><span class="keyword">if</span> (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">    prepareAppDataAfterInstallLIF(newPackage); <span class="comment">// 为安装好的App准备数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在installNewPackageLIF（）中首先调用scanPackageTracedLI（）重新扫描apk文件，scanPackageTracedLI内部会调用scanPackageNewLI（）提交解析结果，将解析的结果Package对象添加到PMS的属性中，详细流程参见深入PMS源码（一）—— PMS的启动过程和执行流程，在安装完成后调用updateSettingsLI（）更新mSetting属性，最后调用prepareAppDataAfterInstallLIF（）为新安装的程序准备数据；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scannedPkg = scanPackageNewLI(pkg, parseFlags, scanFlags, currentTime, user);</span><br></pre></td></tr></table></figure>

<p>到此程序的安装就完成了，上面主要介绍了Android系统是如何实现安装和文件复制的，在复制完成后，就会向PMS启动过程一样解析和处理apk文件；</p>
<h3 id="应用程序的卸载过程"><a href="#应用程序的卸载过程" class="headerlink" title="应用程序的卸载过程"></a>应用程序的卸载过程</h3><ul>
<li>应用程序的卸载</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">packageManager.packageInstaller.uninstall() <span class="comment">//卸载程序</span></span><br></pre></td></tr></table></figure>

<p>由深入PMS源码（一）—— PMS的启动过程和执行流程分析知道此处packageManager获取的是ApplicationPackageManager，而packageInstaller是在ApplicationPackageManager内部实例化的PackageInstaller的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PackageInstaller <span class="title function_">getPackageInstaller</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mInstaller == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mInstaller = <span class="keyword">new</span> <span class="title class_">PackageInstaller</span>(mPM.getPackageInstaller(),</span><br><span class="line">                            mContext.getPackageName(), mContext.getUserId());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mInstaller;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在创建PackageInstaller对象中，调用mPM.getPackageInstaller()调用PMS中方法获取PackageInstallerService对象，并将其封装在PackageInstaller对象中，程序继续调用PackageInstaller.uninstall()中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uninstall</span><span class="params">(<span class="meta">@NonNull</span> String packageName, <span class="meta">@DeleteFlags</span> <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> IntentSender statusReceiver)</span> &#123;</span><br><span class="line">        uninstall(<span class="keyword">new</span> <span class="title class_">VersionedPackage</span>(packageName, PackageManager.VERSION_CODE_HIGHEST),</span><br><span class="line">                flags, statusReceiver);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>uninstall（）中首先根据传入的包名创建VersionedPackage对象，然后继续调用uninstall的重载方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiresPermission(anyOf = &#123;</span></span><br><span class="line"><span class="meta">           Manifest.permission.DELETE_PACKAGES,</span></span><br><span class="line"><span class="meta">           Manifest.permission.REQUEST_DELETE_PACKAGES&#125;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uninstall</span><span class="params">(<span class="meta">@NonNull</span> VersionedPackage versionedPackage, <span class="meta">@DeleteFlags</span> <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">           <span class="meta">@NonNull</span> IntentSender statusReceiver)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           mInstaller.uninstall(versionedPackage, mInstallerPackageName,</span><br><span class="line">                   flags, statusReceiver, mUserId); <span class="comment">//2、</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在uninstall（）中直接调用mInstaller.uninstall()，这里的mInstaller对象就是在创建PackageInstaller时传入的第一个参数，即PMS中实例话的PackageInstallerService对象，PackageInstallerService实现了IPackageInstaller.Stub类，可用于进程间通信</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackageInstallerService</span> <span class="keyword">extends</span> <span class="title class_">IPackageInstaller</span>.Stub &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uninstall</span><span class="params">(VersionedPackage versionedPackage, String callerPackageName, <span class="type">int</span> flags,IntentSender statusReceiver, <span class="type">int</span> userId)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">         mPermissionManager.enforceCrossUserPermission(callingUid, userId, <span class="literal">true</span>, <span class="literal">true</span>, <span class="string">&quot;uninstall&quot;</span>); <span class="comment">// 1、检查权限</span></span><br><span class="line">          <span class="keyword">final</span> <span class="type">PackageDeleteObserverAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageDeleteObserverAdapter</span>(mContext,</span><br><span class="line">                statusReceiver, versionedPackage.getPackageName(),</span><br><span class="line">                isDeviceOwnerOrAffiliatedProfileOwner, userId);  <span class="comment">//2、</span></span><br><span class="line">                     </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DELETE_PACKAGES)== PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            mPm.deletePackageVersioned(versionedPackage, adapter.getBinder(), userId, flags);</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在PackageInstallerService.install（）权限中，主要执行3个流程：</p>
<ol>
<li>创建PackageDeleteObserverAdapter对象，用于接收响应删除的结果</li>
<li>检查当前程序是否具有删除权限</li>
<li>调用PMS的deletePackageVersioned（）方法执行程序的卸载</li>
</ol>
<p>从上面分析应用程序真正开始卸载，是从PackageManager的deletePackageAsUser（）函数开始，间接调用PMS的deletePackageVersioned（）方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deletePackageVersioned</span><span class="params">(VersionedPackage versionedPackage,</span></span><br><span class="line"><span class="params">  <span class="keyword">final</span> IPackageDeleteObserver2 observer, <span class="keyword">final</span> <span class="type">int</span> userId, <span class="keyword">final</span> <span class="type">int</span> deleteFlags)</span> &#123;</span><br><span class="line">              mHandler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; <span class="comment">//发送Handler事件</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                mHandler.removeCallbacks(<span class="built_in">this</span>); <span class="comment">// 移除事件</span></span><br><span class="line">                <span class="type">int</span> returnCode;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">PackageSetting</span> <span class="variable">ps</span> <span class="operator">=</span> mSettings.mPackages.get(internalPackageName);<span class="comment">//获取PackageSettings对象</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">doDeletePackage</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (ps != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">targetIsInstantApp</span> <span class="operator">=</span></span><br><span class="line">                            ps.getInstantApp(UserHandle.getUserId(callingUid));</span><br><span class="line">                    doDeletePackage = !targetIsInstantApp</span><br><span class="line">                            || canViewInstantApps;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (doDeletePackage) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!deleteAllUsers) &#123;</span><br><span class="line">                        returnCode = deletePackageX(internalPackageName, versionCode,</span><br><span class="line">                                userId, deleteFlags);</span><br><span class="line">                    &#125; </span><br><span class="line">               &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">       observer.onPackageDeleted(packageName, returnCode, <span class="literal">null</span>);<span class="comment">// 删除后回调</span></span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在deletePackageVersioned（）中发送Post事件执行异步删除操作，在Handler事件中调用deletePackageX（）方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="title function_">deletePackageX</span><span class="params">(String packageName, <span class="type">long</span> versionCode, <span class="type">int</span> userId, <span class="type">int</span> deleteFlags)</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">PackageRemovedInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageRemovedInfo</span>(<span class="built_in">this</span>);</span><br><span class="line">   <span class="keyword">if</span> (isPackageDeviceAdmin(packageName, removeUser)) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Not removing package &quot;</span> + packageName + <span class="string">&quot;: has active device admin&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> PackageManager.DELETE_FAILED_DEVICE_POLICY_MANAGER;</span><br><span class="line">        &#125;</span><br><span class="line">info.origUsers = uninstalledPs.queryInstalledUsers(allUsers, <span class="literal">true</span>);</span><br><span class="line"> res = deletePackageLIF(packageName, UserHandle.of(removeUser), <span class="literal">true</span>, allUsers,</span><br><span class="line">                        deleteFlags | PackageManager.DELETE_CHATTY, info, <span class="literal">true</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在deletePackageX（）中首先判断要卸载的程序是否是admin管理的，如果是则直接return，如果不是则执行deletePackageLIF（）方法继续卸载程序</p>
<ul>
<li>deletePackageLIF（）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> p = mPackages.get(packageName); <span class="comment">//1、获取保存应用程序的Package对象</span></span><br><span class="line"><span class="keyword">if</span> (isSystemApp(p)) &#123;</span><br><span class="line">ret = deleteSystemPackageLI(p, flags, outInfo, writeSettings); <span class="comment">//2、如果是系统app</span></span><br><span class="line"><span class="number">6376</span>        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 3、处理第三方app卸载</span></span><br><span class="line">ret = deleteInstalledPackageLIF(p, deleteCodeAndResources, flags, outInfo,</span><br><span class="line"><span class="number">6381</span>                    writeSettings);</span><br><span class="line"><span class="number">6382</span>        &#125;</span><br></pre></td></tr></table></figure>

<p>deletePackageLIF（）中根据app类型区分系统app和第三方app，执行不同的卸载程序，对于第三方app执行deleteInstalledPackageLIF（）方法，在deleteInstalledPackageLIF（）中也是直接调用removePackageDataLI（）</p>
<ul>
<li>removePackageDataLIF（）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removePackageDataLI</span><span class="params">(PackageParser.Package p, PackageRemovedInfo outInfo,<span class="type">int</span> flags, <span class="type">boolean</span> writeSettings)</span> &#123;</span><br><span class="line"><span class="number">6183</span>        <span class="type">String</span> <span class="variable">packageName</span> <span class="operator">=</span> p.packageName;</span><br><span class="line"><span class="number">6187</span>        removePackageLI(p, (flags&amp;REMOVE_CHATTY) != <span class="number">0</span>); <span class="comment">// 1、移除mPackages集合中保存的package对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; PackageManager.DELETE_KEEP_DATA) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> PackageParser.Package resolvedPkg;</span><br><span class="line">                resolvedPkg = <span class="keyword">new</span> <span class="title class_">PackageParser</span>.Package(ps.name);</span><br><span class="line">                resolvedPkg.setVolumeUuid(ps.volumeUuid);</span><br><span class="line">            &#125;</span><br><span class="line">            destroyAppDataLIF(resolvedPkg, UserHandle.USER_ALL,</span><br><span class="line">                    StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE); <span class="comment">// 2、调用Installer执行清除/data/app/目录下的文件信息</span></span><br><span class="line">            destroyAppProfilesLIF(resolvedPkg, UserHandle.USER_ALL);</span><br><span class="line">            <span class="comment">//3、发送包清理事件</span></span><br><span class="line">            schedulePackageCleaning(packageName, UserHandle.USER_ALL, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">6210</span>        <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line"><span class="number">6211</span>            <span class="keyword">if</span> (deletedPs != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="number">6212</span>                <span class="keyword">if</span> ((flags&amp;PackageManager.DONT_DELETE_DATA) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">6213</span>                    <span class="keyword">if</span> (outInfo != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="number">6214</span>                        outInfo.removedUid = mSettings.removePackageLPw(packageName); <span class="comment">// 4、移除mSetting中保存的数据</span></span><br><span class="line"><span class="number">6215</span>                    &#125;</span><br><span class="line"><span class="number">6216</span>                    <span class="keyword">if</span> (deletedPs != <span class="literal">null</span>) &#123;</span><br><span class="line">                                mHandler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;<span class="comment">//5、发送事件杀死进程信息</span></span><br><span class="line">                                        killApplication(deletedPs.name, deletedPs.appId,</span><br><span class="line">                                                KILL_APP_REASON_GIDS_CHANGED);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line"><span class="number">6221</span>                        &#125;</span><br><span class="line"><span class="number">6222</span>                    &#125;</span><br><span class="line"><span class="number">6223</span>                &#125; </span><br><span class="line">  <span class="keyword">if</span> (writeSettings) &#123;</span><br><span class="line">    mSettings.writeLPr(); <span class="comment">// 6、写入mSettings信息，更新Package.xml文件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在removePackageDataLIF（）方法中执行了卸载删除的重要操作，具体如下：</p>
<ol>
<li>调用removePackageLI（）删除mPackages集合中保存的次apk的解析对象Package，在removePackageLI中会调用cleanPackageDataStructuresLILPw（），删除此PMS中保存的此应用程序中的四大组件信息</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">void</span> <span class="title function_">cleanPackageDataStructuresLILPw</span><span class="params">(PackageParser.Package pkg, <span class="type">boolean</span> chatty)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> pkg.providers.size();</span><br><span class="line">         <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">            PackageParser.<span class="type">Provider</span> <span class="variable">p</span> <span class="operator">=</span> pkg.providers.get(i);</span><br><span class="line">            mProviders.removeProvider(p);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        N = pkg.services.size();</span><br><span class="line">        r = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">            PackageParser.<span class="type">Service</span> <span class="variable">s</span> <span class="operator">=</span> pkg.services.get(i);</span><br><span class="line">            mServices.removeService(s);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>调用destroyAppDataLIF（）方法，使用Installer删除此应用程序&#x2F;data&#x2F;app&#x2F;目录下的安装包信息</li>
<li>调用schedulePackageCleaning（）发送START_CLEANING_PACKAGE事件执行外部使用数据删除</li>
<li>删除mSetting中保存此程序的PackageSetting对象</li>
<li>发送Handler事件调用killApplication（）杀死应用进程</li>
<li>调用mSettings.writeLPr()将mSettings信息写入配置文件package.xml中</li>
</ol>
<ul>
<li>destroyAppDataLIF（）</li>
</ul>
<p>在destroyAppDataLIF（）中直接调用destroyAppDataLeafLIF（）方法，destroyAppDataLeafLIF中主要调用mInstaller中方法执行删除，删除应用数据之后调用mDexManager通知删除结束；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">destroyAppDataLeafLIF</span><span class="params">(PackageParser.Package pkg, <span class="type">int</span> userId, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> PackageSetting ps;</span><br><span class="line">        <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">            ps = mSettings.mPackages.get(pkg.packageName);<span class="comment">//获取PackageSetting对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> realUserId : resolveUserIds(userId)) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ceDataInode</span> <span class="operator">=</span> (ps != <span class="literal">null</span>) ? ps.getCeDataInode(realUserId) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123; <span class="comment">// 调用mInstaller执行文件数据删除</span></span><br><span class="line">        mInstaller.destroyAppData(pkg.volumeUuid, pkg.packageName, realUserId, flags,</span><br><span class="line">                        ceDataInode);</span><br><span class="line">            &#125; </span><br><span class="line">        mDexManager.notifyPackageDataDestroyed(pkg.packageName, userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>schedulePackageCleaning（）：执行mSetting中信息和程序数据文件的删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">schedulePackageCleaning</span><span class="params">(String packageName, <span class="type">int</span> userId, <span class="type">boolean</span> andCode)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(START_CLEANING_PACKAGE,</span><br><span class="line">                userId, andCode ? <span class="number">1</span> : <span class="number">0</span>, packageName); <span class="comment">// 创建Message对象</span></span><br><span class="line">            msg.sendToTarget(); <span class="comment">// 发送事件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> START_CLEANING_PACKAGE: &#123;</span><br><span class="line">                    Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">packageName</span> <span class="operator">=</span> (String)msg.obj;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">userId</span> <span class="operator">=</span> msg.arg1;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">andCode</span> <span class="operator">=</span> msg.arg2 != <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">                            mSettings.addPackageToCleanLPw(</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">PackageCleanItem</span>(userId, packageName, andCode));</span><br><span class="line">                                    &#125;          Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">startCleaningPackages();</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>在schedulePackageCleaning（）创建Message对象并发送事件，在Handler处理事件时首先调用mSetting将要删除的信息保存在Settings的mPackagesToBeCleaned集合中，然后调用startCleaningPackages（）启动本地服务DefaultContainerService服务，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onHandleIntent</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (PackageManager.ACTION_CLEAN_EXTERNAL_STORAGE.equals(intent.getAction())) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">IPackageManager</span> <span class="variable">pm</span> <span class="operator">=</span> IPackageManager.Stub.asInterface(</span><br><span class="line">                    ServiceManager.getService(<span class="string">&quot;package&quot;</span>)); <span class="comment">// 获取PMS对象</span></span><br><span class="line">            <span class="type">PackageCleanItem</span> <span class="variable">item</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ((item = pm.nextPackageToClean(item)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">UserEnvironment</span> <span class="variable">userEnv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserEnvironment</span>(item.userId);</span><br><span class="line">   <span class="comment">//删除/Android/data/xxxx/下文件信息</span></span><br><span class="line">eraseFiles(userEnv.buildExternalStorageAppDataDirs(item.packageName));</span><br><span class="line">   <span class="comment">//删除/Android/media/xxxx/下文件信息</span></span><br><span class="line">eraseFiles(userEnv.buildExternalStorageAppMediaDirs(item.packageName));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在本地服务的onHandleIntent（）中调用PMS的nextPackageToClean（）获取刚才加入的mSetting中的mPackagesToBeCleaned集合，并遍历集合一次从中取出要卸载删除的数据包，并获取文件路径执行eraseFiles（）删除文件；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">eraseFiles</span><span class="params">(File path)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.isDirectory()) &#123;</span><br><span class="line">            String[] files = path.list();</span><br><span class="line">            <span class="keyword">if</span> (files != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String file : files) &#123;</span><br><span class="line">                    eraseFiles(<span class="keyword">new</span> <span class="title class_">File</span>(path, file)); <span class="comment">// 递归删除目录下文件</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.delete(); <span class="comment">// 删除数据</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>到此应用程序的app安装文件和使用中产生的数据文件都已被删除，且配置文件已更新完成，此时会回调deletePackageVersioned（）中的 observer.onPackageDeleted(packageName, returnCode, null)方法通知删除结果，这里回调的是PackageDeleteObserverAdapter类中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPackageDeleted</span><span class="params">(String basePackageName, <span class="type">int</span> returnCode, String msg)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (PackageManager.DELETE_SUCCEEDED == returnCode &amp;&amp; mNotification != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">NotificationManager</span> <span class="variable">notificationManager</span> <span class="operator">=</span> (NotificationManager)</span><br><span class="line">                        mContext.getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">                notificationManager.notify(basePackageName,</span><br><span class="line">                        SystemMessage.NOTE_PACKAGE_STATE,</span><br><span class="line">                        mNotification);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Intent</span> <span class="variable">fillIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">            fillIn.putExtra(PackageInstaller.EXTRA_PACKAGE_NAME, mPackageName);</span><br><span class="line">            fillIn.putExtra(PackageInstaller.EXTRA_STATUS,</span><br><span class="line">                    PackageManager.deleteStatusToPublicStatus(returnCode));</span><br><span class="line">            fillIn.putExtra(PackageInstaller.EXTRA_STATUS_MESSAGE,</span><br><span class="line">                    PackageManager.deleteStatusToString(returnCode, msg));</span><br><span class="line">            fillIn.putExtra(PackageInstaller.EXTRA_LEGACY_STATUS, returnCode);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mTarget.sendIntent(mContext, <span class="number">0</span>, fillIn, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SendIntentException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在onPackageDeleted（）中，首先调用NotificationManager中方法发送notify（）通知安装成功，然后创建Intent对象并回调mTarget.sendIntent（），这里的mTarget对象其实就是卸载最开始时调用uninstall（）方法传入的第二个参数，即IntentSender对象，用于接收删除的结果；</p>
<h2 id="深入PMS源码（三）——-PMS中intent-filter的匹配架构"><a href="#深入PMS源码（三）——-PMS中intent-filter的匹配架构" class="headerlink" title="深入PMS源码（三）—— PMS中intent-filter的匹配架构"></a>深入PMS源码（三）—— PMS中intent-filter的匹配架构</h2><p>由前面<strong>深入PMS源码（一）—— PMS的启动过程和执行流程和深入PMS源码（二）—— APK的安装和卸载源码分析</strong>两篇文章知道，无论是Android系统启动后执行的PMS启动，还是使用PackageInstaller安装APK的过程，最终都会使用PackageParser扫描相应的apk文件，将扫描提取的信息保在Package对象中，扫描完成后会回调PMS中方法将扫描获取的四大组件信息转换保存在PMS属性中，主要使用ActivityIntentResolver、ServiceIntentResolver、ProviderIntentResolver保存信息，这里会有两个问题：</p>
<ol>
<li>系统是按照何种方式保存这些属性的对应关系？保存这些属性又是如何使用的？</li>
<li>我们启动Activity只是创建了Intent对象，然后调用Context中的启动方法而已，那系统是如何查找到目标活动的信息的呢？</li>
</ol>
<h3 id="PMS保存IntentFilter"><a href="#PMS保存IntentFilter" class="headerlink" title="PMS保存IntentFilter"></a>PMS保存IntentFilter</h3><p>下面带着这两个问题，从源码的角度探讨下PMS中的intent-filter的匹配架构，接着PMS的启动过程中分析，对四大组件处理代码如下，这里已对Activity的处理为例分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">N = pkg.activities.size();</span><br><span class="line"><span class="number">3503</span>            r = <span class="literal">null</span>;</span><br><span class="line"><span class="number">3504</span>            <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line"><span class="number">3505</span>                PackageParser.<span class="type">Activity</span> <span class="variable">a</span> <span class="operator">=</span> pkg.activities.get(i);</span><br><span class="line"><span class="number">3506</span>                a.info.processName = fixProcessName(pkg.applicationInfo.processName,</span><br><span class="line"><span class="number">3507</span>                        a.info.processName, pkg.applicationInfo.uid);</span><br><span class="line"><span class="number">3508</span>                mActivities.addActivity(a, <span class="string">&quot;activity&quot;</span>); <span class="comment">//调用ActivityIntentResolver.addActivity（）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActivityIntentResolver.addActivity()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addActivity</span><span class="params">(PackageParser.Activity a, String type)</span> &#123;</span><br><span class="line">    mActivities.put(a.getComponentName(), a); <span class="comment">// 1、获取内部的Component对象，在Activity会自动创建Component对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NI</span> <span class="operator">=</span> a.intents.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;NI; j++) &#123;</span><br><span class="line">        PackageParser.<span class="type">ActivityIntentInfo</span> <span class="variable">intent</span> <span class="operator">=</span> a.intents.get(j); <span class="comment">// 获取Activity中设置的intent</span></span><br><span class="line">        addFilter(intent); <span class="comment">// 添加Intent过滤</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从解析得到的Package对象中获取每个创建的Activity对象，然后调用ActivityIntentResolver.addActivity（）方法将Activity对象保存在ActivityIntentResolver.mActivities集合中，在程序的最后几行代码中会遍历a.intents的集合，取出每个ActivityIntentInfo信息调用addFilter（）添加Intent过滤信息，这里的ActivityIntentInfo是在PackageParser解析标签中创建的对象并添加到a.intents的集合中，也就是说每个Activity标签下定义的标签都对应一个ActivityIntentInfo对象，且所有的对象都保存在a.intents的集合中，在介绍addFilter（）方法前先介绍下IntentResolver类；</p>
<ul>
<li>IntentResolver</li>
</ul>
<ol>
<li>作用：IntentResolver主要用于保存程序中设置的和相应的ActivityRecord的对应关系，并在使用时提供查找机制</li>
<li>实现原理：IntentResolver会按照中的每个特性（如action、type）等分别创建HashMap，并在解析时保存相应的对象，在查找时取出要匹配的Component对象的action、type，然后再各自的ArrayMap中获取其保存对象的集合，此时获取到的是多个集合其中包含重复信息，然后对所有的集合取交集并去重，最终得到完全匹配的对象；</li>
<li>IntentResolver属性如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">IntentResolver</span>&lt;F <span class="keyword">extends</span> <span class="title class_">IntentFilter</span>, R <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArraySet&lt;F&gt; mFilters = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;F&gt;(); <span class="comment">//保存所有的intent对应的匹配对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayMap&lt;String, F[]&gt; mTypeToFilter = <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;String, F[]&gt;(); <span class="comment">//保存Type 匹配的Intent集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayMap&lt;String, F[]&gt; mBaseTypeToFilter = <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;String, F[]&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayMap&lt;String, F[]&gt; mWildTypeToFilter = <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;String, F[]&gt;();<span class="comment">// 保存所有带“*”通配符类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayMap&lt;String, F[]&gt; mSchemeToFilter = <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;String, F[]&gt;(); <span class="comment">//已注册所有Uri方案</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayMap&lt;String, F[]&gt; mActionToFilter = <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;String, F[]&gt;();<span class="comment">//保存所有指定Action 的Intent集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayMap&lt;String, F[]&gt; mTypedActionToFilter = <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;String, F[]&gt;(); <span class="comment">// 匹配已注册且指定Mime Type类型Intent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的IntentResolver是一个范型，内部储存者IntentFilter的子类，而ActivityIntentInfo继承IntentInfo，IntentInfo又继承于IntentFilter类，所以此处直接保存的就是ActivityIntentInfo对象，在IntentFilter中保存着设置的多个属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> mPriority; <span class="comment">// 优先级</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> mOrder; <span class="comment">// 层级</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;String&gt; mActions;  <span class="comment">// 设置的actions集合</span></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;String&gt; mCategories = <span class="literal">null</span>; <span class="comment">// 设置categories集合</span></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;String&gt; mDataSchemes = <span class="literal">null</span>; <span class="comment">// 数据集合</span></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;PatternMatcher&gt; mDataSchemeSpecificParts = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;AuthorityEntry&gt; mDataAuthorities = <span class="literal">null</span>; <span class="comment">// 匹配权限</span></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;PatternMatcher&gt; mDataPaths = <span class="literal">null</span>; <span class="comment">// 匹配数据path</span></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;String&gt; mDataTypes = <span class="literal">null</span>; <span class="comment">// 数据类型</span></span><br></pre></td></tr></table></figure>

<ul>
<li>addFilter（）：添加匹配意图</li>
</ul>
<p>添加PMS扫描获得的可匹配的IntentFilter对象，在PMS解析时将每个Activity中设置的标签中信息保存在一个IntentFilter对象中，在IntentFilter中保存着标签下所有的action、type、scheme、categories的集合，在addFilter（）时将这些集合中数据取出作为Key，将包含相同Key的Intent-Filter保存在数组中，然后以Key为键将这些集合存储在Intent-Resolve的ArrayMap中；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFilter</span><span class="params">(F f)</span> &#123;</span><br><span class="line">    mFilters.add(f); <span class="comment">// 在总的Filter中保存数据</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numS</span> <span class="operator">=</span> register_intent_filter(f, f.schemesIterator(),</span><br><span class="line">            mSchemeToFilter, <span class="string">&quot;      Scheme: “); // 判断数据uri，保存在mSchemeToFilter集合中</span></span><br><span class="line"><span class="string">    int numT = register_mime_types(f, &quot;</span>      Type: “); <span class="comment">//判断baseType 和 mWildType 类型</span></span><br><span class="line">    <span class="keyword">if</span> (numS == <span class="number">0</span> &amp;&amp; numT == <span class="number">0</span>) &#123; </span><br><span class="line">        register_intent_filter(f, f.actionsIterator(),</span><br><span class="line">                mActionToFilter, <span class="string">&quot;      Action: “); // 判断匹配action对应的</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    if (numT != 0) &#123;</span></span><br><span class="line"><span class="string">        register_intent_filter(f, f.actionsIterator(),</span></span><br><span class="line"><span class="string">                mTypedActionToFilter, &quot;</span>      TypedAction: “); <span class="comment">// 添加mTypedActionToFilter集合</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在addFilter（）中首先将传入的intent-filter对象保存在mFilters中，也就是说mFilters中保存着所有的匹配对象，然后依次调用register_intent_filter（）、register_mime_types（）、register_intent_filter（）、register_intent_filter（）方法分别解析IntentFilter对象中的属性信息，并保存在相应的HashMap中，这里以register_intent_filter（）为例，register_intent_filter中传入的是f.actionsIterator()对象，即获取是actions集合的迭代器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">register_intent_filter</span><span class="params">(F filter, Iterator&lt;String&gt; i, ArrayMap&lt;String, F[]&gt; dest, String prefix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i.hasNext()) &#123;   <span class="comment">// 遍历Iterator</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> i.next();   <span class="comment">// 取出数据集合DataSchemes下一个数据</span></span><br><span class="line">        num++;</span><br><span class="line">        addFilter(dest, name, filter);   <span class="comment">// 添加到对应的Filter集合中，此处为mSchemeToFilter集合数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在register_intent_filter中使用迭代器遍历每个action，然后取出每个action标签下设置的name属性，调用addFilter（）方法执行保存，在addFilter（）中传入要保存的相应的ArrayMap对象，如action对应的就是mActionToFilter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addFilter</span><span class="params">(ArrayMap&lt;String, F[]&gt; map, String name, F filter)</span> &#123;</span><br><span class="line">    F[] array = map.get(name);    <span class="comment">// 根据name的名称去除保存数据的数组</span></span><br><span class="line">    <span class="keyword">if</span> (array == <span class="literal">null</span>) &#123;</span><br><span class="line">        array = newArray(<span class="number">2</span>);    <span class="comment">// 创建数组</span></span><br><span class="line">        map.put(name,  array);    <span class="comment">// 保存数据</span></span><br><span class="line">        array[<span class="number">0</span>] = filter;    <span class="comment">// 保存filter</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> N;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; array[i-<span class="number">1</span>] == <span class="literal">null</span>) &#123; <span class="comment">// 遍历寻找为null的位置</span></span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; N) &#123;</span><br><span class="line">            array[i] = filter;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            F[] newa = newArray((N*<span class="number">3</span>)/<span class="number">2</span>); <span class="comment">// 原数组长度不够，扩展原数组长度</span></span><br><span class="line">            System.arraycopy(array, <span class="number">0</span>, newa, <span class="number">0</span>, N);</span><br><span class="line">            newa[N] = filter;</span><br><span class="line">            map.put(name, newa);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addFilter（）的执行逻辑很简单：</p>
<ol>
<li>首先根据传入的name从相应的集合中获取数组，如果不存在则创建新数组，此时直接保存IntentFilter对象；</li>
<li>如果已经存在数组遍历循转数组中空位置，如果存在将IntentFilter对象保存在数组中；</li>
<li>如果不存在则扩展数组长度，然后保存IntentFilter数据；</li>
<li>最后将保存IntentFilter数据的数组添加到对应的ArrayMap中；</li>
</ol>
<p>到此程序中注册的四大组件和相应的信息都会保存在IntentResolver类中，在使用时只需要根据设置的条件去查找匹配的对象即可；</p>
<h3 id="IntentFilter的查找匹配"><a href="#IntentFilter的查找匹配" class="headerlink" title="IntentFilter的查找匹配"></a>IntentFilter的查找匹配</h3><p>查询匹配方式：IntentResolver查询时分别从请求的Intent中取出数据（如：action、mime、scheme），然后分别以每个数据变量为Key，取出每个相应的ArrayMao中保存的对应的IntentFilter数组，最后求去这些数组的交集并去重，达到精准匹配的目的，最后返回匹配的所有ResolveInfo集合；</p>
<p>一般在查找是否能匹配意图时，会调用packageManager.queryIntentActivities(intent,flag)查找匹配的IntentResolve，这里的packageManager对象实际调用ApplicationPackageManager对象，程序进入ApplicationPackageManager中，在ApplicationPackageManager.queryIntentActivities()中直接调用了queryIntentActivitiesAsUser（）</p>
<ul>
<li>ApplicationPackageManager</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;ResolveInfo&gt; <span class="title function_">queryIntentActivitiesAsUser</span><span class="params">(Intent intent,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> flags, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    ParceledListSlice&lt;ResolveInfo&gt; parceledList = </span><br><span class="line">    mPM.queryIntentActivities(intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(mContext.getContentResolver()),</span><br><span class="line">                        flags, userId);<span class="number">2</span>、</span><br><span class="line">        <span class="keyword">return</span> parceledList.getList();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在queryIntentActivitiesAsUser（）中调用PMS中方法查询匹配Intent，PMS.queryIntentActivities()中间接调用queryIntentActivitiesInternal（）方法</p>
<ul>
<li>queryIntentActivitiesInternal（）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!sUserManager.exists(userId)) <span class="keyword">return</span> Collections.emptyList(); <span class="comment">// 判断userId</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">instantAppPkgName</span> <span class="operator">=</span> getInstantAppPackageName(filterCallingUid); <span class="comment">// 获取userId对应的进程包名</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">pkgName</span> <span class="operator">=</span> intent.getPackage(); <span class="comment">// 获取Intent中携带的包名</span></span><br><span class="line"><span class="type">ComponentName</span> <span class="variable">comp</span> <span class="operator">=</span> intent.getComponent(); <span class="comment">// 获取Component对象</span></span><br><span class="line"><span class="keyword">final</span> List&lt;ResolveInfo&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ResolveInfo&gt;(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="type">ActivityInfo</span> <span class="variable">ai</span> <span class="operator">=</span> getActivityInfo(comp, flags, userId); <span class="comment">// 首先从PMs中保存的mActivites集合中获取ActivityInfo信息</span></span><br><span class="line">result = filterIfNotSystemUser(mActivities.queryIntent( <span class="comment">// 从mActivities中查询匹配的List&lt;ResolveInfo&gt;</span></span><br><span class="line">        intent, resolvedType, flags, userId), userId);</span><br></pre></td></tr></table></figure>

<p>在queryIntentActivitiesInternal（）方法中：</p>
<ol>
<li>首先判断当前用于的userId，如果不存在则直接返回空集合；</li>
<li>从请求的Intent中获取包含的Component对象；</li>
<li>如果Component不为空说明此时是显示启动，直接调用首先从PMs中保存的mActivites集合中获取ActivityInfo信息；</li>
<li>对于Component为空的则调用mActivities.queryIntent（）匹配能处理的ActivityInfo对象；</li>
</ol>
<ul>
<li>ActivityIntentResolve.queryIntent（）中直接调用父类IntentResolve.queryIntent（），方法执行到IntentResolve.queryIntent（）中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;R&gt; <span class="title function_">queryIntent</span><span class="params">(Intent intent, String resolvedType, <span class="type">boolean</span> defaultOnly,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> userId)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">scheme</span> <span class="operator">=</span> intent.getScheme(); <span class="comment">// 获取scheme</span></span><br><span class="line">ArrayList&lt;R&gt; finalList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;R&gt;();</span><br><span class="line">F[] firstTypeCut = <span class="literal">null</span>;   <span class="comment">//保存匹配的结果</span></span><br><span class="line">F[] secondTypeCut = <span class="literal">null</span>;</span><br><span class="line">F[] thirdTypeCut = <span class="literal">null</span>;</span><br><span class="line">F[] schemeCut = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (scheme != <span class="literal">null</span>) &#123;</span><br><span class="line">    schemeCut = mSchemeToFilter.get(scheme); <span class="comment">// 1、先根据scheme匹配,获取匹配的数组</span></span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">final</span> <span class="type">String</span> <span class="variable">baseType</span> <span class="operator">=</span> resolvedType.substring(<span class="number">0</span>, slashpos);</span><br><span class="line">    <span class="keyword">if</span> (!baseType.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (resolvedType.length() != slashpos+<span class="number">2</span></span><br><span class="line">                || resolvedType.charAt(slashpos+<span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            firstTypeCut = mTypeToFilter.get(resolvedType); <span class="comment">// 根据type匹配</span></span><br><span class="line">            secondTypeCut = mWildTypeToFilter.get(baseType);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            firstTypeCut = mBaseTypeToFilter.get(baseType);</span><br><span class="line">            secondTypeCut = mWildTypeToFilter.get(baseType);</span><br><span class="line">        &#125;</span><br><span class="line">        thirdTypeCut = mWildTypeToFilter.get(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (intent.getAction() != <span class="literal">null</span>) &#123;</span><br><span class="line">        firstTypeCut = mTypedActionToFilter.get(intent.getAction());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (resolvedType == <span class="literal">null</span> &amp;&amp; scheme == <span class="literal">null</span> &amp;&amp; intent.getAction() != <span class="literal">null</span>) &#123;</span><br><span class="line">    firstTypeCut = mActionToFilter.get(intent.getAction()); <span class="comment">// 2、根据action匹配</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (firstTypeCut != <span class="literal">null</span>) &#123;</span><br><span class="line">    buildResolveList(intent, categories, debug, defaultOnly, resolvedType,</span><br><span class="line">            scheme, firstTypeCut, finalList, userId); <span class="comment">// 不断进行匹配</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (secondTypeCut != <span class="literal">null</span>) &#123;</span><br><span class="line">    buildResolveList(intent, categories, debug, defaultOnly, resolvedType,</span><br><span class="line">            scheme, secondTypeCut, finalList, userId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (thirdTypeCut != <span class="literal">null</span>) &#123;</span><br><span class="line">    buildResolveList(intent, categories, debug, defaultOnly, resolvedType,</span><br><span class="line">            scheme, thirdTypeCut, finalList, userId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (schemeCut != <span class="literal">null</span>) &#123;</span><br><span class="line">    buildResolveList(intent, categories, debug, defaultOnly, resolvedType,</span><br><span class="line">            scheme, schemeCut, finalList, userId);</span><br><span class="line">&#125;</span><br><span class="line">sortResults(finalList); <span class="comment">// 将数组中元素按照优先级排序</span></span><br><span class="line"><span class="keyword">return</span> finalList; <span class="comment">// 返回最终匹配的结果集合</span></span><br></pre></td></tr></table></figure>

<p>在queryIntent（）中首先从Intent中取出所有属性信息，如action、scheme等，然后创建四个数组对象，这四个数组主要保存根据Intent中设置的属性查找出对应的数组，之后从每个ArrayMap中匹配返回相应的数组，然后根据四个数数组是否存在数据从而多此执行buildResolveList（）方法，buildResolveList主要是获取四个数组中保存的IntentFilter对象转换为输出的对象，然后执行sortResults（）其中的重复对象此时即可返回最终匹配结果；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildResolveList</span><span class="params">(Intent intent, FastImmutableArraySet&lt;String&gt; categories,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> debug, <span class="type">boolean</span> defaultOnly, String resolvedType, String scheme,</span></span><br><span class="line"><span class="params">        F[] src, List&lt;R&gt; dest, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> src != <span class="literal">null</span> ? src.length : <span class="number">0</span>;</span><br><span class="line">F filter;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N &amp;&amp; (filter=src[i]) != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">match = filter.match(action, resolvedType, scheme, data, categories, TAG);</span><br><span class="line"><span class="keyword">if</span> (match &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!defaultOnly || filter.hasCategory(Intent.CATEGORY_DEFAULT)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">R</span> <span class="variable">oneResult</span> <span class="operator">=</span> newResult(filter, match, userId); <span class="comment">// 将filter转换为 ResolveInfo </span></span><br><span class="line">        <span class="keyword">if</span> (oneResult != <span class="literal">null</span>) &#123;</span><br><span class="line">            dest.add(oneResult); <span class="comment">// 保存到dest集合中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述的匹配过程之后即可获取到所有的可处理请求的Activity对象，然后将其中的信息设置在Intent之后再执行请求，此时就是像动态启动Activity一样直接启动目标活动；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(intentToResolve);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">intent.setClassName(ris.get(<span class="number">0</span>).activityInfo.packageName,</span><br><span class="line">ris.get(<span class="number">0</span>).activityInfo.name); </span><br><span class="line"><span class="keyword">return</span> intent；</span><br></pre></td></tr></table></figure>

<p>到此PMS中关于保存IntentFilter和静态启动过程中的匹配过程介绍完毕了，通过上面的学习相信对PMS如何处理apk文件和系统如何识别要启动的程序或活动有了更深的理解，本篇也是PMS系列的最后一篇，希望整个系列的分析对大家学习有所帮助；</p>
<h1 id="WMS"><a href="#WMS" class="headerlink" title="WMS"></a>WMS</h1><h2 id="WMS（一）：WMS的诞生"><a href="#WMS（一）：WMS的诞生" class="headerlink" title="WMS（一）：WMS的诞生"></a>WMS（一）：WMS的诞生</h2><p>此前我用多篇文章介绍了WindowManager，这个系列我们来介绍WindowManager的管理者WMS，首先我们先来学习WMS是如何产生的。本文源码基于Android 8.0，与Android  7.1.2相比有一个比较直观的变化就是Java FrameWork采用了Lambda表达式。</p>
<h3 id="WMS概述"><a href="#WMS概述" class="headerlink" title="WMS概述"></a>WMS概述</h3><p>WMS是系统的其他服务，无论对于应用开发还是Framework开发都是重点的知识，它的职责有很多，主要有以下几点：</p>
<h4 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h4><p>WMS是窗口的管理者，它负责窗口的启动、添加和删除，另外窗口的大小和层级也是由WMS进行管理的。窗口管理的核心成员有DisplayContent、WindowToken和WindowState。</p>
<h4 id="窗口动画"><a href="#窗口动画" class="headerlink" title="窗口动画"></a>窗口动画</h4><p>窗口间进行切换时，使用窗口动画可以显得更炫一些，窗口动画由WMS的动画子系统来负责，动画子系统的管理者为WindowAnimator。</p>
<h4 id="输入系统的中转站"><a href="#输入系统的中转站" class="headerlink" title="输入系统的中转站"></a>输入系统的中转站</h4><p>通过对窗口的触摸从而产生触摸事件，InputManagerService（IMS）会对触摸事件进行处理，它会寻找一个最合适的窗口来处理触摸反馈信息，WMS是窗口的管理者，因此，WMS“理所应当”的成为了输入系统的中转站。</p>
<h4 id="Surface管理"><a href="#Surface管理" class="headerlink" title="Surface管理"></a>Surface管理</h4><p>窗口并不具备有绘制的功能，因此每个窗口都需要有一块Surface来供自己绘制。为每个窗口分配Surface是由WMS来完成的。</p>
<p>WMS的职责可以简单总结为下图。</p>
<p><img src="https://s2.ax1x.com/2019/05/28/VexIGd.png" alt="img"></p>
<h3 id="WMS的诞生"><a href="#WMS的诞生" class="headerlink" title="WMS的诞生"></a>WMS的诞生</h3><p>WMS的知识点非常多，在了解这些知识点前，我们十分有必要知道WMS是如何产生的。WMS是在SyetemServer进程中启动的，不了解SyetemServer进程的可以查看在<a href="https://link.juejin.cn/?target=http://liuwangshu.cn/framework/booting/3-syetemserver.html">Android系统启动流程（三）解析SyetemServer进程启动过程</a>这篇文章。<br>先来查看SyetemServer的main方法：<br><strong>frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;SystemServer.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">SystemServer</span>().run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main方法中只调用了SystemServer的run方法，如下所示。<br><strong>frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;SystemServer.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">          System.loadLibrary(<span class="string">&quot;android_servers&quot;</span>);<span class="comment">//1</span></span><br><span class="line">          ...</span><br><span class="line">          mSystemServiceManager = <span class="keyword">new</span> <span class="title class_">SystemServiceManager</span>(mSystemContext);<span class="comment">//2</span></span><br><span class="line">          mSystemServiceManager.setRuntimeRestarted(mRuntimeRestart);</span><br><span class="line">          LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line">          <span class="comment">// Prepare the thread pool for init tasks that can be parallelized</span></span><br><span class="line">          SystemServerInitThreadPool.get();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          traceEnd();  <span class="comment">// InitBeforeStartServices</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          traceBeginAndSlog(<span class="string">&quot;StartServices&quot;</span>);</span><br><span class="line">          startBootstrapServices();<span class="comment">//3</span></span><br><span class="line">          startCoreServices();<span class="comment">//4</span></span><br><span class="line">          startOtherServices();<span class="comment">//5</span></span><br><span class="line">          SystemServerInitThreadPool.shutdown();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">          Slog.e(<span class="string">&quot;System&quot;</span>, <span class="string">&quot;******************************************&quot;</span>);</span><br><span class="line">          Slog.e(<span class="string">&quot;System&quot;</span>, <span class="string">&quot;************ Failure starting system services&quot;</span>, ex);</span><br><span class="line">          <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          traceEnd();</span><br><span class="line">      &#125;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>run方法代码很多，这里截取了关键的部分，在注释1处加载了libandroid_servers.so。在注释2处创建SystemServiceManager，它会对系统的服务进行创建、启动和生命周期管理。接下来的代码会启动系统的各种服务，在注释3中的startBootstrapServices方法中用SystemServiceManager启动了ActivityManagerService、PowerManagerService、PackageManagerService等服务。在注释4处的方法中则启动了BatteryService、UsageStatsService和WebViewUpdateService。注释5处的startOtherServices方法中则启动了CameraService、AlarmManagerService、VrManagerService等服务，这些服务的父类为SystemService。从注释3、4、5的方法名称可以看出，官方把大概80多个系统服务分为了三种类型，分别是引导服务、核心服务和其他服务，其中其他服务为一些非紧要和一些不需要立即启动的服务，WMS就是其他服务的一种。<br>我们来查看startOtherServices方法是如何启动WMS的：</p>
<p><strong>frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;SystemServer.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startOtherServices</span><span class="params">()</span> &#123;</span><br><span class="line"> ...</span><br><span class="line">            traceBeginAndSlog(<span class="string">&quot;InitWatchdog&quot;</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Watchdog</span> <span class="variable">watchdog</span> <span class="operator">=</span> Watchdog.getInstance();<span class="comment">//1</span></span><br><span class="line">            watchdog.init(context, mActivityManagerService);<span class="comment">//2</span></span><br><span class="line">            traceEnd();</span><br><span class="line">            traceBeginAndSlog(<span class="string">&quot;StartInputManagerService&quot;</span>);</span><br><span class="line">            inputManager = <span class="keyword">new</span> <span class="title class_">InputManagerService</span>(context);<span class="comment">//3</span></span><br><span class="line">            traceEnd();</span><br><span class="line">            traceBeginAndSlog(<span class="string">&quot;StartWindowManagerService&quot;</span>);</span><br><span class="line">            ConcurrentUtils.waitForFutureNoInterrupt(mSensorServiceStart, START_SENSOR_SERVICE);</span><br><span class="line">            mSensorServiceStart = <span class="literal">null</span>;</span><br><span class="line">            wm = WindowManagerService.main(context, inputManager,</span><br><span class="line">                    mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,</span><br><span class="line">                    !mFirstBoot, mOnlyCore, <span class="keyword">new</span> <span class="title class_">PhoneWindowManager</span>());<span class="comment">//4</span></span><br><span class="line">            ServiceManager.addService(Context.WINDOW_SERVICE, wm);<span class="comment">//5</span></span><br><span class="line">            ServiceManager.addService(Context.INPUT_SERVICE, inputManager);<span class="comment">//6</span></span><br><span class="line">            traceEnd();   </span><br><span class="line">           ... </span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">            wm.displayReady();<span class="comment">//7</span></span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            reportWtf(<span class="string">&quot;making display ready&quot;</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">           ...</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">            wm.systemReady();<span class="comment">//8</span></span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            reportWtf(<span class="string">&quot;making Window Manager Service ready&quot;</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">            ...      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>startOtherServices方法用于启动其他服务，其他服务大概有70多个，上面的代码只列出了WMS以及和它相关的IMS的启动逻辑，剩余的其他服务的启动逻辑也都大同小异。<br>在注释1、2处分别得到Watchdog实例并对它进行初始化，Watchdog用来监控系统的一些关键服务的运行状况，后文会再次提到它。在注释3处创建了IMS，并赋值给IMS类型的inputManager对象。注释4处执行了WMS的main方法，其内部会创建WMS，需要注意的是main方法其中一个传入的参数就是注释1处创建的IMS，WMS是输入事件的中转站，其内部包含了IMS引用并不意外。结合上文，我们可以得知WMS的main方法是运行在SystemServer的run方法中，换句话说就是运行在”system_server”线程”中，后面会再次提到”system_server”线程。<br>注释5和注释6处分别将WMS和IMS注册到ServiceManager中，这样如果某个客户端想要使用WMS，就需要先去ServiceManager中查询信息，然后根据信息与WMS所在的进程建立通信通路，客户端就可以使用WMS了。注释7处用来初始化显示信息，注释8处则用来通知WMS，系统的初始化工作已经完成，其内部调用了WindowManagerPolicy的systemReady方法。<br>我们来查看注释4处WMS的main方法，如下所示。<br><strong>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService .java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> WindowManagerService <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> InputManagerService im,</span></span><br><span class="line"><span class="params">           <span class="keyword">final</span> <span class="type">boolean</span> haveInputMethods, <span class="keyword">final</span> <span class="type">boolean</span> showBootMsgs, <span class="keyword">final</span> <span class="type">boolean</span> onlyCore,</span></span><br><span class="line"><span class="params">           WindowManagerPolicy policy)</span> &#123;</span><br><span class="line">       DisplayThread.getHandler().runWithScissors(() -&gt;<span class="comment">//1</span></span><br><span class="line">               sInstance = <span class="keyword">new</span> <span class="title class_">WindowManagerService</span>(context, im, haveInputMethods, showBootMsgs,</span><br><span class="line">                       onlyCore, policy), <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> sInstance;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在注释1处调用了DisplayThread的getHandler方法，用来得到DisplayThread的Handler实例。DisplayThread是一个单例的前台线程，这个线程用来处理需要低延时显示的相关操作，并只能由WindowManager、DisplayManager和InputManager实时执行快速操作。注释1处的runWithScissors方法中使用了Java8中的Lambda表达式，它等价于如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DisplayThread.getHandler().runWithScissors(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">         sInstance = <span class="keyword">new</span> <span class="title class_">WindowManagerService</span>(context, im, haveInputMethods, showBootMsgs,</span><br><span class="line">                    onlyCore, policy);<span class="comment">//2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>在注释2处创建了WMS的实例，这个过程运行在Runnable的run方法中，而Runnable则传入到了DisplayThread对应Handler的runWithScissors方法中，说明WMS的创建是运行在“android.display”线程中。需要注意的是，runWithScissors方法的第二个参数传入的是0，后面会提到。来查看Handler的runWithScissors方法里做了什么：</p>
<p><strong>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;Handler.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">runWithScissors</span><span class="params">(<span class="keyword">final</span> Runnable r, <span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;runnable must not be null&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout must be non-negative&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (Looper.myLooper() == mLooper) &#123;<span class="comment">//1</span></span><br><span class="line">           r.run();</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">BlockingRunnable</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlockingRunnable</span>(r);</span><br><span class="line">       <span class="keyword">return</span> br.postAndWait(<span class="built_in">this</span>, timeout);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>开头对传入的Runnable和timeout进行了判断，如果Runnable为null或者timeout小于0则抛出异常。注释1处根据每个线程只有一个Looper的原理来判断当前的线程（”system_server”线程）是否是Handler所指向的线程（”android.display”线程），如果是则直接执行Runnable的run方法，如果不是则调用BlockingRunnable的postAndWait方法，并将当前线程的Runnable作为参数传进去 ，BlockingRunnable是Handler的内部类，代码如下所示。<br><strong>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;Handler.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">BlockingRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Runnable mTask;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> mDone;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BlockingRunnable</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">            mTask = task;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mTask.run();<span class="comment">//1</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    mDone = <span class="literal">true</span>;</span><br><span class="line">                    notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">postAndWait</span><span class="params">(Handler handler, <span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!handler.post(<span class="built_in">this</span>)) &#123;<span class="comment">//2</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">expirationTime</span> <span class="operator">=</span> SystemClock.uptimeMillis() + timeout;</span><br><span class="line">                    <span class="keyword">while</span> (!mDone) &#123;</span><br><span class="line">                        <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> expirationTime - SystemClock.uptimeMillis();</span><br><span class="line">                        <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// timeout</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            wait(delay);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!mDone) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            wait();<span class="comment">//3</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注释2处将当前的BlockingRunnable添加到Handler的任务队列中。前面runWithScissors方法的第二个参数为0，因此timeout等于0，这样如果mDone为false的话会一直调用注释3处的wait方法使得当前线程（”system_server”线程）进入等待状态，那么等待的是哪个线程呢？我们往上看，注释1处，执行了传入的Runnable的run方法（运行在”android.display”线程），执行完毕后在finally代码块中将mDone设置为true，并调用notifyAll方法唤醒处于等待状态的线程，这样就不会继续调用注释3处的wait方法。因此得出结论，”system_server”线程线程等待的就是”android.display”线程，一直到”android.display”线程执行完毕再执行”system_server”线程，这是因为”android.display”线程内部执行了WMS的创建，显然WMS的创建优先级更高些。<br>WMS的创建就讲到这，最后我们来查看WMS的构造方法：</p>
<p><strong>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService .java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">WindowManagerService</span><span class="params">(Context context, InputManagerService inputManager,</span></span><br><span class="line"><span class="params">         <span class="type">boolean</span> haveInputMethods, <span class="type">boolean</span> showBootMsgs, <span class="type">boolean</span> onlyCore, WindowManagerPolicy policy)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    mInputManager = inputManager;<span class="comment">//1</span></span><br><span class="line">    ...</span><br><span class="line">     mDisplayManager = (DisplayManager)context.getSystemService(Context.DISPLAY_SERVICE);</span><br><span class="line">     mDisplays = mDisplayManager.getDisplays();<span class="comment">//2</span></span><br><span class="line">     <span class="keyword">for</span> (Display display : mDisplays) &#123;</span><br><span class="line">         createDisplayContentLocked(display);<span class="comment">//3</span></span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">      mActivityManager = ActivityManager.getService();<span class="comment">//4</span></span><br><span class="line">    ...</span><br><span class="line">     mAnimator = <span class="keyword">new</span> <span class="title class_">WindowAnimator</span>(<span class="built_in">this</span>);<span class="comment">//5</span></span><br><span class="line">     mAllowTheaterModeWakeFromLayout = context.getResources().getBoolean(</span><br><span class="line">             com.android.internal.R.bool.config_allowTheaterModeWakeFromWindowLayout);</span><br><span class="line">     LocalServices.addService(WindowManagerInternal.class, <span class="keyword">new</span> <span class="title class_">LocalService</span>());</span><br><span class="line">     initPolicy();<span class="comment">//6</span></span><br><span class="line">     <span class="comment">// Add ourself to the Watchdog monitors.</span></span><br><span class="line">     Watchdog.getInstance().addMonitor(<span class="built_in">this</span>);<span class="comment">//7</span></span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>注释1处用来保存传进来的IMS，这样WMS就持有了IMS的引用。注释2处通过DisplayManager的getDisplays方法得到Display数组（每个显示设备都有一个Display实例），接着遍历Display数组，在注释3处的createDisplayContentLocked方法会将Display封装成DisplayContent，DisplayContent用来描述一快屏幕。<br>注释4处得到AMS实例，并赋值给mActivityManager ，这样WMS就持有了AMS的引用。注释5处创建了WindowAnimator，它用于管理所有的窗口动画。注释6处初始化了窗口管理策略的接口类WindowManagerPolicy（WMP），它用来定义一个窗口策略所要遵循的通用规范。注释7处将自身也就是WMS通过addMonitor方法添加到Watchdog中，Watchdog用来监控系统的一些关键服务的运行状况（比如传入的WMS的运行状况），这些被监控的服务都会实现Watchdog.Monitor接口。Watchdog每分钟都会对被监控的系统服务进行检查，如果被监控的系统服务出现了死锁，则会杀死Watchdog所在的进程，也就是SystemServer进程。</p>
<p>查看注释6处的initPolicy方法，如下所示。<br><strong>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initPolicy</span><span class="params">()</span> &#123;</span><br><span class="line">     UiThread.getHandler().runWithScissors(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">             WindowManagerPolicyThread.set(Thread.currentThread(), Looper.myLooper());</span><br><span class="line">             mPolicy.init(mContext, WindowManagerService.<span class="built_in">this</span>, WindowManagerService.<span class="built_in">this</span>);<span class="comment">//1</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;, <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>initPolicy方法和此前讲的WMS的main方法的实现类似，注释1处执行了WMP的init方法，WMP是一个接口，init方法的具体实现在PhoneWindowManager（PWM）中。PWM的init方法运行在”android.ui”线程中，它的优先级要高于initPolicy方法所在的”android.display”线程，因此”android.display”线程要等PWM的init方法执行完毕后，处于等待状态的”android.display”线程才会被唤醒从而继续执行下面的代码。</p>
<p>在本文中共提到了3个线程，分别是”system_server”、”android.display”和”android.ui”，为了便于理解，下面给出这三个线程之间的关系。</p>
<p><img src="https://s2.ax1x.com/2019/05/28/VexoRA.png" alt="img"></p>
<p>“system_server”线程中会调用WMS的main方法，main方法中会创建WMS，创建WMS的过程运行在”android.display”线程中，它的优先级更高一些，因此要等创建WMS完毕后才会唤醒处于等待状态的”system_server”线程。<br>WMS初始化时会执行initPolicy方法，initPolicy方法会调用PWM的init方法，这个init方法运行在”android.ui”线程，并且优先级更高，因此要先执行完PWM的init方法后，才会唤醒处于等待状态的”android.display”线程。<br>PWM的init方法执行完毕后会接着执行运行在”system_server”线程的代码，比如本文前部分提到WMS的systemReady方法。</p>
<h2 id="WMS（二）：WMS的重要成员和Window的添加过程"><a href="#WMS（二）：WMS的重要成员和Window的添加过程" class="headerlink" title="WMS（二）：WMS的重要成员和Window的添加过程"></a>WMS（二）：WMS的重要成员和Window的添加过程</h2><p>在本系列的上一篇文章中，我们学习了WMS的诞生，WMS被创建后，它的重要的成员有哪些？Window添加过程的WMS部分做了什么呢？这篇文章会给你解答。</p>
<h3 id="WMS的重要成员"><a href="#WMS的重要成员" class="headerlink" title="WMS的重要成员"></a>WMS的重要成员</h3><p>所谓WMS的重要成员是指WMS中的重要的成员变量，如下所示。<br><strong>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> WindowManagerPolicy mPolicy;</span><br><span class="line"><span class="keyword">final</span> IActivityManager mActivityManager;</span><br><span class="line"><span class="keyword">final</span> ActivityManagerInternal mAmInternal;</span><br><span class="line"><span class="keyword">final</span> AppOpsManager mAppOps;</span><br><span class="line"><span class="keyword">final</span> DisplaySettings mDisplaySettings;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">final</span> ArraySet&lt;Session&gt; mSessions = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> <span class="type">WindowHashMap</span> <span class="variable">mWindowMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowHashMap</span>();</span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;AppWindowToken&gt; mFinishedStarting = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;AppWindowToken&gt; mFinishedEarlyAnim = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;AppWindowToken&gt; mWindowReplacementTimeouts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;WindowState&gt; mResizingWindows = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;WindowState&gt; mPendingRemove = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">WindowState[] mPendingRemoveTmp = <span class="keyword">new</span> <span class="title class_">WindowState</span>[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;WindowState&gt; mDestroySurface = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;WindowState&gt; mDestroyPreservedSurface = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">final</span> <span class="type">H</span> <span class="variable">mH</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">H</span>();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">final</span> WindowAnimator mAnimator;</span><br><span class="line">...</span><br><span class="line"> <span class="keyword">final</span> InputManagerService mInputManager</span><br></pre></td></tr></table></figure>

<p>这里列出了WMS的部分成员变量，下面分别对它们进行简单的介绍。</p>
<p> <strong>mPolicy：WindowManagerPolicy</strong><br>WindowManagerPolicy（WMP）类型的变量。WindowManagerPolicy是窗口管理策略的接口类，用来定义一个窗口策略所要遵循的通用规范，并提供了WindowManager所有的特定的UI行为。它的具体实现类为PhoneWindowManager，这个实现类在WMS创建时被创建。WMP允许定制窗口层级和特殊窗口类型以及关键的调度和布局。</p>
<p> <strong>mSessions：ArraySet</strong><br>ArraySet类型的变量，元素类型为Session。在<a href="https://link.juejin.cn/?target=http://liuwangshu.cn/framework/wm/3-add-window.html">Android解析WindowManager（三）Window的添加过程</a>这篇文章中我提到过Session，它主要用于进程间通信，其他的应用程序进程想要和WMS进程进行通信就需要经过Session，并且每个应用程序进程都会对应一个Session，WMS保存这些Session用来记录所有向WMS提出窗口管理服务的客户端。<br><strong>mWindowMap：WindowHashMap</strong><br>WindowHashMap类型的变量，WindowHashMap继承了HashMap，它限制了HashMap的key值的类型为IBinder，value值的类型为WindowState。WindowState用于保存窗口的信息，在WMS中它用来描述一个窗口。综上得出结论，mWindowMap就是用来保存WMS中各种窗口的集合。</p>
<p> <strong>mFinishedStarting：ArrayList</strong><br>ArrayList类型的变量，元素类型为AppWindowToken，它是WindowToken的子类。要想理解mFinishedStarting的含义，需要先了解WindowToken是什么。WindowToken主要有两个作用：</p>
<ul>
<li>可以理解为窗口令牌，当应用程序想要向WMS申请新创建一个窗口，则需要向WMS出示有效的WindowToken。AppWindowToken作为WindowToken的子类，主要用来描述应用程序的WindowToken结构，<br>应用程序中每个Activity都对应一个AppWindowToken。</li>
<li>WindowToken会将相同组件（比如Acitivity）的窗口（WindowState）集合在一起，方便管理。</li>
</ul>
<p>mFinishedStarting就是用于存储已经完成启动的应用程序窗口（比如Acitivity）的AppWindowToken的列表。<br>除了mFinishedStarting，还有类似的mFinishedEarlyAnim和mWindowReplacementTimeouts，其中mFinishedEarlyAnim存储了已经完成窗口绘制并且不需要展示任何已保存surface的应用程序窗口的AppWindowToken。mWindowReplacementTimeout存储了等待更换的应用程序窗口的AppWindowToken，如果更换不及时，旧窗口就需要被处理。</p>
<p> <strong>mResizingWindows：ArrayList</strong><br>ArrayList类型的变量，元素类型为WindowState。<br>mResizingWindows是用来存储正在调整大小的窗口的列表。与mResizingWindows类似的还有mPendingRemove、mDestroySurface和mDestroyPreservedSurface等等。其中mPendingRemove是在内存耗尽时设置的，里面存有需要强制删除的窗口。mDestroySurface里面存有需要被Destroy的Surface。mDestroyPreservedSurface里面存有窗口需要保存的等待销毁的Surface，为什么窗口要保存这些Surface？这是因为当窗口经历Surface变化时，窗口需要一直保持旧Surface，直到新Surface的第一帧绘制完成。</p>
<p> <strong>mAnimator：WindowAnimator</strong><br>WindowAnimator类型的变量，用于管理窗口的动画以及特效动画。</p>
<p> <strong>mH：H</strong><br>H类型的变量，系统的Handler类，用于将任务加入到主线程的消息队列中，这样代码逻辑就会在主线程中执行。</p>
<p> <strong>mInputManager：InputManagerService</strong><br>InputManagerService类型的变量，输入系统的管理者。InputManagerService（IMS）会对触摸事件进行处理，它会寻找一个最合适的窗口来处理触摸反馈信息，WMS是窗口的管理者，因此，WMS“理所应当”的成为了输入系统的中转站，WMS包含了IMS的引用不足为怪。</p>
<h3 id="Window的添加过程（WMS部分）"><a href="#Window的添加过程（WMS部分）" class="headerlink" title="Window的添加过程（WMS部分）"></a>Window的添加过程（WMS部分）</h3><p>我们知道Window的操作分为两大部分，一部分是WindowManager处理部分，另一部分是WMS处理部分，如下所示。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/26/d4cbb185457f36fd6fe1bd58e7470868~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<p>在<a href="https://link.juejin.cn/?target=http://liuwangshu.cn/framework/wm/3-add-window.html">Android解析WindowManager（三）Window的添加过程</a>这篇文章中，我讲解了Window的添加过程的WindowManager处理部分，这一篇文章我们接着来学习Window的添加过程的WMS部分。<br>无论是系统窗口还是Activity，它们的Window的添加过程都会调用WMS的addWindow方法，由于这个方法代码逻辑比较多，这里分为3个部分来阅读。<br><strong>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService.java</strong></p>
<h4 id="addWindow方法part1"><a href="#addWindow方法part1" class="headerlink" title="addWindow方法part1"></a>addWindow方法part1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addWindow</span><span class="params">(Session session, IWindow client, <span class="type">int</span> seq,</span></span><br><span class="line"><span class="params">            WindowManager.LayoutParams attrs, <span class="type">int</span> viewVisibility, <span class="type">int</span> displayId,</span></span><br><span class="line"><span class="params">            Rect outContentInsets, Rect outStableInsets, Rect outOutsets,</span></span><br><span class="line"><span class="params">            InputChannel outInputChannel)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] appOp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> mPolicy.checkAddPermission(attrs, appOp);<span class="comment">//1</span></span><br><span class="line">        <span class="keyword">if</span> (res != WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mDisplayReady) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Display has not been initialialized&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">DisplayContent</span> <span class="variable">displayContent</span> <span class="operator">=</span> mRoot.getDisplayContentOrCreate(displayId);<span class="comment">//2</span></span><br><span class="line">            <span class="keyword">if</span> (displayContent == <span class="literal">null</span>) &#123;</span><br><span class="line">                Slog.w(TAG_WM, <span class="string">&quot;Attempted to add window to a display that does not exist: &quot;</span></span><br><span class="line">                        + displayId + <span class="string">&quot;.  Aborting.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> WindowManagerGlobal.ADD_INVALID_DISPLAY;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (type &gt;= FIRST_SUB_WINDOW &amp;&amp; type &lt;= LAST_SUB_WINDOW) &#123;<span class="comment">//3</span></span><br><span class="line">                parentWindow = windowForClientLocked(<span class="literal">null</span>, attrs.token, <span class="literal">false</span>);<span class="comment">//4</span></span><br><span class="line">                <span class="keyword">if</span> (parentWindow == <span class="literal">null</span>) &#123;</span><br><span class="line">                    Slog.w(TAG_WM, <span class="string">&quot;Attempted to add window with token that is not a window: &quot;</span></span><br><span class="line">                          + attrs.token + <span class="string">&quot;.  Aborting.&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (parentWindow.mAttrs.type &gt;= FIRST_SUB_WINDOW</span><br><span class="line">                        &amp;&amp; parentWindow.mAttrs.type &lt;= LAST_SUB_WINDOW) &#123;</span><br><span class="line">                    Slog.w(TAG_WM, <span class="string">&quot;Attempted to add window with token that is a sub-window: &quot;</span></span><br><span class="line">                            + attrs.token + <span class="string">&quot;.  Aborting.&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WMS的addWindow返回的是addWindow的各种状态，比如添加Window成功，无效的display等等，这些状态被定义在WindowManagerGlobal中。<br>注释1处根据Window的属性，调用WMP的checkAddPermission方法来检查权限，具体的实现在PhoneWindowManager的checkAddPermission方法中，如果没有权限则不会执行后续的代码逻辑。注释2处通过displayId来获得窗口要添加到哪个DisplayContent上，如果没有找到DisplayContent，则返回WindowManagerGlobal.ADD_INVALID_DISPLAY这一状态，其中DisplayContent用来描述一块屏幕。注释3处，type代表一个窗口的类型，它的数值介于FIRST_SUB_WINDOW和LAST_SUB_WINDOW之间（1000~1999），这个数值定义在WindowManager中，说明这个窗口是一个子窗口，不了解窗口类型取值范围的请阅读<a href="https://link.juejin.cn/?target=http://liuwangshu.cn/framework/wm/2-window-property.html">Android解析WindowManager（二）Window的属性</a>这篇文章。注释4处，attrs.token是IBinder类型的对象，windowForClientLocked方法内部会根据attrs.token作为key值从mWindowMap中得到该子窗口的父窗口。接着对父窗口进行判断，如果父窗口为null或者type的取值范围不正确则会返回错误的状态。</p>
<h4 id="addWindow方法part2"><a href="#addWindow方法part2" class="headerlink" title="addWindow方法part2"></a>addWindow方法part2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">         <span class="type">AppWindowToken</span> <span class="variable">atoken</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">         <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">hasParent</span> <span class="operator">=</span> parentWindow != <span class="literal">null</span>;</span><br><span class="line">         <span class="type">WindowToken</span> <span class="variable">token</span> <span class="operator">=</span> displayContent.getWindowToken(</span><br><span class="line">                 hasParent ? parentWindow.mAttrs.token : attrs.token);<span class="comment">//1</span></span><br><span class="line">         <span class="keyword">final</span> <span class="type">int</span> <span class="variable">rootType</span> <span class="operator">=</span> hasParent ? parentWindow.mAttrs.type : type;<span class="comment">//2</span></span><br><span class="line">         <span class="type">boolean</span> <span class="variable">addToastWindowRequiresToken</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (token == <span class="literal">null</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (rootType &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; rootType &lt;= LAST_APPLICATION_WINDOW) &#123;</span><br><span class="line">                 Slog.w(TAG_WM, <span class="string">&quot;Attempted to add application window with unknown token &quot;</span></span><br><span class="line">                       + attrs.token + <span class="string">&quot;.  Aborting.&quot;</span>);</span><br><span class="line">                 <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (rootType == TYPE_INPUT_METHOD) &#123;</span><br><span class="line">                 Slog.w(TAG_WM, <span class="string">&quot;Attempted to add input method window with unknown token &quot;</span></span><br><span class="line">                       + attrs.token + <span class="string">&quot;.  Aborting.&quot;</span>);</span><br><span class="line">                 <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (rootType == TYPE_VOICE_INTERACTION) &#123;</span><br><span class="line">                 Slog.w(TAG_WM, <span class="string">&quot;Attempted to add voice interaction window with unknown token &quot;</span></span><br><span class="line">                       + attrs.token + <span class="string">&quot;.  Aborting.&quot;</span>);</span><br><span class="line">                 <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (rootType == TYPE_WALLPAPER) &#123;</span><br><span class="line">                 Slog.w(TAG_WM, <span class="string">&quot;Attempted to add wallpaper window with unknown token &quot;</span></span><br><span class="line">                       + attrs.token + <span class="string">&quot;.  Aborting.&quot;</span>);</span><br><span class="line">                 <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">             &#125;</span><br><span class="line">             ...</span><br><span class="line">             <span class="keyword">if</span> (type == TYPE_TOAST) &#123;</span><br><span class="line">                 <span class="comment">// Apps targeting SDK above N MR1 cannot arbitrary add toast windows.</span></span><br><span class="line">                 <span class="keyword">if</span> (doesAddToastWindowRequireToken(attrs.packageName, callingUid,</span><br><span class="line">                         parentWindow)) &#123;</span><br><span class="line">                     Slog.w(TAG_WM, <span class="string">&quot;Attempted to add a toast window with unknown token &quot;</span></span><br><span class="line">                             + attrs.token + <span class="string">&quot;.  Aborting.&quot;</span>);</span><br><span class="line">                     <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> attrs.token != <span class="literal">null</span> ? attrs.token : client.asBinder();</span><br><span class="line">             token = <span class="keyword">new</span> <span class="title class_">WindowToken</span>(<span class="built_in">this</span>, binder, type, <span class="literal">false</span>, displayContent,</span><br><span class="line">                     session.mCanAddInternalSystemWindow);<span class="comment">//3</span></span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rootType &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; rootType &lt;= LAST_APPLICATION_WINDOW) &#123;<span class="comment">//4</span></span><br><span class="line">             atoken = token.asAppWindowToken();<span class="comment">//5</span></span><br><span class="line">             <span class="keyword">if</span> (atoken == <span class="literal">null</span>) &#123;</span><br><span class="line">                 Slog.w(TAG_WM, <span class="string">&quot;Attempted to add window with non-application token &quot;</span></span><br><span class="line">                       + token + <span class="string">&quot;.  Aborting.&quot;</span>);</span><br><span class="line">                 <span class="keyword">return</span> WindowManagerGlobal.ADD_NOT_APP_TOKEN;</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (atoken.removed) &#123;</span><br><span class="line">                 Slog.w(TAG_WM, <span class="string">&quot;Attempted to add window with exiting application token &quot;</span></span><br><span class="line">                       + token + <span class="string">&quot;.  Aborting.&quot;</span>);</span><br><span class="line">                 <span class="keyword">return</span> WindowManagerGlobal.ADD_APP_EXITING;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rootType == TYPE_INPUT_METHOD) &#123;</span><br><span class="line">             <span class="keyword">if</span> (token.windowType != TYPE_INPUT_METHOD) &#123;</span><br><span class="line">                 Slog.w(TAG_WM, <span class="string">&quot;Attempted to add input method window with bad token &quot;</span></span><br><span class="line">                         + attrs.token + <span class="string">&quot;.  Aborting.&quot;</span>);</span><br><span class="line">                   <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">   ...      </span><br></pre></td></tr></table></figure>

<p>注释1处通过displayContent的getWindowToken方法来得到WindowToken。注释2处，如果有父窗口就将父窗口的type值赋值给rootType，如果没有将当前窗口的type值赋值给rootType。接下来如果WindowToken为null，则根据rootType或者type的值进行区分判断，如果rootType值等于TYPE_INPUT_METHOD、TYPE_WALLPAPER等值时，则返回状态值WindowManagerGlobal.ADD_BAD_APP_TOKEN，说明rootType值等于TYPE_INPUT_METHOD、TYPE_WALLPAPER等值时是不允许WindowToken为null的。通过多次的条件判断筛选，最后会在注释3处隐式创建WindowToken，这说明当我们添加窗口时是可以不向WMS提供WindowToken的，前提是rootType和type的值不为前面条件判断筛选的值。WindowToken隐式和显式的创建肯定是要加以区分的，注释3处的第4个参数为false就代表这个WindowToken是隐式创建的。接下来的代码逻辑就是WindowToken不为null的情况，根据rootType和type的值进行判断，比如在注释4处判断如果窗口为应用程序窗口，在注释5处会将WindowToken转换为专门针对应用程序窗口的AppWindowToken，然后根据AppWindowToken的值进行后续的判断。</p>
<h4 id="addWindow方法part3"><a href="#addWindow方法part3" class="headerlink" title="addWindow方法part3"></a>addWindow方法part3</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"> ...</span><br><span class="line"><span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">win</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowState</span>(<span class="built_in">this</span>, session, client, token, parentWindow,</span><br><span class="line">                  appOp[<span class="number">0</span>], seq, attrs, viewVisibility, session.mUid,</span><br><span class="line">                  session.mCanAddInternalSystemWindow);<span class="comment">//1</span></span><br><span class="line">          <span class="keyword">if</span> (win.mDeathRecipient == <span class="literal">null</span>) &#123;<span class="comment">//2</span></span><br><span class="line">              <span class="comment">// Client has apparently died, so there is no reason to</span></span><br><span class="line">              <span class="comment">// continue.</span></span><br><span class="line">              Slog.w(TAG_WM, <span class="string">&quot;Adding window client &quot;</span> + client.asBinder()</span><br><span class="line">                      + <span class="string">&quot; that is dead, aborting.&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span> WindowManagerGlobal.ADD_APP_EXITING;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (win.getDisplayContent() == <span class="literal">null</span>) &#123;<span class="comment">//3</span></span><br><span class="line">              Slog.w(TAG_WM, <span class="string">&quot;Adding window to Display that has been removed.&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span> WindowManagerGlobal.ADD_INVALID_DISPLAY;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          mPolicy.adjustWindowParamsLw(win.mAttrs);<span class="comment">//4</span></span><br><span class="line">          win.setShowToOwnerOnlyLocked(mPolicy.checkShowToOwnerOnly(attrs));</span><br><span class="line">          res = mPolicy.prepareAddWindowLw(win, attrs);<span class="comment">//5</span></span><br><span class="line">          ...</span><br><span class="line">          win.attach();</span><br><span class="line">          mWindowMap.put(client.asBinder(), win);<span class="comment">//6</span></span><br><span class="line">          <span class="keyword">if</span> (win.mAppOp != AppOpsManager.OP_NONE) &#123;</span><br><span class="line">              <span class="type">int</span> <span class="variable">startOpResult</span> <span class="operator">=</span> mAppOps.startOpNoThrow(win.mAppOp, win.getOwningUid(),</span><br><span class="line">                      win.getOwningPackage());</span><br><span class="line">              <span class="keyword">if</span> ((startOpResult != AppOpsManager.MODE_ALLOWED) &amp;&amp;</span><br><span class="line">                      (startOpResult != AppOpsManager.MODE_DEFAULT)) &#123;</span><br><span class="line">                  win.setAppOpVisibilityLw(<span class="literal">false</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">final</span> <span class="type">AppWindowToken</span> <span class="variable">aToken</span> <span class="operator">=</span> token.asAppWindowToken();</span><br><span class="line">          <span class="keyword">if</span> (type == TYPE_APPLICATION_STARTING &amp;&amp; aToken != <span class="literal">null</span>) &#123;</span><br><span class="line">              aToken.startingWindow = win;</span><br><span class="line">              <span class="keyword">if</span> (DEBUG_STARTING_WINDOW) Slog.v (TAG_WM, <span class="string">&quot;addWindow: &quot;</span> + aToken</span><br><span class="line">                      + <span class="string">&quot; startingWindow=&quot;</span> + win);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="type">boolean</span> <span class="variable">imMayMove</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">          win.mToken.addWindow(win);<span class="comment">//7</span></span><br><span class="line">           <span class="keyword">if</span> (type == TYPE_INPUT_METHOD) &#123;</span><br><span class="line">              win.mGivenInsetsPending = <span class="literal">true</span>;</span><br><span class="line">              setInputMethodWindowLocked(win);</span><br><span class="line">              imMayMove = <span class="literal">false</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == TYPE_INPUT_METHOD_DIALOG) &#123;</span><br><span class="line">              displayContent.computeImeTarget(<span class="literal">true</span> <span class="comment">/* updateImeTarget */</span>);</span><br><span class="line">              imMayMove = <span class="literal">false</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (type == TYPE_WALLPAPER) &#123;</span><br><span class="line">                  displayContent.mWallpaperController.clearLastWallpaperTimeoutTime();</span><br><span class="line">                  displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((attrs.flags&amp;FLAG_SHOW_WALLPAPER) != <span class="number">0</span>) &#123;</span><br><span class="line">                  displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (displayContent.mWallpaperController.isBelowWallpaperTarget(win)) &#123;</span><br><span class="line">                  displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       ...</span><br></pre></td></tr></table></figure>

<p>在注释1处创建了WindowState，它存有窗口的所有的状态信息，在WMS中它代表一个窗口。从WindowState传入的参数，可以发现WindowState中包含了WMS、Session、WindowToken、父类的WindowState、LayoutParams等信息。紧接着在注释2和3处分别判断请求添加窗口的客户端是否已经死亡、窗口的DisplayContent是否为null，如果是则不会再执行下面的代码逻辑。注释4处调用了WMP的adjustWindowParamsLw方法，该方法的实现在PhoneWindowManager中，会根据窗口的type对窗口的LayoutParams的一些成员变量进行修改。注释5处调用WMP的prepareAddWindowLw方法，用于准备将窗口添加到系统中。<br>注释6处将WindowState添加到mWindowMap中。注释7处将WindowState添加到该WindowState对应的WindowToken中(实际是保存在WindowToken的父类WindowContainer中)，这样WindowToken就包含了相同组件的WindowState。</p>
<h4 id="addWindow方法总结"><a href="#addWindow方法总结" class="headerlink" title="addWindow方法总结"></a>addWindow方法总结</h4><p>addWindow方法分了3个部分来进行讲解，主要就是做了下面4件事：</p>
<ol>
<li>对所要添加的窗口进行检查，如果窗口不满足一些条件，就不会再执行下面的代码逻辑。</li>
<li>WindowToken相关的处理，比如有的窗口类型需要提供WindowToken，没有提供的话就不会执行下面的代码逻辑，有的窗口类型则需要由WMS隐式创建WindowToken。</li>
<li>WindowState的创建和相关处理，将WindowToken和WindowState相关联。</li>
<li>创建和配置DisplayContent，完成窗口添加到系统前的准备工作。</li>
</ol>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在本篇文章中我们首先学习了WMS的重要成员，了解这些成员有利于对WMS的进一步分析。接下来我们又学习了Window的添加过程的WMS部分，将addWindow方法分为了3个部分来进行讲解，从addWindow方法我们得知WMS有3个重要的类分别是WindowToken、WindowState和DisplayContent，关于它们会在本系列后续的文章中进行介绍。</p>
<h2 id="WMS（三）：Window的删除过程"><a href="#WMS（三）：Window的删除过程" class="headerlink" title="WMS（三）：Window的删除过程"></a>WMS（三）：Window的删除过程</h2><p>在本系列文章中，我提到过：Window的操作分为两大部分，一部分是WindowManager处理部分，另一部分是WMS处理部分，Window的删除过程也不例外，本篇文章会介绍Window的删除过程，包括了两大处理部分的内容。</p>
<h3 id="Window的删除过程"><a href="#Window的删除过程" class="headerlink" title="Window的删除过程"></a>Window的删除过程</h3><p>和<a href="https://link.juejin.cn/?target=http://liuwangshu.cn/framework/wms/2-wms-member.html">Android解析WindowManagerService（二）WMS的重要成员和Window的添加过程</a>这篇文章中Window的创建和更新过程类似，要删除Window需要先调用WindowManagerImpl的removeView方法，removeView方法中又会调用WindowManagerGlobal的removeView方法，我们就从这里开始讲起。为了表述的更易于理解，本文将要删除的Window（View）简称为V。WindowManagerGlobal的removeView方法如下所示。</p>
<p><strong>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;WindowManagerGlobal.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeView</span><span class="params">(View view, <span class="type">boolean</span> immediate)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (view == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;view must not be null&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> findViewLocked(view, <span class="literal">true</span>);<span class="comment">//1</span></span><br><span class="line">          <span class="type">View</span> <span class="variable">curView</span> <span class="operator">=</span> mRoots.get(index).getView();</span><br><span class="line">          removeViewLocked(index, immediate);<span class="comment">//2</span></span><br><span class="line">          <span class="keyword">if</span> (curView == view) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Calling with view &quot;</span> + view</span><br><span class="line">                  + <span class="string">&quot; but the ViewAncestor is attached to &quot;</span> + curView);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>注释1处找到要V在View列表中的索引，在注释2处调用了removeViewLocked方法并将这个索引传进去，如下所示。 <strong>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;WindowManagerGlobal.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeViewLocked</span><span class="params">(<span class="type">int</span> index, <span class="type">boolean</span> immediate)</span> &#123;</span><br><span class="line">       <span class="type">ViewRootImpl</span> <span class="variable">root</span> <span class="operator">=</span> mRoots.get(index);<span class="comment">//1</span></span><br><span class="line">       <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> root.getView();</span><br><span class="line">       <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="type">InputMethodManager</span> <span class="variable">imm</span> <span class="operator">=</span> InputMethodManager.getInstance();<span class="comment">//2</span></span><br><span class="line">           <span class="keyword">if</span> (imm != <span class="literal">null</span>) &#123;</span><br><span class="line">               imm.windowDismissed(mViews.get(index).getWindowToken());<span class="comment">//3</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">deferred</span> <span class="operator">=</span> root.die(immediate);<span class="comment">//4</span></span><br><span class="line">       <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">           view.assignParent(<span class="literal">null</span>);</span><br><span class="line">           <span class="keyword">if</span> (deferred) &#123;</span><br><span class="line">               mDyingViews.add(view);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>注释1处根据传入的索引在ViewRootImpl列表中获得V的ViewRootImpl。注释2处得到InputMethodManager实例，如果InputMethodManager实例不为null则在注释3处调用InputMethodManager的windowDismissed方法来结束V的输入法相关的逻辑。注释4处调用ViewRootImpl 的die方法，如下所示。</p>
<p><strong>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;ViewRootImpl.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">die</span><span class="params">(<span class="type">boolean</span> immediate)</span> &#123;</span><br><span class="line">      <span class="comment">//die方法需要立即执行并且此时ViewRootImpl不在执行performTraversals方法</span></span><br><span class="line">      <span class="keyword">if</span> (immediate &amp;&amp; !mIsInTraversal) &#123;<span class="comment">//1</span></span><br><span class="line">          doDie();<span class="comment">//2</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!mIsDrawing) &#123;</span><br><span class="line">          destroyHardwareRenderer();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Log.e(mTag, <span class="string">&quot;Attempting to destroy the window while drawing!\n&quot;</span> +</span><br><span class="line">                  <span class="string">&quot;  window=&quot;</span> + <span class="built_in">this</span> + <span class="string">&quot;, title=&quot;</span> + mWindowAttributes.getTitle());</span><br><span class="line">      &#125;</span><br><span class="line">      mHandler.sendEmptyMessage(MSG_DIE);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>注释1处如果immediate为ture（需要立即执行），并且mIsInTraversal值为false则执行注释2处的代码，mIsInTraversal在执行ViewRootImpl的performTraversals方法时会被设置为true，在performTraversals方法执行完时被设置为false，因此注释1处可以理解为die方法需要立即执行并且此时ViewRootImpl不在执行performTraversals方法。注释2处的doDie方法如下所示。<br> <strong>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;ViewRootImpl.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">doDie</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//检查执行doDie方法的线程的正确性</span></span><br><span class="line">    checkThread();<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">if</span> (LOCAL_LOGV) Log.v(mTag, <span class="string">&quot;DIE in &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot; of &quot;</span> + mSurface);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRemoved) &#123;<span class="comment">//2</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mRemoved = <span class="literal">true</span>;<span class="comment">//3</span></span><br><span class="line">        <span class="keyword">if</span> (mAdded) &#123;<span class="comment">//4</span></span><br><span class="line">            dispatchDetachedFromWindow();<span class="comment">//5</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mAdded &amp;&amp; !mFirst) &#123;<span class="comment">//6</span></span><br><span class="line">            destroyHardwareRenderer();</span><br><span class="line">            <span class="keyword">if</span> (mView != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">viewVisibility</span> <span class="operator">=</span> mView.getVisibility();</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">viewVisibilityChanged</span> <span class="operator">=</span> mViewVisibility != viewVisibility;</span><br><span class="line">                <span class="keyword">if</span> (mWindowAttributesChanged || viewVisibilityChanged) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((relayoutWindow(mWindowAttributes, viewVisibility, <span class="literal">false</span>)</span><br><span class="line">                                &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != <span class="number">0</span>) &#123;</span><br><span class="line">                            mWindowSession.finishDrawing(mWindow);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                mSurface.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mAdded = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    WindowManagerGlobal.getInstance().doRemoveView(<span class="built_in">this</span>);<span class="comment">//7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处用于检查执行doDie方法的线程的正确性，注释1的内部会判断执行doDie方法线程是否是创建V的原始线程，如果不是就会抛出异常，这是因为只有创建V的原始线程才能够操作V。注释2到注释3处的代码用于防止doDie方法被重复调用。注释4处V有子View就会调用dispatchDetachedFromWindow方法来销毁View。注释6处如果V有子View并且不是第一次被添加，就会执行后面的代码逻辑。注释7处的WindowManagerGlobal的doRemoveView方法，如下所示。 <strong>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;WindowManagerGlobal.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">doRemoveView</span><span class="params">(ViewRootImpl root)</span> &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> mRoots.indexOf(root);<span class="comment">//1</span></span><br><span class="line">          <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              mRoots.remove(index);</span><br><span class="line">              mParams.remove(index);</span><br><span class="line">              <span class="keyword">final</span> <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> mViews.remove(index);</span><br><span class="line">              mDyingViews.remove(view);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (ThreadedRenderer.sTrimForeground &amp;&amp; ThreadedRenderer.isAvailable()) &#123;</span><br><span class="line">          doTrimForeground();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>WindowManagerGlobal中维护了和 Window操作相关的三个列表，doRemoveView方法会从这三个列表中清除V对应的元素。注释1处找到V对应的ViewRootImpl在ViewRootImpl列表中的索引，接着根据这个索引从ViewRootImpl列表、布局参数列表和View列表中删除与V对应的元素。 我们接着回到ViewRootImpl的doDie方法，查看注释5处的dispatchDetachedFromWindow方法里做了什么： <strong>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;ViewRootImpl.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dispatchDetachedFromWindow</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          mWindowSession.remove(mWindow);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>dispatchDetachedFromWindow方法中主要调用了IWindowSession的remove方法，IWindowSession在Server端的实现为Session，Session的remove方法如下所示。 <strong>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;Session.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(IWindow window)</span> &#123;</span><br><span class="line">     mService.removeWindow(<span class="built_in">this</span>, window);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>接着查看WMS的removeWindow方法： <strong>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowManagerService .java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">removeWindow</span><span class="params">(Session session, IWindow client)</span> &#123;</span><br><span class="line">     <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">         <span class="type">WindowState</span> <span class="variable">win</span> <span class="operator">=</span> windowForClientLocked(session, client, <span class="literal">false</span>);<span class="comment">//1</span></span><br><span class="line">         <span class="keyword">if</span> (win == <span class="literal">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         win.removeIfPossible();<span class="comment">//2</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>注释1处用于获取Window对应的WindowState，WindowState用于保存窗口的信息，在WMS中它用来描述一个窗口。接着在注释2处调用WindowState的removeIfPossible方法，如下所示。 <strong>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeIfPossible</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.removeIfPossible();</span><br><span class="line">    removeIfPossible(<span class="literal">false</span> <span class="comment">/*keepVisibleDeadWindow*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又会调用removeIfPossible方法，如下所示。 <strong>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeIfPossible</span><span class="params">(<span class="type">boolean</span> keepVisibleDeadWindow)</span> &#123;</span><br><span class="line">        ...条件判断过滤，满足其中一个条件就会<span class="keyword">return</span>，推迟删除操作</span><br><span class="line">	removeImmediately();<span class="comment">//1</span></span><br><span class="line">	<span class="keyword">if</span> (wasVisible &amp;&amp; mService.updateOrientationFromAppTokensLocked(<span class="literal">false</span>, displayId)) &#123;</span><br><span class="line">		mService.mH.obtainMessage(SEND_NEW_CONFIGURATION, displayId).sendToTarget();</span><br><span class="line">	&#125;</span><br><span class="line">	mService.updateFocusedWindowLocked(UPDATE_FOCUS_NORMAL, <span class="literal">true</span> <span class="comment">/*updateInputWindows*/</span>);</span><br><span class="line">	Binder.restoreCallingIdentity(origId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>removeIfPossible方法和它的名字一样，并不是直接执行删除操作，而是进行多个条件判断过滤，满足其中一个条件就会return，推迟删除操作。比如这时V正在运行一个动画，这时就得推迟删除操作，直到动画完成。通过这些条件判断过滤就会执行注释1处的removeImmediately方法： <strong>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;WindowState.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeImmediately</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.removeImmediately();</span><br><span class="line">    <span class="keyword">if</span> (mRemoved) &#123;<span class="comment">//1</span></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_ADD_REMOVE) Slog.v(TAG_WM,</span><br><span class="line">                <span class="string">&quot;WS.removeImmediately: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot; Already removed...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mRemoved = <span class="literal">true</span>;<span class="comment">//2</span></span><br><span class="line">    ...</span><br><span class="line">    mPolicy.removeWindowLw(<span class="built_in">this</span>);<span class="comment">//3</span></span><br><span class="line">    disposeInputChannel();</span><br><span class="line">    mWinAnimator.destroyDeferredSurfaceLocked();</span><br><span class="line">    mWinAnimator.destroySurfaceLocked();</span><br><span class="line">    mSession.windowRemovedLocked();<span class="comment">//4</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mClient.asBinder().unlinkToDeath(mDeathRecipient, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;          </span><br><span class="line">    &#125;</span><br><span class="line">    mService.postWindowRemoveCleanupLocked(<span class="built_in">this</span>);<span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>removeImmediately方法如同它的名字一样，用于立即进行删除操作。注释1处的mRemoved为true意味着正在执行删除Window操作，注释1到注释2处之间的代码用于防止重复删除操作。注释3处如果当前要删除的Window是StatusBar或者NavigationBar就会将这个Window从对应的控制器中删除。注释4处会将V对应的Session从WMS的<code>ArraySet&lt;Session&gt; mSessions</code>中删除并清除Session对应的SurfaceSession资源（SurfaceSession是SurfaceFlinger的一个连接，通过这个连接可以创建1个或者多个Surface并渲染到屏幕上 ）。注释5处调用了WMS的postWindowRemoveCleanupLocked方法用于对V进行一些集中的清理工作，这里就不在继续深挖下去，有兴趣的同学可以自行查看源码。</p>
<p>Window的删除过程就讲到这里，虽然删除的操作逻辑比较复杂，但是可以简单的总结为以下4点：</p>
<ol>
<li>检查删除线程的正确性，如果不正确就抛出异常。</li>
<li>从ViewRootImpl列表、布局参数列表和View列表中删除与V对应的元素。</li>
<li>判断是否可以直接执行删除操作，如果不能就推迟删除操作。</li>
<li>执行删除操作，清理和释放与V相关的一切资源。</li>
</ol>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 jaytp@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 Yelog
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
